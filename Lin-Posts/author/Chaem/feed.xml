<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="/author/Chaem/feed.xml" rel="self" type="application/atom+xml" />
  <link href="/" rel="alternate" type="text/html" />
  <updated>2019-05-06T20:44:24+09:00</updated>
  <id>/author/Chaem/feed.xml</id>

  
  
  

  
    <title type="html">LIN ARENA | </title>
  

  
    <subtitle>LIN ARENA Technology Blog</subtitle>
  

  

  
    
      
    
      
    
      
    
      
    
      
    
  

  
  

  
    <entry>
      <title type="html">android-0x02</title>
      <link href="/android-0x02" rel="alternate" type="text/html" title="android-0x02" />
      <published>2019-04-12T14:00:00+09:00</published>
      <updated>2019-04-12T14:00:00+09:00</updated>
      <id>/android-0x02</id>
      <content type="html" xml:base="/android-0x02">&lt;h1 id=&quot;android-동적-분석&quot;&gt;Android 동적 분석&lt;/h1&gt;

&lt;p&gt;안녕하세요 chaem 입니다.&lt;/p&gt;

&lt;p&gt;지난 포스팅에서 다루었던 Android 정적 분석에 이어서 이번에는 Android 동적 분석에 대해 포스팅 하려고 합니다.&lt;/p&gt;

&lt;p&gt;Android를 동적 분석하는 방법은 다양하지만 이번 포스팅에서는 FRIDA이용하는 방법에 대해 알아보겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;frida&quot;&gt;FRIDA&lt;/h4&gt;
&lt;p&gt;FRIDA를 이용한 동적 분석은 Android 앱을 후킹하여 분석하는 방법입니다.&lt;/p&gt;

&lt;p&gt;분석 환경은 아래와 같습니다.&lt;/p&gt;

&lt;p&gt;OS : Window7&lt;/p&gt;

&lt;p&gt;Tools : FRIDA, frida-server, nox, adb, python, pip&lt;/p&gt;

&lt;p&gt;FRIDA를 사용하기 위해서는 python 및 pip가 설치되어있어야 하며,&lt;br /&gt;
아래와 같이 cmd에서 “pip install  frida” 명령어를 입력하여 FRIDA를 쉽게 설치할 수 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/01.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;FRIDA 설치 후 하기 링크에서 Android architecure에 맞는 frida-server를 다운로드합니다.&lt;/p&gt;

&lt;p&gt;https://github.com/frida/frida/releases&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/02.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;

다운로드한 frida-server를 Android 기기에 설치하고 실행 권한 부여 후 실행시켜줍니다.
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/03.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;


아래 링크의 예제 앱을 이용해서 동적 분석을 진행하겠습니다.&lt;br /&gt;
https://github.com/OWASP/owasp-mstg/tree/master/Crackmes/Android&lt;br /&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/03-1.png&quot; alt=&quot;[그림 1-3-1]&quot; /&gt;
&lt;/figure&gt;
&lt;br /&gt;
  
앱을 실행하면 루팅을 탐지하게 되고, ok 버튼을 누르면 앱이 종료되는 것을 확인할 수 있습니다.  
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/04.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;

앱이 종료되지 않도록 후킹 포인트를 찾기 위해 MainActivity를 확인해보겠습니다.&lt;br /&gt;
MainActivity를 살펴보면 ok 버튼을 누르면 System.exit(0)를 호출하는 것을 확인할 수 있습니다.

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/05.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;

따라서 System.exit 함수가 호출될 때 해당 함수를 후킹해보도록 하겠습니다.&lt;br /&gt;
아래 python 코드를 이용해 후킹을 시도하면 ok 버튼을 눌러도 앱이 종료되지 않는 것을 확인할 수 있습니다.
 
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/06.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;

이후 특정 문자열을 입력하여 인증하는 절차가 나옵니다.
아래와 같이 잘못된 문자열을 입력할 시 재시도하라는 메시지가 출력되고 있습니다.

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/07.png&quot; alt=&quot;[그림 1-7]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;

특정 문자열 확인을 위해 아래 verify 함수를 확인해보면 인증 로직인 if(a.a(obj))을 확인할 수 있습니다.

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/08.png&quot; alt=&quot;[그림 1-8]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;

sg.vantagepoint.uncrackable1.a class에서는 입력된 문자열과 암호를 복호화한 값과 비교하여 결과를 리턴하는 것을 확인할 수 있습니다.

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/09.png&quot; alt=&quot;[그림 1-9]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;

마지막으로 sg.vantagepoint.a.a class의 a함수를 확인해보면 최종으로 복호화된 문자열을 리턴하는 것을 확인할 수 있습니다.

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/10.png&quot; alt=&quot;[그림 1-10]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;

분석한 결과를 토대로 암호화된 특정 문자열을 복호화하여 출력하는 python 코드를 아래와 같이 작성해보았습니다.

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/11.png&quot; alt=&quot;[그림 1-11]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;

코드를 실행한 결과 복호화된 문자열을 확인할 수 있었고, 해당 문자열을 입력한 결과 성공이라는 메시지가 출력되는 것을 확인했습니다.

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/12.png&quot; alt=&quot;[그림 1-12]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;


지금까지 Android 동적 분석에 대해 알아보았고, 다음 포스팅에서는 SSL Pinning 우회 방법에 대해 알아보도록 하겠습니다.&lt;br /&gt;
&lt;br /&gt;
감사합니다.

&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;</content>

      
      
      
      
      

      <author>
          <name>Chaem</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">Android 동적 분석</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">android-0x01</title>
      <link href="/android-0x01" rel="alternate" type="text/html" title="android-0x01" />
      <published>2019-03-29T14:00:00+09:00</published>
      <updated>2019-03-29T14:00:00+09:00</updated>
      <id>/android-0x01</id>
      <content type="html" xml:base="/android-0x01">&lt;h1 id=&quot;android-정적-분석&quot;&gt;Android 정적 분석&lt;/h1&gt;

&lt;p&gt;안녕하세요 chaem 입니다.&lt;/p&gt;

&lt;p&gt;지난 포스팅에 이어서 이번에는 Android 정적 분석에 대해 포스팅 하려고 합니다.&lt;/p&gt;

&lt;p&gt;Android 정적 분석은 크게 2가지로 분류할 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;-압축-해제-후-분석&quot;&gt;-압축 해제 후 분석&lt;/h4&gt;
&lt;p&gt;첫째로 Android 앱은 .apk 파일 확장자를 가지며, 압축된 형태이므로 압축을 해제한 후 해당 파일을 분석하는 방법입니다.&lt;/p&gt;

&lt;p&gt;아래 그림과 같이 apk 파일을 압축 해제하면 class.dex 파일이 생성되는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/01.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이 class.dex 파일을 dex -&amp;gt; jar -&amp;gt; java 로 decompile 하면 소스코드를 확인 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;우선 dex2jar를 이용하여 dex -&amp;gt; jar로 decompile 합니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/02.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;jar 파일은 jd-gui를 이용해 decompile하여 소스코드를 확인할 수 있으며, 아래와 같이 난독화가 적용되어 있지 않으면 소스코드 분석을 통해 루팅 탐지 우회 등이 가능합니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/03.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;아래와 같이 jadx-gui를 이용하면 apk 파일을 바로 java 소스 코드로 확인할 수 있는 방법도 있습니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/04.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;-decompile-후-분석&quot;&gt;-Decompile 후 분석&lt;/h4&gt;
&lt;p&gt;두번째는 apk파일을 decompile한 후 해당 파일을 분석하는 방법입니다.&lt;/p&gt;

&lt;p&gt;apktool을 이용하면 아래 그림과 같이 apk 파일이 decompile되는 것을 확인할 수 있습니다.
주요 분석 대상은 AndroidManifest 파일,  smali 코드, lib 폴더 등이 있습니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/05.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;AndroidManifest.xml 파일은 해당 앱에 대한 권한 등의 필수적인 정보를 포함하고 있으며, 앱에서 불필요한 권한을 요청하고 있는지 확인해보아야 합니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/06.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;smali 코드는 An assembler/disassembler for Android’s dex format의 약자로 코드 분석을 통해 실행 원리를 파악할 수 있습니다. 따라서 코드 수정 후 리패키징을 통해 앱 변조가 가능합니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/07.png&quot; alt=&quot;[그림 1-7]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/08.png&quot; alt=&quot;[그림 1-8]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;lib 폴더 내에는 동적라이브러리인 *.so 파일을 포함하며, 보통 보안 솔루션들이 동적 라이브러리로 존재하고 있습니다. 아래 그림과 같이 IDA를 통해 분석이 가능하며, 보안 솔루션에서 루팅을 탐지하는 로직을 확인할 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/09.png&quot; alt=&quot;[그림 1-9]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;지금까지 Android 정적 분석에 대해 알아보았고, 다음 포스팅에서는 Android 동적 분석에 대해 알아보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;감사합니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Chaem</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">Android 정적 분석</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">mobile-0x00</title>
      <link href="/android-0x00" rel="alternate" type="text/html" title="mobile-0x00" />
      <published>2019-03-16T06:00:00+09:00</published>
      <updated>2019-03-16T06:00:00+09:00</updated>
      <id>/android-0x00</id>
      <content type="html" xml:base="/android-0x00">&lt;h1 id=&quot;0x00-introduction&quot;&gt;0x00. Introduction&lt;/h1&gt;

&lt;p&gt;안녕하세요. Chaem 입니다.&lt;/p&gt;

&lt;p&gt;Mobile Android 해킹을 주제로 포스팅을 시작하려고 합니다.
우선 Mobile OWASP Top 10에 등록된  주요 취약점을 간단히 리뷰하고 이후 해당 취약점들을 이용한 Android 해킹과 관련된 내용으로 포스팅을 진행하도록 하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;mobile-owasp-top-10&quot;&gt;Mobile OWASP Top 10&lt;/h5&gt;
&lt;p&gt;OWASP(The Open Web Application Security Project)란 국제 웹 보안 표준기군이며, 웹에 관한 주요 보안 취약점들을 연구하며, 4년 마다 취약점 Top 10 을 발표하고 있습니다. 
OWASP 모바일 보안 프로젝트는 개발자와 보안팀이 모바일 어플리케이션을 안전하게 구축하고 유지, 관리하는데 필요한 리소스를 제공하며 앞으로 일어날 수 있는 영향도와 위험성을 줄이기 위해 진행되고 있습니다. 모바일은 2년 마다 취약점 Top 10을 발표하고 있으며, 현재 가장 최신 자료는 2016년 release된 자료입니다.(아래 그림 참조)
그럼 Mobile OWASP Top 10의 각 취약점에 대해 리뷰해보도록 하겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/Mobile%20OWASP%20TOP10.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;m1---improper-platform-usage&quot;&gt;M1 - Improper Platform Usage&lt;/h4&gt;
&lt;p&gt;첫번째 M1은 부적절한 플랫폼 사용에 관한 취약점입니다. 
이 취약점은 플랫폼 기능의 오용이나 보안 설정이 잘못될 경우 발생하는 문제에 대해 다루고 있습니다.
주로 개발자들의 실수로 인해 발생하며, 문제는 공격 가능성은 쉬우나 그에 따른 영향도가 심각하다는 점입니다.
대응방안으로는 시큐어 코딩과 보안 설정을 서버 단에서 진행하는 것입니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/M1.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;m2---insecure-data-storage&quot;&gt;M2 - Insecure Data Storage&lt;/h4&gt;
&lt;p&gt;M2는 취약한 데이터 저장소에 관한 취약점입니다. 
이 취약점은 안전하지 않은 데이터 저장소로 인해 의도하지 않은 데이터 유출로 발생하는 문제에 대해 다루고 있습니다. 공격 가능성은 쉬우나 영향도는 심각하며 신분 도용, 개인 정보 침해 등의 위험을 초래합니다.
대응방안은 아래와 같은 기능을 통해 중요 정보를 내부 저장소에 저장하지 않아야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;URL caching (both request and response)&lt;/li&gt;
  &lt;li&gt;Keyboard press caching&lt;/li&gt;
  &lt;li&gt;Copy/Paste buffer caching&lt;/li&gt;
  &lt;li&gt;Application backgrounding&lt;/li&gt;
  &lt;li&gt;Intermediate data&lt;/li&gt;
  &lt;li&gt;Logging&lt;/li&gt;
  &lt;li&gt;HTML5 data storage&lt;/li&gt;
  &lt;li&gt;Browser cookie objects&lt;/li&gt;
  &lt;li&gt;Analytics data sent to 3rd parties&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/M3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;m3---insecure-communication&quot;&gt;M3 - Insecure Communication&lt;/h4&gt;
&lt;p&gt;M3는 취약한 통신에 관한 취약점입니다. 이 취약점은 악의적인 handshaking, 잘못된 SSL 버전, 약한 협상, 민감 정보의 평문 통신으로 발생하는 문제에 대해 다루고 있습니다. 공격 가능성은 쉬우나 영향도는 심각하며, 피싱 및 MITM 공격에 의해 중요 정보가 노출될 수 있습니다.
대응방안은 SSL/TLS 적용, 강한 cipher suites 사용, 인증서 확인 등이 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/M2.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;m4---insecure-authentication&quot;&gt;M4 - Insecure Authentication&lt;/h4&gt;
&lt;p&gt;M4는 취약한 인증에 관한 취약점입니다. 이 취약점은 사용자 인증 또는 잘못된 세션 관리로 인해 발생하는 문제에 대해 다루고 있습니다. 공격 가능성은 쉬우나 영향도는 심각하며, 대응방안은 약한 인증 패턴을 피하고, 인증을 강화하는 방법입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/M4.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;m5---insufficient-cryptography&quot;&gt;M5 - Insufficient Cryptography&lt;/h4&gt;
&lt;p&gt;M5는 취약한 암호화에 관한 취약점입니다. 이 취약점은 키관리 문제, 커스텀 암호화 생성, 취약한 암호화 알고리즘 사용 시 발생하는 문제에 대해 다루고 있습니다. 공격 가능성은 쉬우나 영향도는 심각하며, 대응방안은 모바일 기기에 중요한 정보를 저장하지 말아야 하며, 검증된 암호화 표준을 적용하는 방법입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/M5.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;m6---insecure-authorization&quot;&gt;M6 - Insecure Authorization&lt;/h4&gt;
&lt;p&gt;M6는 취약한 권한에 관한 취약점입니다. 이 취약점은 안전하지 않은 권한을 부여하여 발생하는 문제에 대해 다루고 있습니다. 공격 가능성은 쉬우나 영향도는 심각하며, 대응방안은 서버 단에서 사용자의 역할 및 권한을 확인해야 하며, 어플리케이션의 필요한 퍼미션만 설정하는 방법입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/M6.png&quot; alt=&quot;[그림 1-7]&quot; /&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;m7---client-code-quality&quot;&gt;M7 - Client Code Quality&lt;/h4&gt;
&lt;p&gt;M7는 클라이언트 코드 품질에 관한 취약점입니다. 이 취약점은 잘못된 코드 구현으로 인해 클라이언트에서 발생하는 문제에 대해 다루고 있습니다. 공격 가능성은 어렵고 영향도는 보통이며 버퍼오버플로우, XSS등의 취약점으로 이어질 수 있습니다.
대응방안은 버퍼 사용 시 입력 버퍼의 길이를 확인하는 등 안전한 구문을 사용하는 방법입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/M7.png&quot; alt=&quot;[그림 1-8]&quot; /&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;m8---code-tampering&quot;&gt;M8 - Code Tampering&lt;/h4&gt;
&lt;p&gt;M8는 코드 변조에 관한 취약점입니다. 이 취약점은 바이너리 패치, 로컬 리소스 수정, 메소드 후킹 및 변경, 동적 메모리 수정등 코드 변조 시 발생하는 문제에 대해 다루고 있습니다. 공격 가능성은 쉬우나 영향도는 심각하며, 대응방안은 무결성 체크, 루팅 탐지등의 방법이 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/M8.png&quot; alt=&quot;[그림 1-9]&quot; /&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;m9---reverse-engineering&quot;&gt;M9 - Reverse Engineering&lt;/h4&gt;
&lt;p&gt;M9는 역공학에 관한 취약점입니다. 이 취약점은 라이브러리, 알고리즘, 핵심 바이너리 등의 분석을 통해 중요 로직을 파악하여 발생되는 문제 대해 다루고 있습니다. 공격 가능성은 쉬우나 영향도는 보통이며,
대응방안은 바이너리 암호화와, 코드 난독화를 적용하여 리버싱을 방지하는 방법입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/M9.png&quot; alt=&quot;[그림 1-10]&quot; /&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;m10---extraneous-functionality&quot;&gt;M10 - Extraneous Functionality&lt;/h4&gt;
&lt;p&gt;마지막으로 M10는 불필요한 기능에 관한 취약점입니다. 이 취약점은 개발자가 숨겨놓은 기능이나 운영 환경에 적용하지 않는 개발 환경 기능을 악용하여 발생하는 문제에 대해 다루고 있습니다. 공격 가능성은 쉬우나 영향도는 심각하며, 대응방안은 테스트 코드가 포함되어 있는지 확인하고, 모든 로그를 검사하여 과도한 설명이 포함되어 있는지 확인하는 방법입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/M10.png&quot; alt=&quot;[그림 1-11]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Mobile OWASP Top 10에 대해 간략히 리뷰해봤고, 자세한 내용은 원문에서 확인하실 수 있습니다.
다음 포스팅에서는 안드로이드 정적 분석에 대해 알아보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;감사합니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Chaem</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x00. Introduction</summary>
      

      
      
    </entry>
  
</feed>
