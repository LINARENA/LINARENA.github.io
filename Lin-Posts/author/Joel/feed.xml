<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="/author/Joel/feed.xml" rel="self" type="application/atom+xml" />
  <link href="/" rel="alternate" type="text/html" />
  <updated>2019-04-07T14:41:55+09:00</updated>
  <id>/author/Joel/feed.xml</id>

  
  
  

  
    <title type="html">LIN ARENA | </title>
  

  
    <subtitle>LIN ARENA Technology Blog</subtitle>
  

  

  
    
      
    
      
    
      
    
      
    
      
    
  

  
  

  
    <entry>
      <title type="html">Windows-Heap 정의</title>
      <link href="/windows-0x0a" rel="alternate" type="text/html" title="Windows-Heap 정의" />
      <published>2019-04-02T20:18:00+09:00</published>
      <updated>2019-04-02T20:18:00+09:00</updated>
      <id>/windows-0x0a</id>
      <content type="html" xml:base="/windows-0x0a">&lt;h1 id=&quot;0x0a-windows-heap&quot;&gt;0x0a Windows-Heap&lt;/h1&gt;

&lt;p&gt;안녕하세요. Joel입니다.&lt;/p&gt;

&lt;p&gt;오늘부터는 Windows Heap에 대해 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;what-is-heap&quot;&gt;What is Heap?&lt;/h5&gt;

&lt;p&gt;Heap은 프로세스가 실행되는 동안 메모리를 필요한만큼 동적으로 할당하여 사용하는 영역입니다.&lt;/p&gt;

&lt;p&gt;그리고 c/c++에서는 malloc, new 함수를 사용하여 Heap 영역을 할당받아 사용합니다.&lt;/p&gt;

&lt;p&gt;윈도우에서는 힙을 이용할 수 있도록 API 함수들을 제공하고 있는데 대표적인 윈도우 힙 함수는 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HeapCreate : 힙을 생성합니다.&lt;/li&gt;
  &lt;li&gt;HeapDestroy : 힙을 삭제합니다.&lt;/li&gt;
  &lt;li&gt;HeapAlloc : 힙 블록을 할당합니다.&lt;/li&gt;
  &lt;li&gt;HeapFree : 할당된 힙 블록을 해제합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 정도는 이미 알고 계실거라 생각합니다.&lt;/p&gt;

&lt;p&gt;그럼 조금만 더 상세하게 알아볼게요.&lt;/p&gt;

&lt;h5 id=&quot;process-heap&quot;&gt;Process Heap&lt;/h5&gt;

&lt;p&gt;Process가 시작되면 최소한 하나의 기본 Process Heap(또는 Default Heap)이 생성됩니다.&lt;/p&gt;

&lt;p&gt;이 Process Heap은 Process 시작 시에 생성되고(기본 크기는 1MB) Process가 종료될 때까지 없어지지 않는 특징이 있습니다.&lt;/p&gt;

&lt;p&gt;흔히 사용하는 malloc, new는 Process Heap에서 할당하는 것입니다.&lt;/p&gt;

&lt;p&gt;이 기본 Heap은 프로그램 내에서 명시적으로 사용될 수도 있고 윈도우 내부 함수에 의해 암묵적으로 사용될 수도 있는데 프로그램에서 GetProcessHeap을 이용해 기본 Process Heap을 구할 수 있습니다.&lt;/p&gt;

&lt;p&gt;요약을 해보자면, Process가 시작되면 기본 Heap이 생성된다는 것과 malloc, new를 이용해서 아래 그림처럼 Heap을 할당받아 사용한다는 것입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;지금까지 기본 Heap에 대한 설명을 했는데요,&lt;/p&gt;

&lt;p&gt;지금부터는 위 그림처럼 하나만 할당받는 것이 아닌 다양한 크기의 Heap 공간을 반복적으로 할당/해제하는 경우를 한 번 생각해보겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;heap-fragmentation&quot;&gt;Heap Fragmentation&lt;/h5&gt;

&lt;p&gt;사용자가 Heap 공간을 쓰기 위해 할당을 요청하면 사용가능한 “연속된” 공간이 할당됩니다.&lt;/p&gt;

&lt;p&gt;그런데 다양한 크기의 Heap 공간을 요청하고 해제한다고 생각해봅시다.&lt;/p&gt;

&lt;p&gt;분명 할당받은 순서대로 해제하지는 않겠죠?&lt;/p&gt;

&lt;p&gt;정해진 순서없이 다양한 크기의 Heap이 할당되고 해제된다면, 아래 그림처럼 특정 순간에는 원하는 크기의 Heap을 할당해줄 수 없는 순간이 올 겁니다.&lt;/p&gt;

&lt;p&gt;이를 Heap Fragmentation(힙 단편화)이라고 합니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 그림에서 보듯, 남은 메모리 용량의 총합은 할당을 원하는 객체의 크기보다 크지만 연속된 공간을 할당해 줄 수 없는 상황이 옵니다.&lt;/p&gt;

&lt;p&gt;윈도우는 이러한 단편화 문제를 해결하기 위해서 특별한 방식들을 사용하고 있습니다.&lt;/p&gt;

&lt;p&gt;이 방식들을 살펴보면서 Heap에 대한 이해를 더 높여보겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;free-list&quot;&gt;Free List&lt;/h5&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;
&lt;center&gt;http://www.slideshare.net/ffri/mr201312-history-and-current-state-of-heap-exploit-eng&lt;/center&gt;

&lt;p&gt;Free List란 말 그대로 해제된 Heap 메모리들을 담아두는 List입니다.&lt;/p&gt;

&lt;p&gt;어떤 메모리를 할당해서 사용하고 난 뒤, 해제를 하면 그 메모리는 Free List에 들어가게 됩니다.&lt;/p&gt;

&lt;p&gt;그리고 다음 메모리를 할당하려고 하면 Heap 공간을 바로 쓰게 해주는 것이 아니라 Free List를 먼저 살펴봅니다.&lt;/p&gt;

&lt;p&gt;Free List에 적합한 크기의 Heap 메모리가 있을 경우는 해당 메모리를 할당해줍니다.&lt;/p&gt;

&lt;p&gt;만약 적절한 크기의 메모리가 없다면 요청한 크기만큼의 Heap을 새로 할당해주는 방식입니다.&lt;/p&gt;

&lt;p&gt;예를 들어, 프로그램이 시작된 후 처음으로 0x20 크기의 Heap을 요청했다고 가정하겠습니다.&lt;/p&gt;

&lt;p&gt;해제된 메모리가 없으니 Free List는 비어있겠죠?&lt;/p&gt;

&lt;p&gt;그럼 Heap의 할당은 다음 그림처럼 이루어집니다.&lt;/p&gt;

&lt;p&gt;(실제로는 0x20 + Heap Header 크기만큼 할당이 이루어집니다.)&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_4.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;그런 다음 이 메모리를 해제하게 되면 이 메모리는 Free List에 들어가게 됩니다.&lt;/p&gt;

&lt;p&gt;이후 프로그램이 다시 0x30 크기의 Heap을 요청하면 Free List를 먼저 살펴봅니다.&lt;/p&gt;

&lt;p&gt;0x30을 할당할 수 있을 만한 크기가 없기 때문에 새로 0x30만큼의 메모리를 할당해줍니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_5.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이번에는 0x10만큼의 메모리 할당 요청이 들어왔다고 가정하겠습니다.&lt;/p&gt;

&lt;p&gt;이번에도 Heap 관리자는 Free List를 먼저 살펴보겠지요?&lt;/p&gt;

&lt;p&gt;Heap 관리자는 Best-Fit 정책을 사용하고 있기 때문에 최대한 적합한 크기의 Heap을 할당하려고 합니다.&lt;/p&gt;

&lt;p&gt;지금 상황에서는 0x30이 제일 적합한 메모리가 되겠네요.&lt;/p&gt;

&lt;p&gt;이 0x30 메모리를 모두 할당하는 것이 아니라 메모리를 분할하여 0x10만큼만 할당을 해줍니다.&lt;/p&gt;

&lt;p&gt;그런데 이런 방식을 사용하는 환경에서 작은 메모리 요청/해제가 빈번하게 일어나면 어떻게 될까요?&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;작은 메모리 조각이 계속해서 발생할 것이고 이를 관리하는 것에 한계가 생길 겁니다.&lt;/p&gt;

&lt;p&gt;이런 현상을 개선하기 위해서 최신 윈도우에서는 Low Fragmentation Heap이라는 정책을 도입했습니다.&lt;/p&gt;

&lt;h5 id=&quot;low-fragmentation-heap&quot;&gt;Low Fragmentation Heap&lt;/h5&gt;

&lt;p&gt;Low Fragmentation Heap(저단편화 힙)은 말 그대로 위에서 살펴본 Free List 방식에서 발생하는 단편화 현상을 줄이기 위해 도입되었습니다.&lt;/p&gt;

&lt;p&gt;Free List에서는 Heap을 계속해서 분할하는 방식이기 때문에 단편화 문제가 있다고 했었죠?&lt;/p&gt;

&lt;p&gt;그래서 Low Fragmentation Heap은 Bucket이라는 미리 정의된 서로 다른 크기의 범위를 갖는 블록을 관리함으로써 단편화를 해결합니다.&lt;/p&gt;

&lt;p&gt;쉽게 이야기해서, 미리 여러 크기로 Heap 공간을 분할해놓고 할당 요청이 오면 해당 크기를 포함하는 가장 작은 Bucket을 선택해 할당합니다.&lt;/p&gt;

&lt;p&gt;Bucket은 총 128개인데 첫 번째 Bucket은 1~8바이트, 두 번째는 9~16바이트 식으로 8바이트 단위로 구분되며, 마지막 Bucket은 15873~16384 바이트 크기까지 지원할 수 있습니다.&lt;/p&gt;

&lt;p&gt;만약 요청된 크기가 16384 바이트보다 크다면 Backend로 요청을 보냅니다.&lt;/p&gt;

&lt;p&gt;Backend로 요청이 이루어지면 Free List 방식으로 Heap 할당을 진행합니다.&lt;/p&gt;

&lt;p&gt;즉, Low Fragmentation Heap 기법은 미리 Bucket으로 나누어서 적합한 메모리를 찾는 속도를 증가시키고, 크기별 Free List들을 Lookaside List에 나누어 관리하는 것이죠.&lt;/p&gt;

&lt;p&gt;지금까지 Windows Heap 대해 알아봤습니다.&lt;/p&gt;

&lt;p&gt;다음 시간부터는 Heap에 대한 공격 기법을 살펴보도록 하겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x0a Windows-Heap</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">windows-0x09</title>
      <link href="/windows-0x09" rel="alternate" type="text/html" title="windows-0x09" />
      <published>2019-03-24T20:18:00+09:00</published>
      <updated>2019-03-24T20:18:00+09:00</updated>
      <id>/windows-0x09</id>
      <content type="html" xml:base="/windows-0x09">&lt;h1 id=&quot;0x09-dep3&quot;&gt;0x09 DEP(3)&lt;/h1&gt;

&lt;p&gt;이번 시간에는 DEP의 마지막 주제인 ROP에 대해서 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;rop-return-oriented-programming&quot;&gt;ROP (Return Oriented Programming)&lt;/h5&gt;

&lt;p&gt;ROP는 Gadget으로 Chain을 구성하여 API를 호출하는 방식의 공격 기법입니다.&lt;/p&gt;

&lt;p&gt;주로 VirtualProtect()나 SetProcessDEPPolicy() 등 메모리와 관련된 함수들을 호출하며,&lt;/p&gt;

&lt;p&gt;Shellcode를 실행할 수 있도록 실행 권한을 추가하는 방향으로 진행됩니다.&lt;/p&gt;

&lt;p&gt;이번 연재에서는 가장 흔하고 쉬운 방식인 VirtualProtect() API를 호출해서 DEP를 우회하도록 하겠습니다.&lt;/p&gt;

&lt;h6 id=&quot;virtualprotect-함수&quot;&gt;VirtualProtect 함수&lt;/h6&gt;

&lt;p&gt;VirtualProtect는 4개의 인자를 가지며, 특정 메모리 영역의 실행 권한을 변경해주는 함수입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BOOL WINAPI VirtualProtect (
		_In_ LPVOID lpAddress, 		 # 권한을 변경할 메모리 영역의 시작 주소
		_In_ SIZE_T dwSize,	   		 # 변경할 크기
		_In_ flNewProtect,     		 # 변경할 속성 값
		_Out_ PDWORD lpflOldProtect, # 이전 값 저장 (쓰기 가능한 영역)
	);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;VirtualProtect 함수는 변경을 원하는 메모리 영역의 시작 주소를 기준으로 원하는 크기만큼 실행 권한을 변경해줍니다.&lt;/p&gt;

&lt;p&gt;그럼 ShellCode를 넣어둔 뒤, 그 크기만큼 실행 권한을 주면 되겠네요.&lt;/p&gt;

&lt;p&gt;이 내용을 STACK으로 구성하면 다음과 같습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;그림처럼 STACK을 구성할 경우, VirtualProtect()가 호출되어 ShellCode가 들어있는 메모리 주소에 실행 권한이 생길 것이고,&lt;/p&gt;

&lt;p&gt;다음 RET에서 JMP ESP가 호출되어 ShellCode가 실행될 것 입니다.&lt;/p&gt;

&lt;p&gt;그리고 이 모양의 STACK을 구성하기 위해 PUSHAD 명령어를 이용할 것 입니다. STACK 구성이 좀 더 쉽겠죠?&lt;/p&gt;

&lt;h5 id=&quot;payload-구성&quot;&gt;PAYLOAD 구성&lt;/h5&gt;

&lt;p&gt;Mona.py를 이용해서 ROP Chain 구성에 사용할 Gadget들을 찾아 보겠습니다. ( !mona modules )&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Gadget은 위의 Module들 중에 ASLR이 적용되어 있지 않은 example.dll에서 가져다 쓰면 되겠네요.&lt;/p&gt;

&lt;p&gt;이제 여기서 Gadget을 구해서 값들을 맞춰주기만 하면 되는데,,, 일일이 하나씩 찾아서 넣으면 엄청나게 많은 시간이 소요되겠죠??&lt;/p&gt;

&lt;p&gt;하나하나 다 찾아다닐 시간은 없으니까 mona.py에서 제공하는 기능을 활용하겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;!mona rop -m example
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 명령어를 사용하면 mona.py에서 자동으로 rop 공격에 필요한 Gadget들을 example.dll에서 찾아 파일로 생성해줍니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;여러 언어에 맞게 추천을 해주는데 여러분 환경에 맞는 값을 사용하시면 됩니다.&lt;/p&gt;

&lt;p&gt;이제 필요한 Gadget들을 아주 손쉽게 찾아왔는데 한 가지 생각해야 할 점이 있습니다.&lt;/p&gt;

&lt;p&gt;바로 VirtualProtect의 함수 주소입니다.&lt;/p&gt;

&lt;p&gt;ASLR이 적용되어 있으면 Window API 함수들의 주소도 계속해서 변할텐데 어떻게 주소를 가지고 올 수 있는 걸까요?&lt;/p&gt;

&lt;p&gt;Gadget 파일을 잘 보시면 VirtualProtect에 IAT라고 적혀있는 것을 보실 수 있을 겁니다.&lt;/p&gt;

&lt;p&gt;IAT(Import Address Table)는 프로그램에서 사용되는 라이브러리에서 어떤 함수들을 사용하고 있는지, 그 함수들의 정보를 기술한 테이블입니다.&lt;/p&gt;

&lt;p&gt;아래와 같이 example.dll의 IAT를 살펴보면 우리가 사용하고자 하는 VirtualProtect() 함수의 정보가 들어있는 것을 확인하실 수 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_4.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이렇게 VirtualProtect() 정보가 들어 있는 경우에는 IAT 값에서 시작 주소를 가져다가 쓰면 되는 것이죠.&lt;/p&gt;

&lt;p&gt;없다면? 동적으로 찾아오도록 Gadget을 구성하면 됩니다.&lt;/p&gt;

&lt;h5 id=&quot;null-byte-제거&quot;&gt;Null Byte 제거&lt;/h5&gt;

&lt;p&gt;공격을 성공적으로 하기 위해 Payload에 존재하는 Null Byte들을 제거해줘야겠죠?&lt;/p&gt;

&lt;p&gt;mona가 만들어 준 값들엔 Null Byte가 존재해서 Payload 전달이 완전하게 이루어지지 않는답니다.&lt;/p&gt;

&lt;p&gt;그래서 다음과 같이 수정을 했습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_5.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;먼저, 0x201, 0x40 같은 값을 넣어줘야 하는데 Null이 존재하므로 0xfffffdff, 0xffffffc0를 넣고 neg를 사용해서 값을 생성해줬습니다.&lt;/p&gt;

&lt;p&gt;그리고 Gadget 주소 중에 Null이 존재하는 것은 다른 Gadget 찾아서 교체해준 내용입니다.&lt;/p&gt;

&lt;p&gt;mona만 믿고 Payload를 구성하시면 안됩니다. 잘 살펴보고 Null은 반드시 제거해주셔야 합니다.&lt;/p&gt;

&lt;p&gt;이어서 DBG로 살펴보면 다음과 같습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_6.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;strcpy가 실행되고 나서의 모습입니다. 각 Gadget들이 연속해서 실행된 뒤, VirtualProtect() 함수가 실행될 것이고,&lt;/p&gt;

&lt;p&gt;마지막에 JMP ESP가 실행되면서 ShellCode가 실행되겠네요.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_7.png&quot; alt=&quot;[그림 1-7]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;잘 실행되네요^^&lt;/p&gt;

&lt;p&gt;지금까지 DEP에 대해서 알아봤습니다.&lt;/p&gt;

&lt;p&gt;다음 연재부터는 Heap Exploit으로 찾아뵙도록 하겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x09 DEP(3)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">windows-0x08</title>
      <link href="/windows-0x08" rel="alternate" type="text/html" title="windows-0x08" />
      <published>2019-03-19T20:18:00+09:00</published>
      <updated>2019-03-19T20:18:00+09:00</updated>
      <id>/windows-0x08</id>
      <content type="html" xml:base="/windows-0x08">&lt;h1 id=&quot;0x08-dep2&quot;&gt;0x08 DEP(2)&lt;/h1&gt;

&lt;h5 id=&quot;what-is-dep&quot;&gt;What is DEP?&lt;/h5&gt;

&lt;p&gt;지난 Post에서 RTL을 다루어 봤습니다.&lt;/p&gt;

&lt;p&gt;이번 시간에는 RTL에 이어 Chaining RTL에 대해 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;chaining-rtl&quot;&gt;Chaining RTL&lt;/h5&gt;

&lt;p&gt;Chaining RTL은 RTL이 Chain처럼 엮여서 반복되는 것을 말합니다.&lt;/p&gt;

&lt;p&gt;RTL이 뭐였죠? DEP가 적용되어 Shellcode를 실행할 수 없게 되었을 때, 라이브러리 함수로 점프하여&lt;/p&gt;

&lt;p&gt;내가 원하는 함수를 실행하는 것이었죠?&lt;/p&gt;

&lt;p&gt;Chaining RTL은 말 그대로 내가 원하는 함수를 계속해서 실행하는 것을 뜻합니다.&lt;/p&gt;

&lt;p&gt;의미는 알았으니, 본격적으로 알아볼텐데 STACK 구성에 집중해서 보시면 되겠습니다.&lt;/p&gt;

&lt;p&gt;먼저, 지난 시간처럼 몇 가지 가정을 하겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;func1(argv1) : 인자를 하나만 필요로 하는 함수&lt;/li&gt;
  &lt;li&gt;func2(argv1’, argv’2) : 인자를 두 개 필요로 하는 함수&lt;/li&gt;
  &lt;li&gt;func3(argv’‘1, argv’‘2, argv’‘3) : 인자를 세 개 필요로 하는 함수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 함수들을 차례대로 호출한다고 가정하고 이 때, Payload를 어떻게 구성해야하는 것인지를 살펴보도록 하겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x07_2.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이 그림 기억나시나요?? 지난 시간에 살펴봤던 함수를 하나만 호출할 때의 STACK 그림입니다.&lt;/p&gt;

&lt;p&gt;Main-ret가 다음 호출할 함수의 SFP로 변경되고 있죠? 그래서 그 다음 4 Byte가 호출된 함수가 종료되고 다음에 갈 곳의 주소인 것도 알고 있습니다.&lt;/p&gt;

&lt;p&gt;그럼 두 번째 함수(인자가 두 개)를 호출할 때 그림이 이렇게 되겠네요?&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x08_1.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Func1() 함수의 RET 자리에 Func2() 함수의 주소를 넣어줬습니다. 그럼 Func1() 함수가 종료된 후, Func2() 함수가 실행됩니다.&lt;/p&gt;

&lt;p&gt;간단하죠?&lt;/p&gt;

&lt;p&gt;그런데 여기엔 문제가 있습니다. 이 방법으로는 내가 원하는 함수를 마음껏 호출할 수가 없습니다.&lt;/p&gt;

&lt;p&gt;그냥 RET에 다른 함수 주소를 덮어주면 되는거 아니야? 라고 생각하실 수 있습니다.&lt;/p&gt;

&lt;p&gt;자, 그럼 다음에 Func3() 함수를 호출한다고 생각해봅시다.&lt;/p&gt;

&lt;p&gt;Func3() 함수의 주소는 어디에 넣어줘야 하죠?&lt;/p&gt;

&lt;p&gt;이미 Func1() 함수의 첫 번째 인자가 위치하고 있습니다. 이제 이해가 가시죠??&lt;/p&gt;

&lt;p&gt;이 한계를 해결하기 위해 지금부터는 Gadget을 사용할 겁니다.&lt;/p&gt;

&lt;p&gt;RET로 끝나는 많고 많은 Gadget 중에 시스템 해킹에서 주로 사용되는 Gadget은 다음 3가지 입니다.
(이것만 쓴다는 게 아닙니다!!)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;pr : POP RET&lt;/li&gt;
  &lt;li&gt;ppr : POP POP RET&lt;/li&gt;
  &lt;li&gt;pppr : POP POP POP RET&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;POP 뒤에 Operand는 생략했습니다.&lt;/p&gt;

&lt;p&gt;이 Gadget을 이용해서 내가 원하는만큼 함수를 호출하려면 STACK을 다음과 같이 구성하면 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x08_2.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;조금 이상하고 복잡한 듯이 느껴질 수 있는데, 에필로그 과정부터 Gadget 순으로 색깔별로 보시면 됩니다.&lt;/p&gt;

&lt;p&gt;먼저 에필로그부터 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;RETN이 실행되면 POP EIP, JMP EIP를 수행하므로 실행되고 난 후, ESP의 위치는 빨간 ESP 위치가 됩니다.&lt;/p&gt;

&lt;p&gt;JMP EIP가 실행되면 POP RETN이 실행되겠죠?&lt;/p&gt;

&lt;p&gt;처음 POP이 실행되면 STACK 최상단의 값을 꺼내고 ESP가 올라가면서 ESP의 위치는 파란 ESP 위치가 됩니다.&lt;/p&gt;

&lt;p&gt;다시 RETN이 실행되면 POP EIP, JMP EIP가 실행되겠네요.&lt;/p&gt;

&lt;p&gt;그럼 그 때의 ESP는 초록색 위치가 되는데 POP EIP를 했으므로 EIP엔 두 번째 함수 Func2()의 주소가 들어가게 될 것이고&lt;/p&gt;

&lt;p&gt;JMP EIP를 하면서 Func2() 함수가 실행됩니다.&lt;/p&gt;

&lt;p&gt;세 번째 함수까지 모두 호출한다고 가정했을 때, STACK의 구조는 다음과 같이 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x08_3.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이런 식으로 STACK을 구성해서 내가 원하는 함수를 계속해서 호출하는 기법을 Chaining RTL이라고 부릅니다.&lt;/p&gt;

&lt;p&gt;자, 이제 ROP를 하기 위한 기초 준비 작업을 모두 마쳤습니다.&lt;/p&gt;

&lt;p&gt;다음 Post에서 ROP를 알아보고 DEP편을 마무리 짓도록 하겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x08 DEP(2)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">windows-0x07</title>
      <link href="/windows-0x07" rel="alternate" type="text/html" title="windows-0x07" />
      <published>2019-03-19T19:18:00+09:00</published>
      <updated>2019-03-19T19:18:00+09:00</updated>
      <id>/windows-0x07</id>
      <content type="html" xml:base="/windows-0x07">&lt;h1 id=&quot;0x07-dep1&quot;&gt;0x07 DEP(1)&lt;/h1&gt;

&lt;h5 id=&quot;what-is-dep&quot;&gt;What is DEP?&lt;/h5&gt;

&lt;p&gt;DEP는 특정 메모리의 실행 권한을 제거하여, 메모리에 올라온 Shellcode의 실행을 막는 메모리 보호 기법입니다.&lt;/p&gt;

&lt;p&gt;DEP는 Window XP Service Pack 2에서부터 적용된 기법이며, H/W 기반 DEP와 S/W 기반 DEP로 나눌 수 있습니다.&lt;/p&gt;

&lt;p&gt;이 두 가지 방식의 차이는 CPU가 하드웨어적으로 DEP를 지원 가능한가를 기준으로 나뉜다고 생각하시면 됩니다.&lt;/p&gt;

&lt;p&gt;CPU에서 지원 가능한 경우 H/W DEP라 하고, 그렇지 않은 경우 S/W로 그 기능을 지원하는 방식인 것이죠.&lt;/p&gt;

&lt;p&gt;최근 나온 CPU들은 대부분 H/W 기능을 지원하므로 일반적으로 DEP라고 하면 H/W DEP라고 생각하시면 됩니다.&lt;/p&gt;

&lt;p&gt;DEP에는 아래와 같이 4가지 종류의 옵션이 존재합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;OptIn : 지정된 Binary만 보호&lt;/li&gt;
  &lt;li&gt;OptOut : 지정된 Binary를 제외하고 보호&lt;/li&gt;
  &lt;li&gt;AlwaysOn : 모든 Process 항상 보호&lt;/li&gt;
  &lt;li&gt;AlwaysOff : 모든 Process 보호하지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;OS를 설치한 후, 직접 변경한 적이 없다면 Default로 OptIn 옵션이 적용되어 있고 다음과 같이 확인할 수 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x07_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;DEP가 적용되면 Shellcode를 STACK에 넣어서 실행해왔던 지금까지의 방법으로는 성공할 수가 없게 됩니다.&lt;/p&gt;

&lt;p&gt;하지만 이 기법 역시 우회가 가능하며, DEP를 우회하기 위해 필요한 기법과 개념들은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Gadget&lt;/li&gt;
  &lt;li&gt;RTL&lt;/li&gt;
  &lt;li&gt;Chaining RTL&lt;/li&gt;
  &lt;li&gt;ROP&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;지금부터 하나씩 살펴보겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;gadget&quot;&gt;Gadget&lt;/h5&gt;

&lt;p&gt;Gadget이란 “mov esp, ebp” 등의 명령어 조각을 의미했었습니다.&lt;/p&gt;

&lt;p&gt;하지만 지금 시스템 해킹에서의 Gadget은 RET로 끝나는 명령어 조각을 의미하게 되었습니다.&lt;/p&gt;

&lt;p&gt;이 Gadget이 공격에서 왜 중요한지는 Chaining RTL과 ROP를 다루면서 이야기하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;rtl&quot;&gt;RTL&lt;/h5&gt;

&lt;p&gt;RTL은 Return to Library의 약자로 해석을 하면 Library로 돌아간다는 의미입니다.&lt;/p&gt;

&lt;p&gt;Library로 돌아간다?&lt;/p&gt;

&lt;p&gt;아까 앞에서 DEP가 적용되면 Shellcode를 실행할 수가 없다고 했었던 것 기억나시죠?&lt;/p&gt;

&lt;p&gt;그래서 RET를 Shellcode의 주소로 변조하는 것이 아니라, 실행 권한이 있을 수 밖에 없는 Library의 함수의 주소로 변조하는 것이죠.&lt;/p&gt;

&lt;p&gt;그리고!!!&lt;/p&gt;

&lt;p&gt;RTL에서 가장 중요한 것은 함수의 인자를 직접 생성해야 한다는 것입니다.&lt;/p&gt;

&lt;p&gt;Shellcode를 실행했을 때와는 다르게 이 방법은 RET 주소를 원하는 함수의 주소로 바꿔줬을 뿐이기 때문이죠.&lt;/p&gt;

&lt;p&gt;그 함수가 실행되기 위해서는 함수의 동작에 필요한 인자들이 있어야하겠죠?&lt;/p&gt;

&lt;p&gt;CPU가 알아서 자동으로 만들어 줄리가 없으니,,STACK에 직접 구성해줘야 합니다.&lt;/p&gt;

&lt;p&gt;인자를 1개만 취하는 함수 Func()가 있다고 가정하겠습니다.&lt;/p&gt;

&lt;p&gt;RTL 기법으로 이 함수를 호출하기 위해서는 STACK을 다음과 같이 구성해야 합니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x07_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 그림에서 중간 STACK 그림을 보면 Func을 호출하기 위해 RET를 Func 함수의 주소로 변조하고, 그 위치에서 +8만큼 떨어진 곳에 함수의 인자를 구성한 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;그런데 왜 인자의 위치를 저렇게 구성해줘야 할까요?&lt;/p&gt;

&lt;p&gt;다음 그림을 보면서 설명해보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x07_3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;빨간 색으로 표시된 부분은 Main 함수의 에필로그 과정, 파란 색으로 표신된 부분은 Func 함수의 프롤로그 과정을 나타낸 것 입니다.&lt;/p&gt;

&lt;p&gt;먼저, 빨간 색. Main 함수의 에필로그 과정을 봅시다.&lt;/p&gt;

&lt;p&gt;POP EIP, JMP EIP를 코드를 수행했을 때의 위치가 가장 왼쪽 STACK에 표시된 ESP가 가르키는 곳 입니다.&lt;/p&gt;

&lt;p&gt;이후, JMP EIP 코드가 실행되면 새로운 함수가 실행되고 새 함수의 프롤로그 과정이 진행됩니다.&lt;/p&gt;

&lt;p&gt;프롤로그 과정의 일부인 PUSH EBP가 실행되면 새 STACK Frame의 기준점을 만듭니다.&lt;/p&gt;

&lt;p&gt;여기까지 진행된 후, STACK을 살펴봅시다.&lt;/p&gt;

&lt;p&gt;Main 함수의 RET가 뒤이어 실행되는 함수의 SFP 자리로 바뀐다는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;그리고 그 다음에, RET를 만들어주었습니다.&lt;/p&gt;

&lt;p&gt;RTL이 아니라 정상적인 방식인 CALL을 통해 함수가 실행된다면 STACK에 다음에 실행할 곳의 위치를 넣어줍니다.&lt;/p&gt;

&lt;p&gt;그런데 우리는 컴파일러가 만들어주는 것이 아니기 때문에 직접 만들어줘야 합니다.&lt;/p&gt;

&lt;p&gt;그래서 저 위치에 다음에 실행할 곳의 주소 역할을 할 값을 직접 넣어 구성해주는 것 입니다.&lt;/p&gt;

&lt;p&gt;쉽게 생각하면 컴파일러가 만들어주는 구조를 똑같이 흉내낸다고 생각하시면 되겠습니다.&lt;/p&gt;

&lt;p&gt;이것이 RTL의 전부입니다.&lt;/p&gt;

&lt;p&gt;다음은 디버거를 통해 RTL을 진행한 그림입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x07_4.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x07_5.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;잘 실행이 되네요^^&lt;/p&gt;

&lt;p&gt;그런데 이 방식은 실제 환경에서는 거의 불가능한 방법이라는 것도 알아두셔야 합니다.&lt;/p&gt;

&lt;p&gt;실제 환경에서는 ASLR, Safe SEH 등이 기본적으로 적용되어 있기 때문에 내가 원하는 함수의 주소를 찾아내기 힘들기 때문입니다.&lt;/p&gt;

&lt;p&gt;그래서 이 기법은 ROP를 위한 기본 개념 정도로만 이해하시기 바랍니다.&lt;/p&gt;

&lt;p&gt;글이 너무 길어졌네요. 이만 줄이고 다음 편에서 ROP를 알아보도록 하겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x07 DEP(1)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">windows-0x06</title>
      <link href="/windows-0x06" rel="alternate" type="text/html" title="windows-0x06" />
      <published>2019-03-18T19:18:00+09:00</published>
      <updated>2019-03-18T19:18:00+09:00</updated>
      <id>/windows-0x06</id>
      <content type="html" xml:base="/windows-0x06">&lt;h1 id=&quot;0x06-gs2&quot;&gt;0x06 GS(2)&lt;/h1&gt;

&lt;h5 id=&quot;safeseh&quot;&gt;SafeSEH&lt;/h5&gt;

&lt;p&gt;SafeSEH는 SEH Overwite를 방어하기 위해 도입된 메모리 보호 기법입니다.&lt;/p&gt;

&lt;p&gt;SafeSEH가 하는 일은 아주 간단합니다.&lt;/p&gt;

&lt;p&gt;Exception Handler가 실행되기 전에 Handler 주소 값에 대한 검증을 수행합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1) 등록된 Handler의 주소가 STACK인지 확인해서 STACK이면 호출하지 않음.&lt;/li&gt;
  &lt;li&gt;2) Handler의 주소가 현재 로드된 모듈의 주소이고, SafeSEH 컴파일이 되어 있다면 적절한 절차로 등록된 것인지 검증.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;까다롭죠??&lt;/p&gt;

&lt;p&gt;그런데 해법이 상당이 간단합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1) Handler의 주소가 STACK이 아니면 된다.&lt;/li&gt;
  &lt;li&gt;2) SafeSEH 컴파일이 되어 있지 않으면 된다.&lt;/li&gt;
  &lt;li&gt;결론 : SafeSEH가 안걸려 있는 모듈에서 Gadget을 찾아오면 된다!!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;간단하죠?&lt;/p&gt;

&lt;p&gt;Immunity Debugger에서 mona.py를 이용하면 Module들에 어떤 보호기법들이 적용되어 있는지 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;!mona modules
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x06_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이 중에 SafeSEH가 적용되어 있지 않은 Module을 골라서 우회 공격을 동일하게 진행하면 됩니다.&lt;/p&gt;

&lt;p&gt;이상으로 GS편을 모두 마치겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x06 GS(2)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">DLL Hijacking &amp;amp; Ghidra</title>
      <link href="/Dll-Hijacking-&-Ghidra" rel="alternate" type="text/html" title="DLL Hijacking &amp; Ghidra" />
      <published>2019-03-17T19:18:00+09:00</published>
      <updated>2019-03-17T19:18:00+09:00</updated>
      <id>/Dll%20Hijacking%20&amp;%20Ghidra</id>
      <content type="html" xml:base="/Dll-Hijacking-&amp;-Ghidra">&lt;h1 id=&quot;dll-hijacking--ghidra&quot;&gt;DLL Hijacking &amp;amp; Ghidra&lt;/h1&gt;

&lt;p&gt;안녕하세요. Joel입니다.&lt;/p&gt;

&lt;p&gt;방구석에 누워있다 갑자기 DLL Hijacking 포스팅을 올리라는 일거리를 받아서 글을 쓰게 되었습니다. 허허..&lt;/p&gt;

&lt;h5 id=&quot;overview&quot;&gt;Overview&lt;/h5&gt;

&lt;p&gt;DLL Hijacking은 PE 프로그램이 의도하지 않은 external library(dll)을 실행하도록 만드는 것 입니다. 
이 공격은 DLL Search Order 때문에 취약한 PE 프로그램이 공격자가 작성한 DLL을 로드하고 실행하게 됩니다.
지금부터, 취약한 프로그램 분석과 Hijacking할 dll을 찾는 과정 등을 하나씩 살펴보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;먼저, 오늘 포스팅에서 사용한 Tool과 환경구축 내용입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Ghidra (jdk 11 이상, 64bit 필수)&lt;/li&gt;
  &lt;li&gt;PuTTY 0.65&lt;/li&gt;
  &lt;li&gt;Sysinternals suite&lt;/li&gt;
  &lt;li&gt;Visual Studio 2017&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;find-the-dlls-which-are-loaded-by-target-application&quot;&gt;Find the dlls which are loaded by target application.&lt;/h5&gt;

&lt;h6 id=&quot;procexp&quot;&gt;Procexp&lt;/h6&gt;

&lt;p&gt;PuTTY 0.65를 실행한 뒤, Sysinternals의 Procexp.exe를 통해 어떤 dll들을 사용하는지 확인해보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/dll/0x00_2.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Procexp.exe에서 [View]-[Lower Pane View]-[DLLs] 설정을 하면 PuTTY 프로그램이 로드한 dll 목록들을 확인할 수 있습니다.
그런데 이것만 가지고는 어떤 dll을 hijack할 수 있는지 알 수가 없습니다. 결과만 보이기 때문이죠.&lt;/p&gt;

&lt;p&gt;그래서 이번에는 Sysinternals의 Procmon을 실행시켜서 dll이 로드되는 과정을 살펴보겠습니다.&lt;/p&gt;

&lt;h6 id=&quot;procmon&quot;&gt;Procmon&lt;/h6&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/dll/0x00_3.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Procmon을 실행한 후 필터를 위와 같이 설정합니다. 그럼 아래와 같이 PuTTY가 dll을 로드하는 과정에서 발생한 내용들을 볼 수가 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/dll/0x00_4.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 그림과 Procexp의 내용을 종합해보면 PuTTY는 WINMM.dll을 자신이 있는 디렉터리에서 먼저 찾아서 로드하려고 한다는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;하지만 해당 디렉터리에는 WINMM.dll이 없기에 결과적으로는 C:\Windows\SysWOW64\WINMM.dll을 로드하고 있습니다.&lt;/p&gt;

&lt;p&gt;만약 해당 디렉터리에 이 WINMM.dll이 존재한다면 어떻게 될까요? ^^&lt;/p&gt;

&lt;p&gt;아 물론, 여기서 해당 디렉터리에 low priv user가 Write Access가 가능하다는 전제하에 진행하는 것입니다.&lt;/p&gt;

&lt;p&gt;만약, 해당 디렉터리가 C:\, C:\Program Files 등 Admin 권한이 필요한 경우에는 UAC 팝업이 뜨겠죠?&lt;/p&gt;

&lt;p&gt;UAC 팝업은 쉽게 우회가 가능하나, 이 글의 범위를 넘어서므로 바탕화면 특정 디렉터리에서 진행합니다.&lt;/p&gt;

&lt;p&gt;계속 갑니닷.&lt;/p&gt;

&lt;h6 id=&quot;find-a-target-function-with-ghidra&quot;&gt;Find a Target Function with Ghidra&lt;/h6&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/dll/0x00_5.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Target Function을 Ghidra를 이용해서 찾아보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/dll/0x00_1.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;[Symbol Tree] - [Imports] - [WINMM.dll]을 따라가면 PlaySoundA라는 함수를 찾을 수 있습니다. 쉽죠??&lt;/p&gt;

&lt;p&gt;그럼 이제 우리가 해야할 일은 Hijacking에 사용할 dll을 만드는 것 입니다.&lt;/p&gt;

&lt;h6 id=&quot;make-a-dll&quot;&gt;Make a DLL&lt;/h6&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &quot;stdafx.h&quot;

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {

	switch (ul_reason_for_call) {
	case DLL_PROCESS_ATTACH:
		WinExec(&quot;calc&quot;, SW_NORMAL);
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
		break;

	}
	return true;
}

extern &quot;C&quot; __declspec(dllexport) void PlaySoundA() {
	WinExec(&quot;calc&quot;, SW_NORMAL);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 PuTTY가 실행될 때 계산기를 실행하도록 새로운 dll을 생성했습니다.&lt;/p&gt;

&lt;h6 id=&quot;execute-target-program&quot;&gt;Execute Target Program&lt;/h6&gt;

&lt;p&gt;아래와 같이, 같은 디렉터리에 방금 만든 dll을 위치시킨 후, 실행해보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/dll/0x00_6.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
&lt;/figure&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/dll/0x00_7.png&quot; alt=&quot;[그림 1-7]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;계산기가 잘 실행되네요. ^^&lt;/p&gt;

&lt;p&gt;지금까지 DLL Hijacking에 대해서 알아봤습니다. 뿅!&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">DLL Hijacking &amp;amp; Ghidra</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">windows-0x05</title>
      <link href="/windows-0x05" rel="alternate" type="text/html" title="windows-0x05" />
      <published>2019-03-09T19:18:00+09:00</published>
      <updated>2019-03-09T19:18:00+09:00</updated>
      <id>/windows-0x05</id>
      <content type="html" xml:base="/windows-0x05">&lt;h1 id=&quot;0x05-gs&quot;&gt;0x05 GS&lt;/h1&gt;

&lt;h5 id=&quot;what-is-gs&quot;&gt;What is GS?&lt;/h5&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x05_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;GS는 STACK Cookie, Canary로도 불리는 메모리 보호 기법입니다.&lt;/p&gt;

&lt;p&gt;이 GS는 BOF를 방어하기 위해 나온 기법 중 하나로, 함수가 시작될 때 STACK에 4 byte를 넣어놓고 함수가 종료될 때 이 4 byte가 변조되었는지 확인합니다.&lt;/p&gt;

&lt;p&gt;만약 이 STACK Cookie가 처음과 다르다면, 프로그램은 바로 종료되어 버립니다.&lt;/p&gt;

&lt;p&gt;아래 그림은 STACK Cookie가 적용되고 검사하는 과정을 나타냅니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x05_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;STACK BOF는 반드시 Buffer의 시작 주소부터 덮기 시작하여 RET를 변조하는 것이기 때문에 GS를 정확하게 똑같이 입력하지 않으면 BOF 공격을 성공할 수가 없죠.&lt;/p&gt;

&lt;p&gt;STACK Cookie는 고정된 값으로 넣어줄 수도 있지만, 값을 랜덤하게 넣거나, 첫 바이트를 Null로 넣어주는 방식도 있습니다.&lt;/p&gt;

&lt;p&gt;따라서, BOF 공격을 방어하기 위한 아주 효과적인 방법이라고 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;그렇다면 이 메모리 기법은 어떻게 우회를 할 수 있을까요??&lt;/p&gt;

&lt;p&gt;이 기법을 우회하기 위해서는 Window의 Error Handlering에 대한 지식이 필요합니다.&lt;/p&gt;

&lt;h5 id=&quot;structured-error-handling&quot;&gt;Structured Error Handling&lt;/h5&gt;

&lt;p&gt;구조적 예외처리(이하 SEH)는 윈도우 운영 체제 특성에 기반한 예외 처리 매커니즘입니다.&lt;/p&gt;

&lt;p&gt;이 SEH는 Thread별로 독립적으로 설치되고 운영되는 특징이 있습니다.&lt;/p&gt;

&lt;p&gt;쉽게 이야기를 해보자면..프로그램이 좀 더 안정적으로 돌아갈 수 있도록 에러가 발생했을 때, 처리를 담당하는 역할을 맡고 있다고 생각하시면 되겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x05_3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 그림은 SEH의 구조와 동작을 표현한 내용입니다. 뭔가 좀 복잡해보이죠??&lt;/p&gt;

&lt;p&gt;하나씩 설명해보도록 할게요.&lt;/p&gt;

&lt;p&gt;프로그램이 실행되다가 에러가 발생하면 FS(=Segment Register)의 0번지의 값을 참조해서 TIB의 Exception_Register라는 값을 찾습니다.&lt;/p&gt;

&lt;p&gt;여기에는 컴파일러가 미리 등록해놓은 에러 처리를 위한 Handler의 주소가 담겨있는데 이를 참조해서 Handler를 호출합니다.&lt;/p&gt;

&lt;p&gt;만약 에러가 해결되지 않는다면 다음 Handler를 호출하는 방식으로 구현되어 있습니다.&lt;/p&gt;

&lt;p&gt;만약 이 Handler가 발생한 에러를 위한 Handler가 맞다면 실행되고 아니면 *next SEH Record를 참조하여 다음 Handler를 실행하러 갑니다.&lt;/p&gt;

&lt;p&gt;그런데 이 과정이 무한 반복이 되면 안되겠죠? 이 과정은 *next SEH Record의 값이 0xffffffff가 될 때까지만 진행이 되고&lt;/p&gt;

&lt;p&gt;만약 0xffffffff가 된다면 Default Exception Handler를 호출하게 됩니다.&lt;/p&gt;

&lt;p&gt;간단하쥬?&lt;/p&gt;

&lt;p&gt;다음 그림을 통해 NSEH와 SEH의 구조를 살펴보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x05_4.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 그림처럼 EXCEPTION_RECORD는 _next와 _handler로 구성되어 있습니다.&lt;/p&gt;

&lt;p&gt;위에서 이미 설명했듯이 _next는 다음 EXCEPTION_RECORD의 위치를 담고 있습니다.&lt;/p&gt;

&lt;p&gt;_handler는 실제로 에러 처리 과정을 실행할 함수이고, 구조는 아래와 같습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x05_5.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 함수 구조와 같이 에러 처리 함수는 4개의 인자를 필요로 하며, 함수 실행 시 실행에 필요한 인자들을 STACK에 구성합니다.&lt;/p&gt;

&lt;p&gt;따라서 에러 처리 함수가 동작되면 STACK 구조는 아래처럼 구성됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x05_6.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이 중 우리가 공격에서 유용하게 사용할 값이 EstablierFrame입니다. EstablierFrame은 이전 Frame의 주소를 가지고 있습니다.&lt;/p&gt;

&lt;p&gt;이게 왜 중요할까요?&lt;/p&gt;

&lt;p&gt;다음에서 우회 기법을 설명하며 EstablierFrame 값이 왜 중요한지 같이 알아보겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;seh-overwrite&quot;&gt;SEH Overwrite&lt;/h5&gt;

&lt;p&gt;우리는 지금까지 GS와 SEH의 개념을 살펴보았습니다.&lt;/p&gt;

&lt;p&gt;STACK Cookie를 우호하는데 왜 SEH의 개념이 필요할까요??&lt;/p&gt;

&lt;p&gt;GS가 적용되면 함수 시작 시, 특정 4Byte를 넣고 함수가 종료될 때 4Byte를 검사한다고 했습니다.&lt;/p&gt;

&lt;p&gt;이를 우회하려면? 반드시 4Byte를 알아내서 동일하게 적어줘야겠죠?&lt;/p&gt;

&lt;p&gt;그런데 이 STACK Cookie를 검사하기 전에 프로그램에 치명적인 에러가 발생한다면 어떻게 될까요?&lt;/p&gt;

&lt;p&gt;윈도우는 이 에러를 먼저 처리하려고 하겠죠???&lt;/p&gt;

&lt;p&gt;이 점을 이용하는 겁니다. 지금부터 이 점을 이용해서 STACK Cookie 검사 과정을 우회할 것 입니다.&lt;/p&gt;

&lt;p&gt;어떻게 할 것이냐? 저는 STACK의 끝까지 더미 값을 넣어서 할당된 STACK 공간 밖에 값을 쓰도록 Payload를 구성할 겁니다.&lt;/p&gt;

&lt;p&gt;그러면? 반드시 에러가 발생하겠죠??&lt;/p&gt;

&lt;p&gt;에러가 발생하면 윈도우의 SEH 과정이 실행됩니다.&lt;/p&gt;

&lt;p&gt;지금까지 이야기한 것을 STACK으로 표현하면 다음과 같습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x05_7.png&quot; alt=&quot;[그림 1-7]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 그림을 살펴보면 _next는 Jump to Shellcode, _handler는 &amp;amp; pop pop ret으로 되어 있죠?&lt;/p&gt;

&lt;p&gt;그리고 아래 STACK Frame에 EstablierFrame도 빨간 색으로 표현되어 있네요.&lt;/p&gt;

&lt;p&gt;먼저, EstablierFrame은 이전 Frame의 _next의 주소를 담고 있습니다.&lt;/p&gt;

&lt;p&gt;_handler가 실행되면서 자체적으로 새로운 Frame을 생성하는데 이 함수의 인자 중 하나가 이전 Frame의 주소를 가지고 있으니까&lt;/p&gt;

&lt;p&gt;다시 원래 Frame으로 돌아가서 Shellcode를 실행하도록 만들자는 것이죠.&lt;/p&gt;

&lt;p&gt;그래서 _handler에는 &amp;amp; pop pop ret를 넣어줬습니다.&lt;/p&gt;

&lt;p&gt;함수의 프롤로그 과정을 잘 떠올려보세요. 그럼 _handler가 실행될 때의 ESP는 그림에서 가장 아래에 있을 것이고&lt;/p&gt;

&lt;p&gt;+8 위치에 EstablierFrame가 있죠? 그래서 &amp;amp; pop pop ret을 넣어주는 것입니다.&lt;/p&gt;

&lt;p&gt;&amp;amp; pop pop ret이 실행되면?? _next로 오겠죠?&lt;/p&gt;

&lt;p&gt;그럼 이제 남은 것은 _next에서 Shellcode가 얼마나 떨어져있는지 계산해서 jump code를 구성해주면 됩니다.&lt;/p&gt;

&lt;p&gt;해당 그림에서는 바로 뒤에 Shellcode를 위치시켰습니다.&lt;/p&gt;

&lt;p&gt;그래서 뛰어 넘을 거리는 6Byte!&lt;/p&gt;

&lt;p&gt;4Byte가 아니냐구요? jump 0x06을 기계어로 바꾸면 06 eb가 됩니다. 2 byte짜리 명령어에요.&lt;/p&gt;

&lt;p&gt;그래서 90 90 06 eb로 구성합니다. 그럼 90 90과 &amp;amp; pop pop ret을 뛰어넘어야 하니까 6byte 맞죠?&lt;/p&gt;

&lt;p&gt;아래 그림은 Immunity Debugger를 이용해서 우회 과정을 살펴본 것입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x05_8.png&quot; alt=&quot;[그림 1-8]&quot; /&gt;
&lt;/figure&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x05_9.png&quot; alt=&quot;[그림 1-9]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;우회가 잘 되죠??&lt;/p&gt;

&lt;p&gt;지금까지 GS에 대한 설명을 했습니다. 다음 연재에서는 Safe SEH 기법에 대해 설명하겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x05 GS</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">windows-0x04</title>
      <link href="/windows-0x04" rel="alternate" type="text/html" title="windows-0x04" />
      <published>2019-03-03T19:18:00+09:00</published>
      <updated>2019-03-03T19:18:00+09:00</updated>
      <id>/windows-0x04</id>
      <content type="html" xml:base="/windows-0x04">&lt;h1 id=&quot;0x04-random-stack&quot;&gt;0x04 Random STACK&lt;/h1&gt;

&lt;h5 id=&quot;what-is-random-stack&quot;&gt;What is Random STACK?&lt;/h5&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x04_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Random STACK은 메모리에서 STACK이 할당되는 주소가 프로그램 실행시마다 변경되는 방어 기법입니다.&lt;/p&gt;

&lt;p&gt;이 방어 기법이 적용되면 Shellcode의 주소를 정확히 알 수가 없기 때문에 기존의 Direct EIP Overwrite로는 공격을 성공할 수가 없습니다.&lt;/p&gt;

&lt;h5 id=&quot;jmp-esp&quot;&gt;JMP ESP&lt;/h5&gt;

&lt;p&gt;Shellcode의 주소를 알 수 없는 상황을 우회하기 위해서 사용하는 방법 중 하나가 “JMP ESP”를 활용하는 것입니다.&lt;/p&gt;

&lt;p&gt;RET 주소에 JMP ESP의 주소를 넣는다는 것인데 어떻게 우회가 가능한지 살펴보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x04_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 그림은 우리가 지금 실습하고 있는 프로그램의 공격 전/후 STACK 구조입니다.&lt;/p&gt;

&lt;p&gt;Main의 에필로그 과정에서 마지막 RETN이 실행될 때 Shellcode를 실행하러 가기 때문에 그 과정을 살펴보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x04_3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;mov esp, ebp : 이전 Frame으로 돌아가기 위해 ESP를 현재 Frame의 기준점으로 데리고 옵니다.&lt;/li&gt;
  &lt;li&gt;POP ebp : 이전 Frame의 기준 값을 POP하여 EBP에 넣어주어 이전 Frame의 기준 값으로 돌아갑니다.&lt;/li&gt;
  &lt;li&gt;RETN : POP EIP, JMP EIP을 통해 다음 실행할 곳으로 이동합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;RETN이 일어날 때의 ESP를 유심히 보면, 항상 RET 다음에 위치하고 있다는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;따라서 RET를 &amp;amp;JMP ESP로 해둔다면 다음 실행할 곳의 위치는 RET 다음 위치가 됩니다.&lt;/p&gt;

&lt;p&gt;이 점을 이용하기 위해 Payload의 구성도 다음과 같이 변경됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x04_4.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 Payload와 그림 1-1의 오른편 공격 후 STACK 구조를 다시 봅시다.&lt;/p&gt;

&lt;p&gt;이전과는 다르게 RET 뒤에 Shellcode가 위치하도록 Payload를 구성한 것을 보실 수 있습니다.&lt;/p&gt;

&lt;p&gt;이런 방법을 이용하면 Shellcode의 주소를 정확히 알 수 없는 환경에서도 공격을 성공시킬 수가 있습니다.&lt;/p&gt;

&lt;h5 id=&quot;how-to-find-jmp-esp&quot;&gt;How to Find &amp;amp;JMP ESP?&lt;/h5&gt;

&lt;p&gt;공격의 흐름과 방법은 아마 이제 다들 아실거라 생각됩니다. 그런데 한 가지 의문이 남죠?&lt;/p&gt;

&lt;p&gt;아마도 “&amp;amp;JMP ESP는 어떻게 찾습니까?”일텐데요.&lt;/p&gt;

&lt;p&gt;이번 연재에서는 Immunity Debugger를 통해서 찾는 방법을 알려드리겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x04_5.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x04_6.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Immunity Debugger에서 ALT+M을 하면 메모리 창이 띄어집니다. 메모리 창에서 CTRL+F를 눌러 “FF E4”(=JMP ESP)를 검색하면 아래와 같이 
JMP ESP의 주소를 찾을 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;다음 편에서는 GS 기법에 대해 알아보도록 하겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x04 Random STACK</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">windows-0x03</title>
      <link href="/windows-0x03" rel="alternate" type="text/html" title="windows-0x03" />
      <published>2019-02-18T19:18:00+09:00</published>
      <updated>2019-02-18T19:18:00+09:00</updated>
      <id>/windows-0x03</id>
      <content type="html" xml:base="/windows-0x03">&lt;h1 id=&quot;0x03-basic-bof&quot;&gt;0x03 Basic Bof&lt;/h1&gt;

&lt;h5 id=&quot;what-is-the-buffer-overflow&quot;&gt;What is the Buffer Overflow?&lt;/h5&gt;

&lt;p&gt;Buffer Overflow(이하 BOF)는 데이터의 저장 또는 보관을 위해 주어진 메모리 공간의 크기보다 더 많은 값을 입력해 인접 메모리의 값을 변조할 수 있는 공격 기법입니다. 공격자들이 BOF를 이용해서 주로 하는 일은 변수의 값을 변조하는 것과 RET를 변조해서 프로그램의 흐름을 조작하는 것입니다.&lt;/p&gt;

&lt;p&gt;이 취약점은 왜 발생할까요?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;strcpy, gets 등의 입력 값 길이를 체크하지 않는 취약한 문자열 함수의 사용&lt;/li&gt;
  &lt;li&gt;길이 값 검증을 하지 않은 취약한 프로그램 설계&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;BOF는 흔히 위의 두 가지 이유로 발생합니다. 그렇다면 이 취약점이 발생하지 않게 하려면 어떻게 하면 될까요?
입력 값 길이를 체크하는 안전한 문자열 함수를 사용하면 되겠죠? 물론 이것도 중요하지만 안전한 함수의 사용만으로는 이 공격을 100% 막을 수는 없습니다. 안전한 함수로 문자열 길이 500만큼 받도록 해놓더라도 버퍼의 크기가 300이면 BOF가 일어날 수 있습니다. 그렇기 때문에 안전한 문자열 함수의 사용과 더불어 &lt;strong&gt;안전한 프로그램 설계&lt;/strong&gt;도 뒷받침되어야 합니다.&lt;/p&gt;

&lt;h5 id=&quot;direct-eip-overwrite&quot;&gt;Direct EIP Overwrite&lt;/h5&gt;

&lt;p&gt;아래 소스코드를 가지고 가장 기초적인 BOF를 다루어보도록 하겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

#pragma warning (disable:4996)
#define _CRT_SECURE_NO_WARNINGS

int main(int argc, char* argv[]) {

    char content_buffer[1000];
    char display_buffer[300];
    FILE *f = fopen(argv[1], &quot;rb&quot;);

    fgets(content_buffer, 1000, f);
    strcpy(display_buffer,content_buffer);

    printf(&quot;%s\n&quot;, display_buffer);

    fclose(f);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;fgets로 길이 1000만큼 파일을 읽어와서 content_buffer에 값을 저장하고, 다시 content_buffer에서 display_buffer로 값을 복사한 후 출력해주는 프로그램입니다. 여기서 문제는 strcpy로 content_buffer에서 display_buffer로 값을 복사한다는 것이죠.&lt;/p&gt;

&lt;p&gt;본격적으로 공격을 시작해보도록 하겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Buffer 시작 주소에서 RET까지의 거리 알아내기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Buffer 시작 위치에서 값을 얼마나 넣어야 RET를 변조할 수 있는지 알아야 공격이 가능하겠죠?&lt;/p&gt;

&lt;p&gt;지금은 거리를 모르니 다음과 같이 간단하게 “A” 100개만 넣어서 분석을 해보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x03_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;[그림 1-1]&lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x03_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;[그림 1-2]&lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Buffer 시작 위치가 EBP-12C인 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;SFP도 덮어줘야 하니까 거리는 304가 되겠네요.(12C = 300)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Exploit 작성하기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;메모리 보호기법이 적용되지 않은 프로그램이기 때문에 RET를 Shellcode가 있는 곳의 주소로 변조하기만 하면 됩니다.&lt;/p&gt;

&lt;p&gt;그럼 Payload는 아래 코드와 같이 Nop과 Shellcode를 합쳐서 304만큼 만들어주고, RET는 Shellcode 시작 전 Nop이 있는 위치로 지정하면 되겠네요.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x03_3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;[그림 1-3]&lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;immunity debugger로 프로그램 흐름을 한 번 살펴보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x03_4.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;[그림 1-4]&lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Strcpy가 동작이 완료된 후, RET가 Buffer 시작 주소로 잘 변조되었네요.&lt;/p&gt;

&lt;p&gt;Main 함수의 RET를 변조했기 때문에 실제로 Shellcode가 실행되는 시점은 Main 함수의 에필로그 과정이 진행된 다음입니다.&lt;/p&gt;

&lt;p&gt;에필로그 과정의 마지막에서 변조된 RET 주소로 프로그램의 흐름이 바뀌면 다음과 같이 Shellcode를 만나러 갑니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x03_5.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;[그림 1-5]&lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;공격 결과 확인&lt;/li&gt;
&lt;/ul&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x03_6.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;[그림 1-6]&lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;CMD가 정상적으로 잘 실행되네요^^&lt;/p&gt;

&lt;p&gt;지금까지 Direct EIP Overwrite에 대해서 알아봤습니다. 다음 연재에서는 메모리 보호 기법 중 하나인 ASLR의 개념과 우회 방법을 다루어보도록 하겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x03 Basic Bof</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">windows-0x02</title>
      <link href="/windows-0x02" rel="alternate" type="text/html" title="windows-0x02" />
      <published>2019-02-18T19:18:00+09:00</published>
      <updated>2019-02-18T19:18:00+09:00</updated>
      <id>/windows-0x02</id>
      <content type="html" xml:base="/windows-0x02">&lt;h1 id=&quot;0x02-stack&quot;&gt;0x02 STACK&lt;/h1&gt;

&lt;h5 id=&quot;what-is-the-stack&quot;&gt;What is the STACK?&lt;/h5&gt;

&lt;p&gt;STACK은 Main 함수를 포함한 각 함수들이 생성하는 &lt;strong&gt;지역변수&lt;/strong&gt;, &lt;strong&gt;결과값&lt;/strong&gt; 그리고 함수가 필요로 하는 &lt;strong&gt;인자&lt;/strong&gt;들을 저장할 수 있는 메모리 영역입니다.
이 영역은 LIFO(Last In, First Out)이라는 데이터 구조를 가지고 있으며, CPU에 의해 관리되고 최적화되는 영역이기 때문에 데이터를 읽고 쓰는 속도가 매우 빠릅니다. 또한, 어떤 함수가 변수를 선언하면 그 새로운 변수는 스택에 생성되고(push), 함수가 종료될 때 함수가 생성한 모든 변수, 값등은 자동으로 해제됩니다.&lt;/p&gt;

&lt;h5 id=&quot;how-does-the-stack-work&quot;&gt;How does the STACK work?&lt;/h5&gt;

&lt;p&gt;STACK을 설명할 때 가장 먼저 떠오르는 개념이 바로 LIFO입니다. LIFO는 Last In First Out의 앞 글자를 딴 용어이고 한글로는 후입선출이라고 합니다.
설명을 하자면 ‘마지막에 들어온 것이 먼저 나간다’이죠. 아래 그림을 보면서 설명을 이어나가겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x02_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;[그림 1-1]&lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;STACK은 위 그림처럼 한 쪽이 막혀 있고 입구가 하나인 구조를 가지고 있습니다.&lt;/p&gt;

&lt;p&gt;앞에서 제가 마지막에 들어온 것이 먼저 나간다라고 했는데, 들어오는 동작. 값을 STACK에 저장하는 동작을 &lt;strong&gt;push&lt;/strong&gt;라고 합니다.&lt;/p&gt;

&lt;p&gt;반대로 나가는 동작. 값을 STACK에서 빼내는 동작을 &lt;strong&gt;pop&lt;/strong&gt;이라고 합니다. 이것이 STACK의 기본 구조이며 동작입니다.&lt;/p&gt;

&lt;p&gt;그럼, 다음 코드를 가지고 STACK 동작 및 용어들을 조금 더 살펴보도록 하겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

void plus(int input) {
	int output = input+2;
	printf(&quot;Result : %d\n&quot;, output);
}

int main(int argc, char* argv[]) {
	int a = 4;
	plus(a);

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드는 입력 값에다 2를 더해서 출력해주는 간단한 내용입니다. 아래 [그림 1-1]은 plus 함수가 동작하고 있는 특정 순간의 STACK 상황을 표현한 내용입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x02_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;[그림 1-2]&lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;STACK은 STACK Frame들이 모여서 만들어진다고도 표현합니다. 풀어서 설명을 좀 해보자면, 각 함수들마다 주어진 동작을 위한 공간이 주어지는데 이런 공간 하나 하나를 STACK Frame이라고 할 수 있겠습니다. 이 공간들이 모여 STACK을 구성하는 것이죠.&lt;/p&gt;

&lt;p&gt;위 그림의 오른편을 보면, Main Function STACK Frame이라고 적힌 것을 보실 수 있습니다. 
그 아래로 Plus Function STACK Frame이라고 적혀 있죠.&lt;/p&gt;

&lt;p&gt;위 그림처럼, 하나의 함수가 동작하는 중에 다른 함수가 동작되어지는 상황에서는 새롭게 실행되는 함수를 위한 공간을 마련합니다. 
그리고나서 함수가 종료되면 마련해놓았던 공간을 해제합니다.&lt;/p&gt;

&lt;p&gt;STACK은 Heap과는 다르게 여러분들이 직접 할당, 해제할 필요없이 자동으로 진행이 됩니다.&lt;/p&gt;

&lt;p&gt;마지막으로, 함수가 실행되어 동작하는 과정에서 STACK에 값을 저장하거나, STACK의 값을 참조하는 등의 행동을 할 때는 Offset을 가지고 합니다.&lt;/p&gt;

&lt;p&gt;그런데 이 Offset이라는 게 어떤 지점까지의 거리니까 기준점이 있어야겠죠? 그 기준점으로 주로 활용되는 것이 EBP와 ESP입니다.&lt;/p&gt;

&lt;p&gt;새로운 함수를 위해 Frame을 구성하면 제일 먼저하는 동작. 함수의 프롤로그 과정이죠.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;push ebp
mov ebp,esp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;새로운 함수를 위해 Frame을 구성하면 제일 먼저 프롤로그 과정을 통해 기준점을 생성합니다. 이 기준점을 생성할 때는 아무 값이나 설정하는 것이 아니라
이전 STACK Frame의 기준점을 가지고 옵니다.&lt;/p&gt;

&lt;p&gt;그래서 STACK에 그림으로 표기할 때, EBP(Extended Base Pointer)라는 용어와 SFP(Saved Frame Pointer)라는 용어도 같이 사용하죠.&lt;/p&gt;

&lt;p&gt;이전 STACK의 기준점을 가지고와서 현재 STACK Frame의 기준으로 쓰다가 함수가 종료되는 시점. 에필로그 과정에서 다시 되돌려 줍니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mov esp, ebp
pop ebp
pop eip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 과정을 통해 EBP를 원래대로 돌려줄 뿐만 아니라, 이전 Frame 안의 다음 주소로 이동하게 됩니다.
Offset의 기준을 ESP로 잡더라도 EBP를 새로운 STACK Frame에 구성하는 행위는 변함없습니다.&lt;/p&gt;

&lt;p&gt;아래는 지금까지 설명한 내용들을 정리한 내용들입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SFP&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;-Saved Frame Pointer는 현재 STACK Frame의 지역 변수들을 위한 기준점 역할을 합니다.&lt;/p&gt;

    &lt;p&gt;-예전 STACK Frame이 가지고 있던 EBP가 현재 STACK Frame의 EBP(Extended Base Pointer)에 저장됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;함수 호출&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;-함수가 호출되면, 새로운 STACK Frame이 생성됩니다.&lt;/p&gt;

    &lt;p&gt;-함수 동작에 필요한 인자들을 STACK에 저장합니다.&lt;/p&gt;

    &lt;p&gt;-현재 EBP와 Return Address가 저장됩니다.&lt;/p&gt;

    &lt;p&gt;-ESP는 새로운 STACK Frame에 맞추어 변경됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;함수 종료&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;-함수 사용에 필요했던 STACK Frame이 제거됩니다.&lt;/p&gt;

    &lt;p&gt;-EBP가 이전에 저장했뒀던 값으로 되돌려지고, Return Address로 코드의 흐름이 바뀝니다.&lt;/p&gt;

    &lt;p&gt;-ESP는 되돌아온 STACK Frame에 맞추어 변경됩니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;STACK에 대한 이야기는 이쯤해두고, 다음 연재부터는 본격적으로 Stack based overflow를 다루어보겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x02 STACK</summary>
      

      
      
    </entry>
  
</feed>
