<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="/author/Joel/feed.xml" rel="self" type="application/atom+xml" />
  <link href="/" rel="alternate" type="text/html" />
  <updated>2019-03-27T21:47:49+09:00</updated>
  <id>/author/Joel/feed.xml</id>

  
  
  

  
    <title type="html">LIN ARENA | </title>
  

  
    <subtitle>LIN ARENA Technology Blog</subtitle>
  

  

  
    
      
    
      
    
      
    
      
    
      
    
  

  
  

  
    <entry>
      <title type="html">windows-0x09</title>
      <link href="/windows-0x09" rel="alternate" type="text/html" title="windows-0x09" />
      <published>2019-03-24T20:18:00+09:00</published>
      <updated>2019-03-24T20:18:00+09:00</updated>
      <id>/windows-0x09</id>
      <content type="html" xml:base="/windows-0x09">&lt;h1 id=&quot;0x09-dep3&quot;&gt;0x09 DEP(3)&lt;/h1&gt;

&lt;p&gt;이번 시간에는 DEP의 마지막 주제인 ROP에 대해서 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;rop-return-oriented-programming&quot;&gt;ROP (Return Oriented Programming)&lt;/h5&gt;

&lt;p&gt;ROP는 Gadget으로 Chain을 구성하여 API를 호출하는 방식의 공격 기법입니다.&lt;/p&gt;

&lt;p&gt;주로 VirtualProtect()나 SetProcessDEPPolicy() 등 메모리와 관련된 함수들을 호출하며,&lt;/p&gt;

&lt;p&gt;Shellcode를 실행할 수 있도록 실행 권한을 추가하는 방향으로 진행됩니다.&lt;/p&gt;

&lt;p&gt;이번 연재에서는 가장 흔하고 쉬운 방식인 VirtualProtect() API를 호출해서 DEP를 우회하도록 하겠습니다.&lt;/p&gt;

&lt;h6 id=&quot;virtualprotect-함수&quot;&gt;VirtualProtect 함수&lt;/h6&gt;

&lt;p&gt;VirtualProtect는 4개의 인자를 가지며, 특정 메모리 영역의 실행 권한을 변경해주는 함수입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BOOL WINAPI VirtualProtect (
		_In_ LPVOID lpAddress, 		 # 권한을 변경할 메모리 영역의 시작 주소
		_In_ SIZE_T dwSize,	   		 # 변경할 크기
		_In_ flNewProtect,     		 # 변경할 속성 값
		_Out_ PDWORD lpflOldProtect, # 이전 값 저장 (쓰기 가능한 영역)
	);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;VirtualProtect 함수는 변경을 원하는 메모리 영역의 시작 주소를 기준으로 원하는 크기만큼 실행 권한을 변경해줍니다.&lt;/p&gt;

&lt;p&gt;그럼 ShellCode를 넣어둔 뒤, 그 크기만큼 실행 권한을 주면 되겠네요.&lt;/p&gt;

&lt;p&gt;이 내용을 STACK으로 구성하면 다음과 같습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;그림처럼 STACK을 구성할 경우, VirtualProtect()가 호출되어 ShellCode가 들어있는 메모리 주소에 실행 권한이 생길 것이고,&lt;/p&gt;

&lt;p&gt;다음 RET에서 JMP ESP가 호출되어 ShellCode가 실행될 것 입니다.&lt;/p&gt;

&lt;p&gt;그리고 이 모양의 STACK을 구성하기 위해 PUSHAD 명령어를 이용할 것 입니다. STACK 구성이 좀 더 쉽겠죠?&lt;/p&gt;

&lt;h5 id=&quot;payload-구성&quot;&gt;PAYLOAD 구성&lt;/h5&gt;

&lt;p&gt;Mona.py를 이용해서 ROP Chain 구성에 사용할 Gadget들을 찾아 보겠습니다. ( !mona modules )&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Gadget은 위의 Module들 중에 ASLR이 적용되어 있지 않은 example.dll에서 가져다 쓰면 되겠네요.&lt;/p&gt;

&lt;p&gt;이제 여기서 Gadget을 구해서 값들을 맞춰주기만 하면 되는데,,, 일일이 하나씩 찾아서 넣으면 엄청나게 많은 시간이 소요되겠죠??&lt;/p&gt;

&lt;p&gt;하나하나 다 찾아다닐 시간은 없으니까 mona.py에서 제공하는 기능을 활용하겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;!mona rop -m example
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 명령어를 사용하면 mona.py에서 자동으로 rop 공격에 필요한 Gadget들을 example.dll에서 찾아 파일로 생성해줍니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;여러 언어에 맞게 추천을 해주는데 여러분 환경에 맞는 값을 사용하시면 됩니다.&lt;/p&gt;

&lt;p&gt;이제 필요한 Gadget들을 아주 손쉽게 찾아왔는데 한 가지 생각해야 할 점이 있습니다.&lt;/p&gt;

&lt;p&gt;바로 VirtualProtect의 함수 주소입니다.&lt;/p&gt;

&lt;p&gt;ASLR이 적용되어 있으면 Window API 함수들의 주소도 계속해서 변할텐데 어떻게 주소를 가지고 올 수 있는 걸까요?&lt;/p&gt;

&lt;p&gt;Gadget 파일을 잘 보시면 VirtualProtect에 IAT라고 적혀있는 것을 보실 수 있을 겁니다.&lt;/p&gt;

&lt;p&gt;IAT(Import Address Table)는 프로그램에서 사용되는 라이브러리에서 어떤 함수들을 사용하고 있는지, 그 함수들의 정보를 기술한 테이블입니다.&lt;/p&gt;

&lt;p&gt;아래와 같이 example.dll의 IAT를 살펴보면 우리가 사용하고자 하는 VirtualProtect() 함수의 정보가 들어있는 것을 확인하실 수 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_4.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이렇게 VirtualProtect() 정보가 들어 있는 경우에는 IAT 값에서 시작 주소를 가져다가 쓰면 되는 것이죠.&lt;/p&gt;

&lt;p&gt;없다면? 동적으로 찾아오도록 Gadget을 구성하면 됩니다.&lt;/p&gt;

&lt;h5 id=&quot;null-byte-제거&quot;&gt;Null Byte 제거&lt;/h5&gt;

&lt;p&gt;공격을 성공적으로 하기 위해 Payload에 존재하는 Null Byte들을 제거해줘야겠죠?&lt;/p&gt;

&lt;p&gt;mona가 만들어 준 값들엔 Null Byte가 존재해서 Payload 전달이 완전하게 이루어지지 않는답니다.&lt;/p&gt;

&lt;p&gt;그래서 다음과 같이 수정을 했습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_5.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;먼저, 0x201, 0x40 같은 값을 넣어줘야 하는데 Null이 존재하므로 0xfffffdff, 0xffffffc0를 넣고 neg를 사용해서 값을 생성해줬습니다.&lt;/p&gt;

&lt;p&gt;그리고 Gadget 주소 중에 Null이 존재하는 것은 다른 Gadget 찾아서 교체해준 내용입니다.&lt;/p&gt;

&lt;p&gt;mona만 믿고 Payload를 구성하시면 안됩니다. 잘 살펴보고 Null은 반드시 제거해주셔야 합니다.&lt;/p&gt;

&lt;p&gt;이어서 DBG로 살펴보면 다음과 같습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_6.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;strcpy가 실행되고 나서의 모습입니다. 각 Gadget들이 연속해서 실행된 뒤, VirtualProtect() 함수가 실행될 것이고,&lt;/p&gt;

&lt;p&gt;마지막에 JMP ESP가 실행되면서 ShellCode가 실행되겠네요.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_7.png&quot; alt=&quot;[그림 1-7]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;잘 실행되네요^^&lt;/p&gt;

&lt;p&gt;지금까지 DEP에 대해서 알아봤습니다.&lt;/p&gt;

&lt;p&gt;다음 연재부터는 Heap Exploit으로 찾아뵙도록 하겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x09 DEP(3)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">windows-0x08</title>
      <link href="/windows-0x08" rel="alternate" type="text/html" title="windows-0x08" />
      <published>2019-03-19T20:18:00+09:00</published>
      <updated>2019-03-19T20:18:00+09:00</updated>
      <id>/windows-0x08</id>
      <content type="html" xml:base="/windows-0x08">&lt;h1 id=&quot;0x08-dep2&quot;&gt;0x08 DEP(2)&lt;/h1&gt;

&lt;h5 id=&quot;what-is-dep&quot;&gt;What is DEP?&lt;/h5&gt;

&lt;p&gt;지난 Post에서 RTL을 다루어 봤습니다.&lt;/p&gt;

&lt;p&gt;이번 시간에는 RTL에 이어 Chaining RTL에 대해 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;chaining-rtl&quot;&gt;Chaining RTL&lt;/h5&gt;

&lt;p&gt;Chaining RTL은 RTL이 Chain처럼 엮여서 반복되는 것을 말합니다.&lt;/p&gt;

&lt;p&gt;RTL이 뭐였죠? DEP가 적용되어 Shellcode를 실행할 수 없게 되었을 때, 라이브러리 함수로 점프하여&lt;/p&gt;

&lt;p&gt;내가 원하는 함수를 실행하는 것이었죠?&lt;/p&gt;

&lt;p&gt;Chaining RTL은 말 그대로 내가 원하는 함수를 계속해서 실행하는 것을 뜻합니다.&lt;/p&gt;

&lt;p&gt;의미는 알았으니, 본격적으로 알아볼텐데 STACK 구성에 집중해서 보시면 되겠습니다.&lt;/p&gt;

&lt;p&gt;먼저, 지난 시간처럼 몇 가지 가정을 하겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;func1(argv1) : 인자를 하나만 필요로 하는 함수&lt;/li&gt;
  &lt;li&gt;func2(argv1’, argv’2) : 인자를 두 개 필요로 하는 함수&lt;/li&gt;
  &lt;li&gt;func3(argv’‘1, argv’‘2, argv’‘3) : 인자를 세 개 필요로 하는 함수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 함수들을 차례대로 호출한다고 가정하고 이 때, Payload를 어떻게 구성해야하는 것인지를 살펴보도록 하겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x07_2.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이 그림 기억나시나요?? 지난 시간에 살펴봤던 함수를 하나만 호출할 때의 STACK 그림입니다.&lt;/p&gt;

&lt;p&gt;Main-ret가 다음 호출할 함수의 SFP로 변경되고 있죠? 그래서 그 다음 4 Byte가 호출된 함수가 종료되고 다음에 갈 곳의 주소인 것도 알고 있습니다.&lt;/p&gt;

&lt;p&gt;그럼 두 번째 함수(인자가 두 개)를 호출할 때 그림이 이렇게 되겠네요?&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x08_1.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Func1() 함수의 RET 자리에 Func2() 함수의 주소를 넣어줬습니다. 그럼 Func1() 함수가 종료된 후, Func2() 함수가 실행됩니다.&lt;/p&gt;

&lt;p&gt;간단하죠?&lt;/p&gt;

&lt;p&gt;그런데 여기엔 문제가 있습니다. 이 방법으로는 내가 원하는 함수를 마음껏 호출할 수가 없습니다.&lt;/p&gt;

&lt;p&gt;그냥 RET에 다른 함수 주소를 덮어주면 되는거 아니야? 라고 생각하실 수 있습니다.&lt;/p&gt;

&lt;p&gt;자, 그럼 다음에 Func3() 함수를 호출한다고 생각해봅시다.&lt;/p&gt;

&lt;p&gt;Func3() 함수의 주소는 어디에 넣어줘야 하죠?&lt;/p&gt;

&lt;p&gt;이미 Func1() 함수의 첫 번째 인자가 위치하고 있습니다. 이제 이해가 가시죠??&lt;/p&gt;

&lt;p&gt;이 한계를 해결하기 위해 지금부터는 Gadget을 사용할 겁니다.&lt;/p&gt;

&lt;p&gt;RET로 끝나는 많고 많은 Gadget 중에 시스템 해킹에서 주로 사용되는 Gadget은 다음 3가지 입니다.
(이것만 쓴다는 게 아닙니다!!)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;pr : POP RET&lt;/li&gt;
  &lt;li&gt;ppr : POP POP RET&lt;/li&gt;
  &lt;li&gt;pppr : POP POP POP RET&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;POP 뒤에 Operand는 생략했습니다.&lt;/p&gt;

&lt;p&gt;이 Gadget을 이용해서 내가 원하는만큼 함수를 호출하려면 STACK을 다음과 같이 구성하면 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x08_2.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;조금 이상하고 복잡한 듯이 느껴질 수 있는데, 에필로그 과정부터 Gadget 순으로 색깔별로 보시면 됩니다.&lt;/p&gt;

&lt;p&gt;먼저 에필로그부터 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;RETN이 실행되면 POP EIP, JMP EIP를 수행하므로 실행되고 난 후, ESP의 위치는 빨간 ESP 위치가 됩니다.&lt;/p&gt;

&lt;p&gt;JMP EIP가 실행되면 POP RETN이 실행되겠죠?&lt;/p&gt;

&lt;p&gt;처음 POP이 실행되면 STACK 최상단의 값을 꺼내고 ESP가 올라가면서 ESP의 위치는 파란 ESP 위치가 됩니다.&lt;/p&gt;

&lt;p&gt;다시 RETN이 실행되면 POP EIP, JMP EIP가 실행되겠네요.&lt;/p&gt;

&lt;p&gt;그럼 그 때의 ESP는 초록색 위치가 되는데 POP EIP를 했으므로 EIP엔 두 번째 함수 Func2()의 주소가 들어가게 될 것이고&lt;/p&gt;

&lt;p&gt;JMP EIP를 하면서 Func2() 함수가 실행됩니다.&lt;/p&gt;

&lt;p&gt;세 번째 함수까지 모두 호출한다고 가정했을 때, STACK의 구조는 다음과 같이 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x08_3.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이런 식으로 STACK을 구성해서 내가 원하는 함수를 계속해서 호출하는 기법을 Chaining RTL이라고 부릅니다.&lt;/p&gt;

&lt;p&gt;자, 이제 ROP를 하기 위한 기초 준비 작업을 모두 마쳤습니다.&lt;/p&gt;

&lt;p&gt;다음 Post에서 ROP를 알아보고 DEP편을 마무리 짓도록 하겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x08 DEP(2)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">windows-0x07</title>
      <link href="/windows-0x07" rel="alternate" type="text/html" title="windows-0x07" />
      <published>2019-03-19T19:18:00+09:00</published>
      <updated>2019-03-19T19:18:00+09:00</updated>
      <id>/windows-0x07</id>
      <content type="html" xml:base="/windows-0x07">&lt;h1 id=&quot;0x07-dep1&quot;&gt;0x07 DEP(1)&lt;/h1&gt;

&lt;h5 id=&quot;what-is-dep&quot;&gt;What is DEP?&lt;/h5&gt;

&lt;p&gt;DEP는 특정 메모리의 실행 권한을 제거하여, 메모리에 올라온 Shellcode의 실행을 막는 메모리 보호 기법입니다.&lt;/p&gt;

&lt;p&gt;DEP는 Window XP Service Pack 2에서부터 적용된 기법이며, H/W 기반 DEP와 S/W 기반 DEP로 나눌 수 있습니다.&lt;/p&gt;

&lt;p&gt;이 두 가지 방식의 차이는 CPU가 하드웨어적으로 DEP를 지원 가능한가를 기준으로 나뉜다고 생각하시면 됩니다.&lt;/p&gt;

&lt;p&gt;CPU에서 지원 가능한 경우 H/W DEP라 하고, 그렇지 않은 경우 S/W로 그 기능을 지원하는 방식인 것이죠.&lt;/p&gt;

&lt;p&gt;최근 나온 CPU들은 대부분 H/W 기능을 지원하므로 일반적으로 DEP라고 하면 H/W DEP라고 생각하시면 됩니다.&lt;/p&gt;

&lt;p&gt;DEP에는 아래와 같이 4가지 종류의 옵션이 존재합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;OptIn : 지정된 Binary만 보호&lt;/li&gt;
  &lt;li&gt;OptOut : 지정된 Binary를 제외하고 보호&lt;/li&gt;
  &lt;li&gt;AlwaysOn : 모든 Process 항상 보호&lt;/li&gt;
  &lt;li&gt;AlwaysOff : 모든 Process 보호하지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;OS를 설치한 후, 직접 변경한 적이 없다면 Default로 OptIn 옵션이 적용되어 있고 다음과 같이 확인할 수 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x07_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;DEP가 적용되면 Shellcode를 STACK에 넣어서 실행해왔던 지금까지의 방법으로는 성공할 수가 없게 됩니다.&lt;/p&gt;

&lt;p&gt;하지만 이 기법 역시 우회가 가능하며, DEP를 우회하기 위해 필요한 기법과 개념들은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Gadget&lt;/li&gt;
  &lt;li&gt;RTL&lt;/li&gt;
  &lt;li&gt;Chaining RTL&lt;/li&gt;
  &lt;li&gt;ROP&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;지금부터 하나씩 살펴보겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;gadget&quot;&gt;Gadget&lt;/h5&gt;

&lt;p&gt;Gadget이란 “mov esp, ebp” 등의 명령어 조각을 의미했었습니다.&lt;/p&gt;

&lt;p&gt;하지만 지금 시스템 해킹에서의 Gadget은 RET로 끝나는 명령어 조각을 의미하게 되었습니다.&lt;/p&gt;

&lt;p&gt;이 Gadget이 공격에서 왜 중요한지는 Chaining RTL과 ROP를 다루면서 이야기하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;rtl&quot;&gt;RTL&lt;/h5&gt;

&lt;p&gt;RTL은 Return to Library의 약자로 해석을 하면 Library로 돌아간다는 의미입니다.&lt;/p&gt;

&lt;p&gt;Library로 돌아간다?&lt;/p&gt;

&lt;p&gt;아까 앞에서 DEP가 적용되면 Shellcode를 실행할 수가 없다고 했었던 것 기억나시죠?&lt;/p&gt;

&lt;p&gt;그래서 RET를 Shellcode의 주소로 변조하는 것이 아니라, 실행 권한이 있을 수 밖에 없는 Library의 함수의 주소로 변조하는 것이죠.&lt;/p&gt;

&lt;p&gt;그리고!!!&lt;/p&gt;

&lt;p&gt;RTL에서 가장 중요한 것은 함수의 인자를 직접 생성해야 한다는 것입니다.&lt;/p&gt;

&lt;p&gt;Shellcode를 실행했을 때와는 다르게 이 방법은 RET 주소를 원하는 함수의 주소로 바꿔줬을 뿐이기 때문이죠.&lt;/p&gt;

&lt;p&gt;그 함수가 실행되기 위해서는 함수의 동작에 필요한 인자들이 있어야하겠죠?&lt;/p&gt;

&lt;p&gt;CPU가 알아서 자동으로 만들어 줄리가 없으니,,STACK에 직접 구성해줘야 합니다.&lt;/p&gt;

&lt;p&gt;인자를 1개만 취하는 함수 Func()가 있다고 가정하겠습니다.&lt;/p&gt;

&lt;p&gt;RTL 기법으로 이 함수를 호출하기 위해서는 STACK을 다음과 같이 구성해야 합니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x07_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 그림에서 중간 STACK 그림을 보면 Func을 호출하기 위해 RET를 Func 함수의 주소로 변조하고, 그 위치에서 +8만큼 떨어진 곳에 함수의 인자를 구성한 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;그런데 왜 인자의 위치를 저렇게 구성해줘야 할까요?&lt;/p&gt;

&lt;p&gt;다음 그림을 보면서 설명해보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x07_3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;빨간 색으로 표시된 부분은 Main 함수의 에필로그 과정, 파란 색으로 표신된 부분은 Func 함수의 프롤로그 과정을 나타낸 것 입니다.&lt;/p&gt;

&lt;p&gt;먼저, 빨간 색. Main 함수의 에필로그 과정을 봅시다.&lt;/p&gt;

&lt;p&gt;POP EIP, JMP EIP를 코드를 수행했을 때의 위치가 가장 왼쪽 STACK에 표시된 ESP가 가르키는 곳 입니다.&lt;/p&gt;

&lt;p&gt;이후, JMP EIP 코드가 실행되면 새로운 함수가 실행되고 새 함수의 프롤로그 과정이 진행됩니다.&lt;/p&gt;

&lt;p&gt;프롤로그 과정의 일부인 PUSH EBP가 실행되면 새 STACK Frame의 기준점을 만듭니다.&lt;/p&gt;

&lt;p&gt;여기까지 진행된 후, STACK을 살펴봅시다.&lt;/p&gt;

&lt;p&gt;Main 함수의 RET가 뒤이어 실행되는 함수의 SFP 자리로 바뀐다는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;그리고 그 다음에, RET를 만들어주었습니다.&lt;/p&gt;

&lt;p&gt;RTL이 아니라 정상적인 방식인 CALL을 통해 함수가 실행된다면 STACK에 다음에 실행할 곳의 위치를 넣어줍니다.&lt;/p&gt;

&lt;p&gt;그런데 우리는 컴파일러가 만들어주는 것이 아니기 때문에 직접 만들어줘야 합니다.&lt;/p&gt;

&lt;p&gt;그래서 저 위치에 다음에 실행할 곳의 주소 역할을 할 값을 직접 넣어 구성해주는 것 입니다.&lt;/p&gt;

&lt;p&gt;쉽게 생각하면 컴파일러가 만들어주는 구조를 똑같이 흉내낸다고 생각하시면 되겠습니다.&lt;/p&gt;

&lt;p&gt;이것이 RTL의 전부입니다.&lt;/p&gt;

&lt;p&gt;다음은 디버거를 통해 RTL을 진행한 그림입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x07_4.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x07_5.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;잘 실행이 되네요^^&lt;/p&gt;

&lt;p&gt;그런데 이 방식은 실제 환경에서는 거의 불가능한 방법이라는 것도 알아두셔야 합니다.&lt;/p&gt;

&lt;p&gt;실제 환경에서는 ASLR, Safe SEH 등이 기본적으로 적용되어 있기 때문에 내가 원하는 함수의 주소를 찾아내기 힘들기 때문입니다.&lt;/p&gt;

&lt;p&gt;그래서 이 기법은 ROP를 위한 기본 개념 정도로만 이해하시기 바랍니다.&lt;/p&gt;

&lt;p&gt;글이 너무 길어졌네요. 이만 줄이고 다음 편에서 ROP를 알아보도록 하겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x07 DEP(1)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">windows-0x06</title>
      <link href="/windows-0x06" rel="alternate" type="text/html" title="windows-0x06" />
      <published>2019-03-18T19:18:00+09:00</published>
      <updated>2019-03-18T19:18:00+09:00</updated>
      <id>/windows-0x06</id>
      <content type="html" xml:base="/windows-0x06">&lt;h1 id=&quot;0x06-gs2&quot;&gt;0x06 GS(2)&lt;/h1&gt;

&lt;h5 id=&quot;safeseh&quot;&gt;SafeSEH&lt;/h5&gt;

&lt;p&gt;SafeSEH는 SEH Overwite를 방어하기 위해 도입된 메모리 보호 기법입니다.&lt;/p&gt;

&lt;p&gt;SafeSEH가 하는 일은 아주 간단합니다.&lt;/p&gt;

&lt;p&gt;Exception Handler가 실행되기 전에 Handler 주소 값에 대한 검증을 수행합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1) 등록된 Handler의 주소가 STACK인지 확인해서 STACK이면 호출하지 않음.&lt;/li&gt;
  &lt;li&gt;2) Handler의 주소가 현재 로드된 모듈의 주소이고, SafeSEH 컴파일이 되어 있다면 적절한 절차로 등록된 것인지 검증.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;까다롭죠??&lt;/p&gt;

&lt;p&gt;그런데 해법이 상당이 간단합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1) Handler의 주소가 STACK이 아니면 된다.&lt;/li&gt;
  &lt;li&gt;2) SafeSEH 컴파일이 되어 있지 않으면 된다.&lt;/li&gt;
  &lt;li&gt;결론 : SafeSEH가 안걸려 있는 모듈에서 Gadget을 찾아오면 된다!!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;간단하죠?&lt;/p&gt;

&lt;p&gt;Immunity Debugger에서 mona.py를 이용하면 Module들에 어떤 보호기법들이 적용되어 있는지 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;!mona modules
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x06_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이 중에 SafeSEH가 적용되어 있지 않은 Module을 골라서 우회 공격을 동일하게 진행하면 됩니다.&lt;/p&gt;

&lt;p&gt;이상으로 GS편을 모두 마치겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x06 GS(2)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">DLL Hijacking &amp;amp; Ghidra</title>
      <link href="/Dll-Hijacking-&-Ghidra" rel="alternate" type="text/html" title="DLL Hijacking &amp; Ghidra" />
      <published>2019-03-17T19:18:00+09:00</published>
      <updated>2019-03-17T19:18:00+09:00</updated>
      <id>/Dll%20Hijacking%20&amp;%20Ghidra</id>
      <content type="html" xml:base="/Dll-Hijacking-&amp;-Ghidra">&lt;h1 id=&quot;dll-hijacking--ghidra&quot;&gt;DLL Hijacking &amp;amp; Ghidra&lt;/h1&gt;

&lt;p&gt;안녕하세요. Joel입니다.&lt;/p&gt;

&lt;p&gt;방구석에 누워있다 갑자기 DLL Hijacking 포스팅을 올리라는 일거리를 받아서 글을 쓰게 되었습니다. 허허..&lt;/p&gt;

&lt;h5 id=&quot;overview&quot;&gt;Overview&lt;/h5&gt;

&lt;p&gt;DLL Hijacking은 PE 프로그램이 의도하지 않은 external library(dll)을 실행하도록 만드는 것 입니다. 
이 공격은 DLL Search Order 때문에 취약한 PE 프로그램이 공격자가 작성한 DLL을 로드하고 실행하게 됩니다.
지금부터, 취약한 프로그램 분석과 Hijacking할 dll을 찾는 과정 등을 하나씩 살펴보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;먼저, 오늘 포스팅에서 사용한 Tool과 환경구축 내용입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Ghidra (jdk 11 이상, 64bit 필수)&lt;/li&gt;
  &lt;li&gt;PuTTY 0.65&lt;/li&gt;
  &lt;li&gt;Sysinternals suite&lt;/li&gt;
  &lt;li&gt;Visual Studio 2017&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;find-the-dlls-which-are-loaded-by-target-application&quot;&gt;Find the dlls which are loaded by target application.&lt;/h5&gt;

&lt;h6 id=&quot;procexp&quot;&gt;Procexp&lt;/h6&gt;

&lt;p&gt;PuTTY 0.65를 실행한 뒤, Sysinternals의 Procexp.exe를 통해 어떤 dll들을 사용하는지 확인해보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/dll/0x00_2.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Procexp.exe에서 [View]-[Lower Pane View]-[DLLs] 설정을 하면 PuTTY 프로그램이 로드한 dll 목록들을 확인할 수 있습니다.
그런데 이것만 가지고는 어떤 dll을 hijack할 수 있는지 알 수가 없습니다. 결과만 보이기 때문이죠.&lt;/p&gt;

&lt;p&gt;그래서 이번에는 Sysinternals의 Procmon을 실행시켜서 dll이 로드되는 과정을 살펴보겠습니다.&lt;/p&gt;

&lt;h6 id=&quot;procmon&quot;&gt;Procmon&lt;/h6&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/dll/0x00_3.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Procmon을 실행한 후 필터를 위와 같이 설정합니다. 그럼 아래와 같이 PuTTY가 dll을 로드하는 과정에서 발생한 내용들을 볼 수가 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/dll/0x00_4.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 그림과 Procexp의 내용을 종합해보면 PuTTY는 WINMM.dll을 자신이 있는 디렉터리에서 먼저 찾아서 로드하려고 한다는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;하지만 해당 디렉터리에는 WINMM.dll이 없기에 결과적으로는 C:\Windows\SysWOW64\WINMM.dll을 로드하고 있습니다.&lt;/p&gt;

&lt;p&gt;만약 해당 디렉터리에 이 WINMM.dll이 존재한다면 어떻게 될까요? ^^&lt;/p&gt;

&lt;p&gt;아 물론, 여기서 해당 디렉터리에 low priv user가 Write Access가 가능하다는 전제하에 진행하는 것입니다.&lt;/p&gt;

&lt;p&gt;만약, 해당 디렉터리가 C:\, C:\Program Files 등 Admin 권한이 필요한 경우에는 UAC 팝업이 뜨겠죠?&lt;/p&gt;

&lt;p&gt;UAC 팝업은 쉽게 우회가 가능하나, 이 글의 범위를 넘어서므로 바탕화면 특정 디렉터리에서 진행합니다.&lt;/p&gt;

&lt;p&gt;계속 갑니닷.&lt;/p&gt;

&lt;h6 id=&quot;find-a-target-function-with-ghidra&quot;&gt;Find a Target Function with Ghidra&lt;/h6&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/dll/0x00_5.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Target Function을 Ghidra를 이용해서 찾아보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/dll/0x00_1.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;[Symbol Tree] - [Imports] - [WINMM.dll]을 따라가면 PlaySoundA라는 함수를 찾을 수 있습니다. 쉽죠??&lt;/p&gt;

&lt;p&gt;그럼 이제 우리가 해야할 일은 Hijacking에 사용할 dll을 만드는 것 입니다.&lt;/p&gt;

&lt;h6 id=&quot;make-a-dll&quot;&gt;Make a DLL&lt;/h6&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &quot;stdafx.h&quot;

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {

	switch (ul_reason_for_call) {
	case DLL_PROCESS_ATTACH:
		WinExec(&quot;calc&quot;, SW_NORMAL);
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
		break;

	}
	return true;
}

extern &quot;C&quot; __declspec(dllexport) void PlaySoundA() {
	WinExec(&quot;calc&quot;, SW_NORMAL);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 PuTTY가 실행될 때 계산기를 실행하도록 새로운 dll을 생성했습니다.&lt;/p&gt;

&lt;h6 id=&quot;execute-target-program&quot;&gt;Execute Target Program&lt;/h6&gt;

&lt;p&gt;아래와 같이, 같은 디렉터리에 방금 만든 dll을 위치시킨 후, 실행해보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/dll/0x00_6.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
&lt;/figure&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/dll/0x00_7.png&quot; alt=&quot;[그림 1-7]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;계산기가 잘 실행되네요. ^^&lt;/p&gt;

&lt;p&gt;지금까지 DLL Hijacking에 대해서 알아봤습니다. 뿅!&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">DLL Hijacking &amp;amp; Ghidra</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">windows-0x05</title>
      <link href="/windows-0x05" rel="alternate" type="text/html" title="windows-0x05" />
      <published>2019-03-09T19:18:00+09:00</published>
      <updated>2019-03-09T19:18:00+09:00</updated>
      <id>/windows-0x05</id>
      <content type="html" xml:base="/windows-0x05">&lt;h1 id=&quot;0x05-gs&quot;&gt;0x05 GS&lt;/h1&gt;

&lt;h5 id=&quot;what-is-gs&quot;&gt;What is GS?&lt;/h5&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x05_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;GS는 STACK Cookie, Canary로도 불리는 메모리 보호 기법입니다.&lt;/p&gt;

&lt;p&gt;이 GS는 BOF를 방어하기 위해 나온 기법 중 하나로, 함수가 시작될 때 STACK에 4 byte를 넣어놓고 함수가 종료될 때 이 4 byte가 변조되었는지 확인합니다.&lt;/p&gt;

&lt;p&gt;만약 이 STACK Cookie가 처음과 다르다면, 프로그램은 바로 종료되어 버립니다.&lt;/p&gt;

&lt;p&gt;아래 그림은 STACK Cookie가 적용되고 검사하는 과정을 나타냅니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x05_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;STACK BOF는 반드시 Buffer의 시작 주소부터 덮기 시작하여 RET를 변조하는 것이기 때문에 GS를 정확하게 똑같이 입력하지 않으면 BOF 공격을 성공할 수가 없죠.&lt;/p&gt;

&lt;p&gt;STACK Cookie는 고정된 값으로 넣어줄 수도 있지만, 값을 랜덤하게 넣거나, 첫 바이트를 Null로 넣어주는 방식도 있습니다.&lt;/p&gt;

&lt;p&gt;따라서, BOF 공격을 방어하기 위한 아주 효과적인 방법이라고 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;그렇다면 이 메모리 기법은 어떻게 우회를 할 수 있을까요??&lt;/p&gt;

&lt;p&gt;이 기법을 우회하기 위해서는 Window의 Error Handlering에 대한 지식이 필요합니다.&lt;/p&gt;

&lt;h5 id=&quot;structured-error-handling&quot;&gt;Structured Error Handling&lt;/h5&gt;

&lt;p&gt;구조적 예외처리(이하 SEH)는 윈도우 운영 체제 특성에 기반한 예외 처리 매커니즘입니다.&lt;/p&gt;

&lt;p&gt;이 SEH는 Thread별로 독립적으로 설치되고 운영되는 특징이 있습니다.&lt;/p&gt;

&lt;p&gt;쉽게 이야기를 해보자면..프로그램이 좀 더 안정적으로 돌아갈 수 있도록 에러가 발생했을 때, 처리를 담당하는 역할을 맡고 있다고 생각하시면 되겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x05_3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 그림은 SEH의 구조와 동작을 표현한 내용입니다. 뭔가 좀 복잡해보이죠??&lt;/p&gt;

&lt;p&gt;하나씩 설명해보도록 할게요.&lt;/p&gt;

&lt;p&gt;프로그램이 실행되다가 에러가 발생하면 FS(=Segment Register)의 0번지의 값을 참조해서 TIB의 Exception_Register라는 값을 찾습니다.&lt;/p&gt;

&lt;p&gt;여기에는 컴파일러가 미리 등록해놓은 에러 처리를 위한 Handler의 주소가 담겨있는데 이를 참조해서 Handler를 호출합니다.&lt;/p&gt;

&lt;p&gt;만약 에러가 해결되지 않는다면 다음 Handler를 호출하는 방식으로 구현되어 있습니다.&lt;/p&gt;

&lt;p&gt;만약 이 Handler가 발생한 에러를 위한 Handler가 맞다면 실행되고 아니면 *next SEH Record를 참조하여 다음 Handler를 실행하러 갑니다.&lt;/p&gt;

&lt;p&gt;그런데 이 과정이 무한 반복이 되면 안되겠죠? 이 과정은 *next SEH Record의 값이 0xffffffff가 될 때까지만 진행이 되고&lt;/p&gt;

&lt;p&gt;만약 0xffffffff가 된다면 Default Exception Handler를 호출하게 됩니다.&lt;/p&gt;

&lt;p&gt;간단하쥬?&lt;/p&gt;

&lt;p&gt;다음 그림을 통해 NSEH와 SEH의 구조를 살펴보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x05_4.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 그림처럼 EXCEPTION_RECORD는 _next와 _handler로 구성되어 있습니다.&lt;/p&gt;

&lt;p&gt;위에서 이미 설명했듯이 _next는 다음 EXCEPTION_RECORD의 위치를 담고 있습니다.&lt;/p&gt;

&lt;p&gt;_handler는 실제로 에러 처리 과정을 실행할 함수이고, 구조는 아래와 같습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x05_5.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 함수 구조와 같이 에러 처리 함수는 4개의 인자를 필요로 하며, 함수 실행 시 실행에 필요한 인자들을 STACK에 구성합니다.&lt;/p&gt;

&lt;p&gt;따라서 에러 처리 함수가 동작되면 STACK 구조는 아래처럼 구성됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x05_6.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이 중 우리가 공격에서 유용하게 사용할 값이 EstablierFrame입니다. EstablierFrame은 이전 Frame의 주소를 가지고 있습니다.&lt;/p&gt;

&lt;p&gt;이게 왜 중요할까요?&lt;/p&gt;

&lt;p&gt;다음에서 우회 기법을 설명하며 EstablierFrame 값이 왜 중요한지 같이 알아보겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;seh-overwrite&quot;&gt;SEH Overwrite&lt;/h5&gt;

&lt;p&gt;우리는 지금까지 GS와 SEH의 개념을 살펴보았습니다.&lt;/p&gt;

&lt;p&gt;STACK Cookie를 우호하는데 왜 SEH의 개념이 필요할까요??&lt;/p&gt;

&lt;p&gt;GS가 적용되면 함수 시작 시, 특정 4Byte를 넣고 함수가 종료될 때 4Byte를 검사한다고 했습니다.&lt;/p&gt;

&lt;p&gt;이를 우회하려면? 반드시 4Byte를 알아내서 동일하게 적어줘야겠죠?&lt;/p&gt;

&lt;p&gt;그런데 이 STACK Cookie를 검사하기 전에 프로그램에 치명적인 에러가 발생한다면 어떻게 될까요?&lt;/p&gt;

&lt;p&gt;윈도우는 이 에러를 먼저 처리하려고 하겠죠???&lt;/p&gt;

&lt;p&gt;이 점을 이용하는 겁니다. 지금부터 이 점을 이용해서 STACK Cookie 검사 과정을 우회할 것 입니다.&lt;/p&gt;

&lt;p&gt;어떻게 할 것이냐? 저는 STACK의 끝까지 더미 값을 넣어서 할당된 STACK 공간 밖에 값을 쓰도록 Payload를 구성할 겁니다.&lt;/p&gt;

&lt;p&gt;그러면? 반드시 에러가 발생하겠죠??&lt;/p&gt;

&lt;p&gt;에러가 발생하면 윈도우의 SEH 과정이 실행됩니다.&lt;/p&gt;

&lt;p&gt;지금까지 이야기한 것을 STACK으로 표현하면 다음과 같습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x05_7.png&quot; alt=&quot;[그림 1-7]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 그림을 살펴보면 _next는 Jump to Shellcode, _handler는 &amp;amp; pop pop ret으로 되어 있죠?&lt;/p&gt;

&lt;p&gt;그리고 아래 STACK Frame에 EstablierFrame도 빨간 색으로 표현되어 있네요.&lt;/p&gt;

&lt;p&gt;먼저, EstablierFrame은 이전 Frame의 _next의 주소를 담고 있습니다.&lt;/p&gt;

&lt;p&gt;_handler가 실행되면서 자체적으로 새로운 Frame을 생성하는데 이 함수의 인자 중 하나가 이전 Frame의 주소를 가지고 있으니까&lt;/p&gt;

&lt;p&gt;다시 원래 Frame으로 돌아가서 Shellcode를 실행하도록 만들자는 것이죠.&lt;/p&gt;

&lt;p&gt;그래서 _handler에는 &amp;amp; pop pop ret를 넣어줬습니다.&lt;/p&gt;

&lt;p&gt;함수의 프롤로그 과정을 잘 떠올려보세요. 그럼 _handler가 실행될 때의 ESP는 그림에서 가장 아래에 있을 것이고&lt;/p&gt;

&lt;p&gt;+8 위치에 EstablierFrame가 있죠? 그래서 &amp;amp; pop pop ret을 넣어주는 것입니다.&lt;/p&gt;

&lt;p&gt;&amp;amp; pop pop ret이 실행되면?? _next로 오겠죠?&lt;/p&gt;

&lt;p&gt;그럼 이제 남은 것은 _next에서 Shellcode가 얼마나 떨어져있는지 계산해서 jump code를 구성해주면 됩니다.&lt;/p&gt;

&lt;p&gt;해당 그림에서는 바로 뒤에 Shellcode를 위치시켰습니다.&lt;/p&gt;

&lt;p&gt;그래서 뛰어 넘을 거리는 6Byte!&lt;/p&gt;

&lt;p&gt;4Byte가 아니냐구요? jump 0x06을 기계어로 바꾸면 06 eb가 됩니다. 2 byte짜리 명령어에요.&lt;/p&gt;

&lt;p&gt;그래서 90 90 06 eb로 구성합니다. 그럼 90 90과 &amp;amp; pop pop ret을 뛰어넘어야 하니까 6byte 맞죠?&lt;/p&gt;

&lt;p&gt;아래 그림은 Immunity Debugger를 이용해서 우회 과정을 살펴본 것입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x05_8.png&quot; alt=&quot;[그림 1-8]&quot; /&gt;
&lt;/figure&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x05_9.png&quot; alt=&quot;[그림 1-9]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;우회가 잘 되죠??&lt;/p&gt;

&lt;p&gt;지금까지 GS에 대한 설명을 했습니다. 다음 연재에서는 Safe SEH 기법에 대해 설명하겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x05 GS</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">windows-0x04</title>
      <link href="/windows-0x04" rel="alternate" type="text/html" title="windows-0x04" />
      <published>2019-03-03T19:18:00+09:00</published>
      <updated>2019-03-03T19:18:00+09:00</updated>
      <id>/windows-0x04</id>
      <content type="html" xml:base="/windows-0x04">&lt;h1 id=&quot;0x04-random-stack&quot;&gt;0x04 Random STACK&lt;/h1&gt;

&lt;h5 id=&quot;what-is-random-stack&quot;&gt;What is Random STACK?&lt;/h5&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x04_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Random STACK은 메모리에서 STACK이 할당되는 주소가 프로그램 실행시마다 변경되는 방어 기법입니다.&lt;/p&gt;

&lt;p&gt;이 방어 기법이 적용되면 Shellcode의 주소를 정확히 알 수가 없기 때문에 기존의 Direct EIP Overwrite로는 공격을 성공할 수가 없습니다.&lt;/p&gt;

&lt;h5 id=&quot;jmp-esp&quot;&gt;JMP ESP&lt;/h5&gt;

&lt;p&gt;Shellcode의 주소를 알 수 없는 상황을 우회하기 위해서 사용하는 방법 중 하나가 “JMP ESP”를 활용하는 것입니다.&lt;/p&gt;

&lt;p&gt;RET 주소에 JMP ESP의 주소를 넣는다는 것인데 어떻게 우회가 가능한지 살펴보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x04_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 그림은 우리가 지금 실습하고 있는 프로그램의 공격 전/후 STACK 구조입니다.&lt;/p&gt;

&lt;p&gt;Main의 에필로그 과정에서 마지막 RETN이 실행될 때 Shellcode를 실행하러 가기 때문에 그 과정을 살펴보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x04_3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;mov esp, ebp : 이전 Frame으로 돌아가기 위해 ESP를 현재 Frame의 기준점으로 데리고 옵니다.&lt;/li&gt;
  &lt;li&gt;POP ebp : 이전 Frame의 기준 값을 POP하여 EBP에 넣어주어 이전 Frame의 기준 값으로 돌아갑니다.&lt;/li&gt;
  &lt;li&gt;RETN : POP EIP, JMP EIP을 통해 다음 실행할 곳으로 이동합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;RETN이 일어날 때의 ESP를 유심히 보면, 항상 RET 다음에 위치하고 있다는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;따라서 RET를 &amp;amp;JMP ESP로 해둔다면 다음 실행할 곳의 위치는 RET 다음 위치가 됩니다.&lt;/p&gt;

&lt;p&gt;이 점을 이용하기 위해 Payload의 구성도 다음과 같이 변경됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x04_4.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 Payload와 그림 1-1의 오른편 공격 후 STACK 구조를 다시 봅시다.&lt;/p&gt;

&lt;p&gt;이전과는 다르게 RET 뒤에 Shellcode가 위치하도록 Payload를 구성한 것을 보실 수 있습니다.&lt;/p&gt;

&lt;p&gt;이런 방법을 이용하면 Shellcode의 주소를 정확히 알 수 없는 환경에서도 공격을 성공시킬 수가 있습니다.&lt;/p&gt;

&lt;h5 id=&quot;how-to-find-jmp-esp&quot;&gt;How to Find &amp;amp;JMP ESP?&lt;/h5&gt;

&lt;p&gt;공격의 흐름과 방법은 아마 이제 다들 아실거라 생각됩니다. 그런데 한 가지 의문이 남죠?&lt;/p&gt;

&lt;p&gt;아마도 “&amp;amp;JMP ESP는 어떻게 찾습니까?”일텐데요.&lt;/p&gt;

&lt;p&gt;이번 연재에서는 Immunity Debugger를 통해서 찾는 방법을 알려드리겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x04_5.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x04_6.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Immunity Debugger에서 ALT+M을 하면 메모리 창이 띄어집니다. 메모리 창에서 CTRL+F를 눌러 “FF E4”(=JMP ESP)를 검색하면 아래와 같이 
JMP ESP의 주소를 찾을 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;다음 편에서는 GS 기법에 대해 알아보도록 하겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x04 Random STACK</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">windows-0x02</title>
      <link href="/windows-0x02" rel="alternate" type="text/html" title="windows-0x02" />
      <published>2019-02-18T19:18:00+09:00</published>
      <updated>2019-02-18T19:18:00+09:00</updated>
      <id>/windows-0x02</id>
      <content type="html" xml:base="/windows-0x02">&lt;h1 id=&quot;0x02-stack&quot;&gt;0x02 STACK&lt;/h1&gt;

&lt;h5 id=&quot;what-is-the-stack&quot;&gt;What is the STACK?&lt;/h5&gt;

&lt;p&gt;STACK은 Main 함수를 포함한 각 함수들이 생성하는 &lt;strong&gt;지역변수&lt;/strong&gt;, &lt;strong&gt;결과값&lt;/strong&gt; 그리고 함수가 필요로 하는 &lt;strong&gt;인자&lt;/strong&gt;들을 저장할 수 있는 메모리 영역입니다.
이 영역은 LIFO(Last In, First Out)이라는 데이터 구조를 가지고 있으며, CPU에 의해 관리되고 최적화되는 영역이기 때문에 데이터를 읽고 쓰는 속도가 매우 빠릅니다. 또한, 어떤 함수가 변수를 선언하면 그 새로운 변수는 스택에 생성되고(push), 함수가 종료될 때 함수가 생성한 모든 변수, 값등은 자동으로 해제됩니다.&lt;/p&gt;

&lt;h5 id=&quot;how-does-the-stack-work&quot;&gt;How does the STACK work?&lt;/h5&gt;

&lt;p&gt;STACK을 설명할 때 가장 먼저 떠오르는 개념이 바로 LIFO입니다. LIFO는 Last In First Out의 앞 글자를 딴 용어이고 한글로는 후입선출이라고 합니다.
설명을 하자면 ‘마지막에 들어온 것이 먼저 나간다’이죠. 아래 그림을 보면서 설명을 이어나가겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x02_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;[그림 1-1]&lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;STACK은 위 그림처럼 한 쪽이 막혀 있고 입구가 하나인 구조를 가지고 있습니다.&lt;/p&gt;

&lt;p&gt;앞에서 제가 마지막에 들어온 것이 먼저 나간다라고 했는데, 들어오는 동작. 값을 STACK에 저장하는 동작을 &lt;strong&gt;push&lt;/strong&gt;라고 합니다.&lt;/p&gt;

&lt;p&gt;반대로 나가는 동작. 값을 STACK에서 빼내는 동작을 &lt;strong&gt;pop&lt;/strong&gt;이라고 합니다. 이것이 STACK의 기본 구조이며 동작입니다.&lt;/p&gt;

&lt;p&gt;그럼, 다음 코드를 가지고 STACK 동작 및 용어들을 조금 더 살펴보도록 하겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

void plus(int input) {
	int output = input+2;
	printf(&quot;Result : %d\n&quot;, output);
}

int main(int argc, char* argv[]) {
	int a = 4;
	plus(a);

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드는 입력 값에다 2를 더해서 출력해주는 간단한 내용입니다. 아래 [그림 1-1]은 plus 함수가 동작하고 있는 특정 순간의 STACK 상황을 표현한 내용입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x02_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;[그림 1-2]&lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;STACK은 STACK Frame들이 모여서 만들어진다고도 표현합니다. 풀어서 설명을 좀 해보자면, 각 함수들마다 주어진 동작을 위한 공간이 주어지는데 이런 공간 하나 하나를 STACK Frame이라고 할 수 있겠습니다. 이 공간들이 모여 STACK을 구성하는 것이죠.&lt;/p&gt;

&lt;p&gt;위 그림의 오른편을 보면, Main Function STACK Frame이라고 적힌 것을 보실 수 있습니다. 
그 아래로 Plus Function STACK Frame이라고 적혀 있죠.&lt;/p&gt;

&lt;p&gt;위 그림처럼, 하나의 함수가 동작하는 중에 다른 함수가 동작되어지는 상황에서는 새롭게 실행되는 함수를 위한 공간을 마련합니다. 
그리고나서 함수가 종료되면 마련해놓았던 공간을 해제합니다.&lt;/p&gt;

&lt;p&gt;STACK은 Heap과는 다르게 여러분들이 직접 할당, 해제할 필요없이 자동으로 진행이 됩니다.&lt;/p&gt;

&lt;p&gt;마지막으로, 함수가 실행되어 동작하는 과정에서 STACK에 값을 저장하거나, STACK의 값을 참조하는 등의 행동을 할 때는 Offset을 가지고 합니다.&lt;/p&gt;

&lt;p&gt;그런데 이 Offset이라는 게 어떤 지점까지의 거리니까 기준점이 있어야겠죠? 그 기준점으로 주로 활용되는 것이 EBP와 ESP입니다.&lt;/p&gt;

&lt;p&gt;새로운 함수를 위해 Frame을 구성하면 제일 먼저하는 동작. 함수의 프롤로그 과정이죠.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;push ebp
mov ebp,esp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;새로운 함수를 위해 Frame을 구성하면 제일 먼저 프롤로그 과정을 통해 기준점을 생성합니다. 이 기준점을 생성할 때는 아무 값이나 설정하는 것이 아니라
이전 STACK Frame의 기준점을 가지고 옵니다.&lt;/p&gt;

&lt;p&gt;그래서 STACK에 그림으로 표기할 때, EBP(Extended Base Pointer)라는 용어와 SFP(Saved Frame Pointer)라는 용어도 같이 사용하죠.&lt;/p&gt;

&lt;p&gt;이전 STACK의 기준점을 가지고와서 현재 STACK Frame의 기준으로 쓰다가 함수가 종료되는 시점. 에필로그 과정에서 다시 되돌려 줍니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mov esp, ebp
pop ebp
pop eip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 과정을 통해 EBP를 원래대로 돌려줄 뿐만 아니라, 이전 Frame 안의 다음 주소로 이동하게 됩니다.
Offset의 기준을 ESP로 잡더라도 EBP를 새로운 STACK Frame에 구성하는 행위는 변함없습니다.&lt;/p&gt;

&lt;p&gt;아래는 지금까지 설명한 내용들을 정리한 내용들입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SFP&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;-Saved Frame Pointer는 현재 STACK Frame의 지역 변수들을 위한 기준점 역할을 합니다.&lt;/p&gt;

    &lt;p&gt;-예전 STACK Frame이 가지고 있던 EBP가 현재 STACK Frame의 EBP(Extended Base Pointer)에 저장됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;함수 호출&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;-함수가 호출되면, 새로운 STACK Frame이 생성됩니다.&lt;/p&gt;

    &lt;p&gt;-함수 동작에 필요한 인자들을 STACK에 저장합니다.&lt;/p&gt;

    &lt;p&gt;-현재 EBP와 Return Address가 저장됩니다.&lt;/p&gt;

    &lt;p&gt;-ESP는 새로운 STACK Frame에 맞추어 변경됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;함수 종료&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;-함수 사용에 필요했던 STACK Frame이 제거됩니다.&lt;/p&gt;

    &lt;p&gt;-EBP가 이전에 저장했뒀던 값으로 되돌려지고, Return Address로 코드의 흐름이 바뀝니다.&lt;/p&gt;

    &lt;p&gt;-ESP는 되돌아온 STACK Frame에 맞추어 변경됩니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;STACK에 대한 이야기는 이쯤해두고, 다음 연재부터는 본격적으로 Stack based overflow를 다루어보겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x02 STACK</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">windows-0x03</title>
      <link href="/windows-0x03" rel="alternate" type="text/html" title="windows-0x03" />
      <published>2019-02-18T19:18:00+09:00</published>
      <updated>2019-02-18T19:18:00+09:00</updated>
      <id>/windows-0x03</id>
      <content type="html" xml:base="/windows-0x03">&lt;h1 id=&quot;0x03-basic-bof&quot;&gt;0x03 Basic Bof&lt;/h1&gt;

&lt;h5 id=&quot;what-is-the-buffer-overflow&quot;&gt;What is the Buffer Overflow?&lt;/h5&gt;

&lt;p&gt;Buffer Overflow(이하 BOF)는 데이터의 저장 또는 보관을 위해 주어진 메모리 공간의 크기보다 더 많은 값을 입력해 인접 메모리의 값을 변조할 수 있는 공격 기법입니다. 공격자들이 BOF를 이용해서 주로 하는 일은 변수의 값을 변조하는 것과 RET를 변조해서 프로그램의 흐름을 조작하는 것입니다.&lt;/p&gt;

&lt;p&gt;이 취약점은 왜 발생할까요?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;strcpy, gets 등의 입력 값 길이를 체크하지 않는 취약한 문자열 함수의 사용&lt;/li&gt;
  &lt;li&gt;길이 값 검증을 하지 않은 취약한 프로그램 설계&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;BOF는 흔히 위의 두 가지 이유로 발생합니다. 그렇다면 이 취약점이 발생하지 않게 하려면 어떻게 하면 될까요?
입력 값 길이를 체크하는 안전한 문자열 함수를 사용하면 되겠죠? 물론 이것도 중요하지만 안전한 함수의 사용만으로는 이 공격을 100% 막을 수는 없습니다. 안전한 함수로 문자열 길이 500만큼 받도록 해놓더라도 버퍼의 크기가 300이면 BOF가 일어날 수 있습니다. 그렇기 때문에 안전한 문자열 함수의 사용과 더불어 &lt;strong&gt;안전한 프로그램 설계&lt;/strong&gt;도 뒷받침되어야 합니다.&lt;/p&gt;

&lt;h5 id=&quot;direct-eip-overwrite&quot;&gt;Direct EIP Overwrite&lt;/h5&gt;

&lt;p&gt;아래 소스코드를 가지고 가장 기초적인 BOF를 다루어보도록 하겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

#pragma warning (disable:4996)
#define _CRT_SECURE_NO_WARNINGS

int main(int argc, char* argv[]) {

    char content_buffer[1000];
    char display_buffer[300];
    FILE *f = fopen(argv[1], &quot;rb&quot;);

    fgets(content_buffer, 1000, f);
    strcpy(display_buffer,content_buffer);

    printf(&quot;%s\n&quot;, display_buffer);

    fclose(f);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;fgets로 길이 1000만큼 파일을 읽어와서 content_buffer에 값을 저장하고, 다시 content_buffer에서 display_buffer로 값을 복사한 후 출력해주는 프로그램입니다. 여기서 문제는 strcpy로 content_buffer에서 display_buffer로 값을 복사한다는 것이죠.&lt;/p&gt;

&lt;p&gt;본격적으로 공격을 시작해보도록 하겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Buffer 시작 주소에서 RET까지의 거리 알아내기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Buffer 시작 위치에서 값을 얼마나 넣어야 RET를 변조할 수 있는지 알아야 공격이 가능하겠죠?&lt;/p&gt;

&lt;p&gt;지금은 거리를 모르니 다음과 같이 간단하게 “A” 100개만 넣어서 분석을 해보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x03_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;[그림 1-1]&lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x03_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;[그림 1-2]&lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Buffer 시작 위치가 EBP-12C인 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;SFP도 덮어줘야 하니까 거리는 304가 되겠네요.(12C = 300)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Exploit 작성하기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;메모리 보호기법이 적용되지 않은 프로그램이기 때문에 RET를 Shellcode가 있는 곳의 주소로 변조하기만 하면 됩니다.&lt;/p&gt;

&lt;p&gt;그럼 Payload는 아래 코드와 같이 Nop과 Shellcode를 합쳐서 304만큼 만들어주고, RET는 Shellcode 시작 전 Nop이 있는 위치로 지정하면 되겠네요.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x03_3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;[그림 1-3]&lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;immunity debugger로 프로그램 흐름을 한 번 살펴보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x03_4.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;[그림 1-4]&lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Strcpy가 동작이 완료된 후, RET가 Buffer 시작 주소로 잘 변조되었네요.&lt;/p&gt;

&lt;p&gt;Main 함수의 RET를 변조했기 때문에 실제로 Shellcode가 실행되는 시점은 Main 함수의 에필로그 과정이 진행된 다음입니다.&lt;/p&gt;

&lt;p&gt;에필로그 과정의 마지막에서 변조된 RET 주소로 프로그램의 흐름이 바뀌면 다음과 같이 Shellcode를 만나러 갑니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x03_5.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;[그림 1-5]&lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;공격 결과 확인&lt;/li&gt;
&lt;/ul&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x03_6.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;[그림 1-6]&lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;CMD가 정상적으로 잘 실행되네요^^&lt;/p&gt;

&lt;p&gt;지금까지 Direct EIP Overwrite에 대해서 알아봤습니다. 다음 연재에서는 메모리 보호 기법 중 하나인 ASLR의 개념과 우회 방법을 다루어보도록 하겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x03 Basic Bof</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">windows-0x01</title>
      <link href="/windows-0x01" rel="alternate" type="text/html" title="windows-0x01" />
      <published>2019-02-07T19:18:00+09:00</published>
      <updated>2019-02-07T19:18:00+09:00</updated>
      <id>/windows-0x01</id>
      <content type="html" xml:base="/windows-0x01">&lt;h1 id=&quot;0x01-윈도우-메모리&quot;&gt;0x01 윈도우 메모리&lt;/h1&gt;

&lt;h3 id=&quot;가상-메모리&quot;&gt;가상 메모리&lt;/h3&gt;

&lt;h5 id=&quot;x86-메모리-구조&quot;&gt;x86 메모리 구조&lt;/h5&gt;
&lt;p&gt;x86 윈도우의 경우 각 프로세스 별로 최대 4GB를 지원합니다. 이 중 상위 절반(0xFFFFFFFF~0x80000000)은 OS 메모리로 사용하고(커널영역), 나머지 하위 절반(0x7FFFFFFF~0x00000000)은 프로세스가 독립적으로 사용할 수 있도록 제공합니다.(유저영역)
그림 1-1는 32비트 윈도우에 의해 지원되는 전형적인 가상 주소 공간 배치를 나타냅니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x01_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;[그림 1-1]&lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;그림 1-1에서 확인하였듯이 커널 영역은 다른 프로세스와 공통으로 사용하는 구조로 되어 있습니다. 그리고 이 영역은 OS가 사용하는 아주 중요한 영역입니다. 그래서 윈도우에서는 유저 영역에서 운영체제의 데이터에 접근하거나 수정하는 것을 막기 위해 두 가지 접근 모드(커널모드, 유저모드)를 사용합니다. &lt;strong&gt;유저 모드&lt;/strong&gt;는 커널 영역에 대한 접근을 할 수가 없지만, &lt;strong&gt;커널 모드&lt;/strong&gt;는 모든 시스템 메모리와 모든 CPU 명령어 등에 대해 접근이 허가된 실행모드를 말합니다. 이렇게 함으로써, 윈도우는 운영체제 시스템 커널에 잘못된 사용자 어플리케이션이 오동작을 유발하여, 시스템 전체의 안정성을 해치지 않게 보장하고 있습니다. 표 1-1은 커널모드, 유저모드를 뜻하는 다양한 용어들에 대한 정리입니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;모드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;용어&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;커널 모드&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;커널 모드, 링 0, 커널 레벨, 슈퍼 바이저 모드&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;유저 모드&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;유저 모드, 링 3, 유저 레벨, 어플리케이션 모드&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;center&gt;[표 1-1] 커널 모드, 유저모드 용어 정리&lt;/center&gt;

&lt;p&gt;** 윈도우는 4가지의 특권 레벨을 정의하고 있습니다. 하지만, 단지 두 개의 레벨만을 사용하는 이유는 일부 하드웨어 구조(ARM이나 MIPS 등)에서 2가지의 특권 레벨만 구현했기 때문입니다.&lt;/p&gt;

&lt;h5 id=&quot;x86-유저-영역-주소-공간-배치&quot;&gt;x86 유저 영역 주소 공간 배치&lt;/h5&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x01_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;[그림 1-2]&lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;그림 1-2는 우리가 중점적으로 알아볼 유저영역의 메모리 배치입니다. 위 그림에서 볼 수 있듯이, 유저 영역은 스택, 힙, 공유라이브러리, PE Image 등으로 구성되어 있습니다. 또한, 각 영역의 주소가 임의로 할당됨을 알 수 있습니다. 메모리 보호기법 중 하나인 ASLR이 적용되어 위 그림과 같이 각 영역의 주소가 임의로 할당되는 것이죠. 그럼 계산기 프로그램을 가지고 실제로 저렇게 할당되는지 살펴보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x01_3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;[그림 1-3]&lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;그림 1-3은 Sysinternals suites의 vmmap을 통해 살펴 본 계산기의 메모리 구조입니다. 계산기를 종료한 후 다시 실행해보면 위치 값이 이전과 다르다는 것도 확인할 수 있습니다. 또한, vmmap은 각 할당 유형에 따라 다음과 같은 요약된 형태로 보여줍니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Image&lt;/strong&gt; : 실행 파일과 동적 라이브러리 같은 의존물, PE Image 파일을 매핑하는 데 사용되는 메모리 할당&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Shareable&lt;/strong&gt; : 일반적으로 공유 메모리를 포함해 공유 속성으로 설정된 메모리 할당&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Heap&lt;/strong&gt; : 프로세스가 소유한 힙을 위해 할당된 메모리 영역&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Stack&lt;/strong&gt; : 프로세스 내의 각 스레드를 위한 스택 용도로 할당된 영역&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Private Data&lt;/strong&gt; : 스택이나 힙을 제외한 전용 데이터(내부 데이터 구조체 등)로 표시된 메모리 영역&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;지금까지 윈도우 시스템의 가상 메모리 할당에 대한 대략적인 부분을 알아봤습니다. 이 글의 도입부에서 제가 각 프로세스 별로 4GB를 지원한다고 했습니다. 그런데 일반적으로 여러분들이 사용하는 PC의 RAM은 4~16GB 정도인데, 어떻게 실행하는 모든 프로세스마다 4GB를 지원할 수 있을까요?&lt;/p&gt;

&lt;h5 id=&quot;paging&quot;&gt;Paging&lt;/h5&gt;

&lt;p&gt;대부분의 시스템이 프로세스 실행에 사용하는 가상 메모리의 총합보다 작은 물리 메모리를 가지고 있습니다. 그래서 윈도우의 메모리 관리자는 프로세스가 사용하는 메모리 내용의 일부를 디스크로 보냅니다. 데이터를 디스크에 전송하면서 물리 메모리의 공간을 비울 수 있고, 그 자리를 다른 프로세스가 사용할 수 있도록 지원합니다. 만약 디스크에 전송한 내용을 사용하기 위해 가상 주소를 접근할 경우, 동일한 과정을 거쳐 메모리로 정보를 다시 가져옵니다. 이런 방식으로 윈도우에서는 메모리를 관리하고 있고, 디스크로 또는 메모리로 매핑하는 데이터의 단위를 페이지라고 부르고 기본 크기는 4KB입니다. 그림 1-4은 방금 설명한 페이징을 나타냅니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x01_4.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;[그림 1-4]&lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h5 id=&quot;공유-메모리&quot;&gt;공유 메모리&lt;/h5&gt;

&lt;p&gt;공유 메모리란, 프로세스와 운영체제 사이의 공통으로 사용하는 메모리를 이야기합니다. 각 프로세스는 개별 데이터를 저장하거나 실행하기 위해 자신만의 메모리 공간을 갖겠지만, 여러 프로세스에서 동일하게 사용하는 부분은 굳이 여러 번 메모리에 할당할 필요가 없습니다. 그래서 윈도우는 그림 1-5과 같이 동일한 dll이나 다른 자원을 물리 메모리로 한 번만 로딩시키고 공유해서 사용하도록 구성되어 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x01_5.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;[그림 1-5]&lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;이런 구조를 사용함으로써 메모리를 좀 더 효율적으로 사용할 수가 있게 됩니다.&lt;/p&gt;

&lt;p&gt;윈도우 메모리 구조에 대해 중요한 기본 개념들을 살펴봤습니다.
다음 연재에서는 본격적으로 Stack의 구조와 Stack에서 일어날 수 있는 취약점들에 대해서 알아보도록 하겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Joel Park</name>
        
        
      </author>

      

      
        <category term="Posts" />
      

      
        <summary type="html">0x01 윈도우 메모리</summary>
      

      
      
    </entry>
  
</feed>
