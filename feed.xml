<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2019-02-08T22:33:30+09:00</updated><id>/</id><title type="html">LIN ARENA</title><subtitle>LIN ARENA Technology Blog</subtitle><entry><title type="html">linux_0x01</title><link href="/linux_0x01" rel="alternate" type="text/html" title="linux_0x01" /><published>2019-02-08T19:18:00+09:00</published><updated>2019-02-08T19:18:00+09:00</updated><id>/linux_0x01</id><content type="html" xml:base="/linux_0x01">&lt;h2 id=&quot;buffer-overflow-뭐임뭐임뭐임&quot;&gt;Buffer Overflow 뭐임?뭐임?뭐임?&lt;/h2&gt;

&lt;p&gt;BOF란 &lt;strong&gt;메모리&lt;/strong&gt;의 동작 과정중의 오류로 인한 잘못된 동작을 유도하는 취약점입니다. 프로세스가 데이터를 &lt;strong&gt;버퍼&lt;/strong&gt;에 저장 시 입력 값의 크기를 검증하지 않을 경우 주어진 버퍼를 넘어선 즉, 지정된 위치가 아닌 곳에 저장되며 인접한 메모리를 덮어 쓰게 됩니다. 인접 메모리에는 기존의 데이터가 저장되어 있으며 &lt;strong&gt;변수, 프로세스 흐름 제어&lt;/strong&gt; 등의 데이터가 포함됩니다. 따라서 메모리 접근 오류로 인한 이상 동작을 하게되며 결과적으로 취약점으로 동작하게 되는것입니다.&lt;/p&gt;

&lt;p&gt;앞으로 이 BOF 취약점을 천천히 알아보고자 합니다. 먼저 BOF를 알기 위해서는 메모리, 레지스터 등의 구조 및 개념과 앞으로 사용될 gdb의 사용법 등 본격적인 시작에 앞 서 필요한 배경 지식에 대하여 짚고 넘어갈 계획입니다.&lt;/p&gt;

&lt;h2 id=&quot;메모리-구조&quot;&gt;메모리 구조&lt;/h2&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x01-1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;[그림 1-1]&lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;먼저 BOF를 알기 위해선 메모리를 알아야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Kernel&lt;/strong&gt; : OS의 중요 코드들이 로드되며 일반 사용자는 접근 불가한 영역&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;off-limit&lt;/strong&gt; : 사용자의 Kernel 접근을 막기 위해 설정한 영역&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Stack&lt;/strong&gt; : 환경변수, 파라미터, 반환되는 주소 및 지역변수 등 임시적인 데이터를 저장하는 공간이며, 높은 메모리 주소에서 낮은 메모리 주소로 저장됨&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;libc&lt;/strong&gt; : 프로그램 내부에서 사용하는 라이브러리 함수들과 관련된 공유 라이버리 파일이 정장되는 공간&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Heap&lt;/strong&gt; : 엉덩…아니 필요에 의해 사용되는 동적 변수의 데이터가 저장되는 공간이며, 낮은 메모리 주소에서 높은 메모리 주소로 저장됨&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;BSS / Data&lt;/strong&gt; : 전역변수, 정적변수, 배열, 구조체 등이 저장되는 구조이며 차이는 아래와 같다
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;BSS&lt;/strong&gt; : 초기화 되지 않은, 0으로 초기화, Null로 초기화된 데이터의 경우 저장되는 공간&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Data&lt;/strong&gt; : 초기화 된 데이터가 저장 되는 공간&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Code&lt;/strong&gt; : 실제로 실행되는 hex, bin과 같은 파일내부에 실행되는 코드들이 저장되며 기계어 명령어, 어셈블리 코드가 실행되는 영역&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이것은 간단하게 정리한 내용입니다. 여기서 Stack과 Heap의 동작 방향이 다르다는 것이 특이한 모습을 보입니다. 왜 그럴까요?&lt;/p&gt;

&lt;p&gt;간단히 말씀 드리자면 효율적인 메모리 관리와 Kernel영역의 보호를 위해 저런 모습으로 설계 되었습니다. Stack은 Kernel의 반대 방향으로 움직이고 Stack과 Heap 사이에 libc를 배치하여 메모리 관리의 효율성을 높인것이죠.&lt;/p&gt;

&lt;p&gt;이제 메모리를 간단히 알아 보았으니 메모리 중 Stack에 관하여 간단히 짚고 넘어가도록 하겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;stack&quot;&gt;Stack?&lt;/h2&gt;

&lt;p&gt;Stack의 역할은 위에서 언급했으니 패스하고 동작 장식에 대하여 알아 보도록 하겠습니다. Stack은 기본적으로 &lt;strong&gt;후입선출&lt;/strong&gt;(LIFO, Last in First out)의 방식으로 동작합니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/linux/0x01-2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;[그림 1-2]&lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Stack의 동작은 위와 같습니다. 16byte의 Stack공간에 A(4byte) 데이터를 저장시 PUSH를 통하여 저장합니다. 밀어 넣는다는 거죠. 이 때 ESP -4 즉 스택 포인터의 값을 총값에서 -4값을 저장 해둡니다. 왜일까요?&lt;/p&gt;

&lt;p&gt;Stack은 메모리의 높은 주소값에서 낮은 주소값으로 이동하기 떄문에 16byte 에서 4byte씩 줄이는 것이죠. 높은 곳에서 낮은 곳으로.&lt;/p&gt;

&lt;p&gt;다음으로 B 데이터를 저장시 마찬가지로 PUSH를 통하여 A데이터 위에 밀어 넣게 됩니다. ESP 값 또한 -4의 값을 저장 합니다. C 데이터까지 같은 방식으로 데이터를 저장 합니다. 그런데 다시 A 데이터를 빼고 싶다면?&lt;/p&gt;

&lt;p&gt;앞서 말했던 Stack의 동작 방식인 &lt;strong&gt;후입선출&lt;/strong&gt;에 의해 C 데이터를 POP을 통하여 뽑고 ESP의 값은 -4가 아닌 +4의 값을 저장합니다. 이어서 B데이터를 뽑은 후 A 데이터를 뽑을수 있습니다. 이것이 Stack의 동작 방식이며 후입선출입니다.&lt;/p&gt;

&lt;p&gt;결과적으로 Stack을 정리하자면 &lt;strong&gt;메모리의 높은 주소값에서 낮은 주소값으로  데이터가 저장&lt;/strong&gt;되며 동작 방식은 &lt;strong&gt;후입선출&lt;/strong&gt;의 방식으로 동작 합니다. 위에서 나온 ESP의 경우 레지스터의 한 종류로서 레지스터는 포인터, 산술 연산, 인덱스, 세그먼트, 플래그 등이 있으며  필요한 몇가지의 레지스터만 간단하게 정리하자면 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;포인터 레지스터 : 포인터와 관련된 레지스터&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;EIP&lt;/strong&gt; (Instruction Pointer) : CPU가 실행할 다음 명령어의 주소값을 나타냄&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;EBP&lt;/strong&gt; (Base Pointer) : 현재 스택의 최하단 주속밧을 나타냄, EBP의 다음 주소는 Return값을 나타냄&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ESP&lt;/strong&gt; (Stack Pointer) : 현재 스택의 최상단 주소값을 나타냄&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;산술 연산 레지스터 : 산술 논리 연산에 필요한 레지스터&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;EAX&lt;/strong&gt; (Accumulator Register) : 산술 논리 연산에 필요한 상수 또는 변수값이 저장되며 함수의 리턴값 저장&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ECX&lt;/strong&gt; (Counter Register) : 반복문 동작시 반복문의 반복 횟수를 저장&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;EDX&lt;/strong&gt; (Data Register) : EAX 레지스터를 보조&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;인덱스 레지스터 : 작업에 필요한 데이터의 주소값 저장에 사용되는 레지스터&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ESI&lt;/strong&gt; (Source Index) : 데이터 복사 및 조작할 때 사용하는 데이터 주소를 저장(ESI &amp;lt;&amp;gt; EDI)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;EDI&lt;/strong&gt; (Destination Index) : 데이터 복사시 목적지의 주소 저장 (EDI &amp;lt;&amp;gt; ESI)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;레지스터의 사용 이유는 CPU의 빠른 작업 처리를 위해 사용 됩니다. CPU내부에 위치하여 메모리에 접근하는 것보다 더욱 빠른 속도로 접근 가능합니다. 단, 별도의 데이터를 저장 하기엔 용량이 작기에 위에서 알아본 특수한 목적에 맞는 특정 데이터만 저장해두며 CPU의 빠른 동작을 지원 해줍니다.&lt;/p&gt;

&lt;p&gt;레지스터의 종류는 위의 내용 외 더욱 다양한 레지스터가 존재 하지만 현재 필요한 레지스터 및 알아두면 좋을 레지스터를 알아 보았습니다. 급하게 외우기보단 반복적으로 사용하다 보면 필요한 레지그터의 값만 빠르게 살펴보고 자연스럽게 기억이 되실겁니다.&lt;/p&gt;

&lt;p&gt;마지막으로 어셈블리어 명령어에 대하여 알아보도록 하겠습니다. 위에서 Stack의 후입선출의 동작 방식을 알아보는 과정 중 PUSH, POP 그리고 언급은 없었지만 NOP라는 단어가 보였습니다. 이 단어들이 어셈블리어의 명령어이며, 어셈블리어란 컴퓨터 프로그래밍의 저급 언어입니다. 쉽게 말해 컴퓨터가 알아먹기 쉽도록 구성된 언어입니다. 다양한 명령어가 있으며 여기서도 필요한 또는 알아두면 나중에 좋을만한 내용들만 알아보도록 하겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;PUSH&lt;/strong&gt; : 데이터를 스택에 쌓음&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;POP&lt;/strong&gt; : 스택의 저장된 데이터를 뽑음&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;NOP&lt;/strong&gt; : 아무 동작 안함&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;MOV&lt;/strong&gt; : 데이터 이동&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CALL&lt;/strong&gt; : 특정 주소의 함수를 호출, JMP와 같이 실행의 흐름이 변경되지만 호출된 함수의 동작이 종료되면 돌아갈 리턴 주소를 Stack에 저장해 둔다는 차이점이 있음&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;JMP&lt;/strong&gt; : 특정 주소의 함수로 이동하며 JMP 외의 다양한 조건 점프 명령어가 있음&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ADD&lt;/strong&gt; : 덧셈 명령을 수행&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SUB&lt;/strong&gt; : 뺄셈 명령을 수행&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 리스트 외에도 곱셈, 나눗셈, AND, OR, XOR 연산 및 조건 분기 등 다양한 기능의 명령어들이 존재 합니다. 이 명령어들 또한 레지스터들과 함께 자연스럽게 익혀 나가시면 됩니다.&lt;/p&gt;

&lt;p&gt;다음 포스트에는 간단한 BOF 공격과 공격에 필요한 내용들을 추가적으로 정리해보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;천천히 갑시다. 조바심 내지 말고 천천히 탄탄하게.&lt;/p&gt;</content><author><name>Sulla</name></author><category term="Posts" /><summary type="html">Buffer Overflow 뭐임?뭐임?뭐임?</summary></entry><entry><title type="html">windows-0x01</title><link href="/windows-0x01" rel="alternate" type="text/html" title="windows-0x01" /><published>2019-02-07T19:18:00+09:00</published><updated>2019-02-07T19:18:00+09:00</updated><id>/windows-0x01</id><content type="html" xml:base="/windows-0x01">&lt;h1 id=&quot;0x01-윈도우-메모리&quot;&gt;0x01 윈도우 메모리&lt;/h1&gt;

&lt;h3 id=&quot;가상-메모리&quot;&gt;가상 메모리&lt;/h3&gt;

&lt;h5 id=&quot;x86-메모리-구조&quot;&gt;x86 메모리 구조&lt;/h5&gt;
&lt;p&gt;x86 윈도우의 경우 각 프로세스 별로 최대 4GB를 지원합니다. 이 중 상위 절반(0xFFFFFFFF~0x80000000)은 OS 메모리로 사용하고(커널영역), 나머지 하위 절반(0x7FFFFFFF~0x00000000)은 프로세스가 독립적으로 사용할 수 있도록 제공합니다.(유저영역)
그림 1-1는 32비트 윈도우에 의해 지원되는 전형적인 가상 주소 공간 배치를 나타냅니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x01_1.png&quot; alt=&quot;[그림 1-1]&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;[그림 1-1]&lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;그림 1-1에서 확인하였듯이 커널 영역은 다른 프로세스와 공통으로 사용하는 구조로 되어 있습니다. 그리고 이 영역은 OS가 사용하는 아주 중요한 영역입니다. 그래서 윈도우에서는 유저 영역에서 운영체제의 데이터에 접근하거나 수정하는 것을 막기 위해 두 가지 접근 모드(커널모드, 유저모드)를 사용합니다. &lt;strong&gt;유저 모드&lt;/strong&gt;는 커널 영역에 대한 접근을 할 수가 없지만, &lt;strong&gt;커널 모드&lt;/strong&gt;는 모든 시스템 메모리와 모든 CPU 명령어 등에 대해 접근이 허가된 실행모드를 말합니다. 이렇게 함으로써, 윈도우는 운영체제 시스템 커널에 잘못된 사용자 어플리케이션이 오동작을 유발하여, 시스템 전체의 안정성을 해치지 않게 보장하고 있습니다. 표 1-1은 커널모드, 유저모드를 뜻하는 다양한 용어들에 대한 정리입니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;모드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;용어&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;커널 모드&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;커널 모드, 링 0, 커널 레벨, 슈퍼 바이저 모드&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;유저 모드&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;유저 모드, 링 3, 유저 레벨, 어플리케이션 모드&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;center&gt;[표 1-1] 커널 모드, 유저모드 용어 정리&lt;/center&gt;

&lt;p&gt;** 윈도우는 4가지의 특권 레벨을 정의하고 있습니다. 하지만, 단지 두 개의 레벨만을 사용하는 이유는 일부 하드웨어 구조(ARM이나 MIPS 등)에서 2가지의 특권 레벨만 구현했기 때문입니다.&lt;/p&gt;

&lt;h5 id=&quot;x86-유저-영역-주소-공간-배치&quot;&gt;x86 유저 영역 주소 공간 배치&lt;/h5&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x01_2.png&quot; alt=&quot;[그림 1-2]&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;[그림 1-2]&lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;그림 1-2는 우리가 중점적으로 알아볼 유저영역의 메모리 배치입니다. 위 그림에서 볼 수 있듯이, 유저 영역은 스택, 힙, 공유라이브러리, PE Image 등으로 구성되어 있습니다. 또한, 각 영역의 주소가 임의로 할당됨을 알 수 있습니다. 메모리 보호기법 중 하나인 ASLR이 적용되어 위 그림과 같이 각 영역의 주소가 임의로 할당되는 것이죠. 그럼 계산기 프로그램을 가지고 실제로 저렇게 할당되는지 살펴보겠습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x01_3.png&quot; alt=&quot;[그림 1-3]&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;[그림 1-3]&lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;그림 1-3은 Sysinternals suites의 vmmap을 통해 살펴 본 계산기의 메모리 구조입니다. 계산기를 종료한 후 다시 실행해보면 위치 값이 이전과 다르다는 것도 확인할 수 있습니다. 또한, vmmap은 각 할당 유형에 따라 다음과 같은 요약된 형태로 보여줍니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Image&lt;/strong&gt; : 실행 파일과 동적 라이브러리 같은 의존물, PE Image 파일을 매핑하는 데 사용되는 메모리 할당&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Shareable&lt;/strong&gt; : 일반적으로 공유 메모리를 포함해 공유 속성으로 설정된 메모리 할당&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Heap&lt;/strong&gt; : 프로세스가 소유한 힙을 위해 할당된 메모리 영역&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Stack&lt;/strong&gt; : 프로세스 내의 각 스레드를 위한 스택 용도로 할당된 영역&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Private Data&lt;/strong&gt; : 스택이나 힙을 제외한 전용 데이터(내부 데이터 구조체 등)로 표시된 메모리 영역&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;지금까지 윈도우 시스템의 가상 메모리 할당에 대한 대략적인 부분을 알아봤습니다. 이 글의 도입부에서 제가 각 프로세스 별로 4GB를 지원한다고 했습니다. 그런데 일반적으로 여러분들이 사용하는 PC의 RAM은 4~16GB 정도인데, 어떻게 실행하는 모든 프로세스마다 4GB를 지원할 수 있을까요?&lt;/p&gt;

&lt;h5 id=&quot;paging&quot;&gt;Paging&lt;/h5&gt;

&lt;p&gt;대부분의 시스템이 프로세스 실행에 사용하는 가상 메모리의 총합보다 작은 물리 메모리를 가지고 있습니다. 그래서 윈도우의 메모리 관리자는 프로세스가 사용하는 메모리 내용의 일부를 디스크로 보냅니다. 데이터를 디스크에 전송하면서 물리 메모리의 공간을 비울 수 있고, 그 자리를 다른 프로세스가 사용할 수 있도록 지원합니다. 만약 디스크에 전송한 내용을 사용하기 위해 가상 주소를 접근할 경우, 동일한 과정을 거쳐 메모리로 정보를 다시 가져옵니다. 이런 방식으로 윈도우에서는 메모리를 관리하고 있고, 디스크로 또는 메모리로 매핑하는 데이터의 단위를 페이지라고 부르고 기본 크기는 4KB입니다. 그림 1-4은 방금 설명한 페이징을 나타냅니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x01_4.png&quot; alt=&quot;[그림 1-4]&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;[그림 1-4]&lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h5 id=&quot;공유-메모리&quot;&gt;공유 메모리&lt;/h5&gt;

&lt;p&gt;공유 메모리란, 프로세스와 운영체제 사이의 공통으로 사용하는 메모리를 이야기합니다. 각 프로세스는 개별 데이터를 저장하거나 실행하기 위해 자신만의 메모리 공간을 갖겠지만, 여러 프로세스에서 동일하게 사용하는 부분은 굳이 여러 번 메모리에 할당할 필요가 없습니다. 그래서 윈도우는 그림 1-5과 같이 동일한 dll이나 다른 자원을 물리 메모리로 한 번만 로딩시키고 공유해서 사용하도록 구성되어 있습니다.&lt;/p&gt;

&lt;figure&gt;
  &lt;img data-action=&quot;zoom&quot; src=&quot;/assets/images/windows/0x01_5.png&quot; alt=&quot;[그림 1-5]&quot; /&gt;
  &lt;figcaption&gt;&lt;center&gt;[그림 1-5]&lt;/center&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;이런 구조를 사용함으로써 메모리를 좀 더 효율적으로 사용할 수가 있게 됩니다.&lt;/p&gt;

&lt;p&gt;윈도우 메모리 구조에 대해 중요한 기본 개념들을 살펴봤습니다.
다음 연재에서는 본격적으로 Stack의 구조와 Stack에서 일어날 수 있는 취약점들에 대해서 알아보도록 하겠습니다.&lt;/p&gt;</content><author><name>Joel Park</name></author><category term="Posts" /><summary type="html">0x01 윈도우 메모리</summary></entry><entry><title type="html">windows-0x00</title><link href="/windows-0x00" rel="alternate" type="text/html" title="windows-0x00" /><published>2019-02-06T19:18:00+09:00</published><updated>2019-02-06T19:18:00+09:00</updated><id>/windows-0x00</id><content type="html" xml:base="/windows-0x00">&lt;p&gt;0x00. 서문&lt;/p&gt;

&lt;p&gt;안녕하세요. Joel-Park입니다.&lt;/p&gt;

&lt;p&gt;“Windows Exploit”이라는 주제로 연재를 시작하게 되었습니다. 
본격적으로 시작하기 전에 왜 이 연재를 시작하게 되었는지, 어떤 주제들을 다룰 것인지를 먼저 소개하려고 합니다.&lt;/p&gt;

&lt;p&gt;왜 이 연재를 시작하게 되었는가?&lt;/p&gt;

&lt;p&gt;결론부터 이야기를 드리자면, 자료가 너무 부족하다고 느꼈기 때문입니다.
리눅스 시스템 해킹의 경우는 워게임이나 강좌 등 자료가 많이 존재하지만 윈도우는 찾기가 너무나도 힘이 듭니다. 어렵게 찾은 자료도 영문이라 100% 이해한 건지 확신하기도 어렵죠. 
제가 윈도우 시스템 해킹을 시작하면서 느꼈던 이런 어려움들을 조금은 해소할 수 있지 않을까라는 생각에 연재를 시작하게 되었습니다.&lt;/p&gt;

&lt;p&gt;어떤 주제들을 다룰 것인가?&lt;/p&gt;

&lt;p&gt;Window_7_x86을 대상으로 메모리 구조, 스택과 힙 Exploit의 전반적인 내용을 다룰 것입니다.
그리고 기회가 된다면 Windows 10을 이어서 연재할 예정입니다.( 아직 한다고는 안했습니다. :) )&lt;/p&gt;

&lt;p&gt;이 글이 저와 같은 고민을 하시는 분들에게 조금이나마 도움이 되길 바랍니다.&lt;/p&gt;

&lt;p&gt;감사합니다.&lt;/p&gt;</content><author><name>Joel Park</name></author><category term="Posts" /><summary type="html">0x00. 서문</summary></entry></feed>